### 数组和链表的区别

- **存储**
  - 数组时连续的内存空间，链表不需要连续
- **长度**
  - 数组的长度需要预先确定，若超出数组则会溢出
  - 链表的长度是动态扩展的
- **随机访问**
  - 数组可以随机访问，时间复杂度为O(1)
  - 链表不支持随机访问，平均需要O(n)
- **插入，删除**
  - 数组其实位置的插入和删除， 时间复杂度为O(n)
    - 数组的插入优化：如果与顺序无关，可以交换该位置和最后一位的下一位置的数值，然后插入。
    - 数组的删除优化：不做删除而是做标记，当数组没有存储空间的时候做一次删除操作
  - 链表的时间复杂度为O(1)
- **内存空间**
  - 链表占用的内存空间更大，因为需要额外的指针

### 栈

**数组模拟栈**

```c++
// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空
if (tt > 0)
{

}
```

**栈实现浏览器的前进和后退功能**

使用两个栈，X 和 Y，把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。当通过页面 b 又跳转到新的页面 d ，页面 c 就无法再通过前进、后退按钮重复查看了，所以需要清空栈 Y。

### 队列

**数组模拟队列**

```c++
//1.普通队列
// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh <= tt)
{

}

//2.循环队列
// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh != tt)
{

}
```

### 排序算法

![综合排序算法分析](/Users/wushengna/manual/img/img-post/综合排序算法分析.jpg)

#### 冒泡排序

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。优化操作当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。

```c++
class Solution {
public:
    vector<int> MySort(vector<int>& arr) {
        int n = arr.size();
        for(int i = 0; i < n; i++){
            bool isch = false;
            for(int j = 0; j < n - i - 1; j++){
                if(arr[j] > arr[j + 1]){
                    swap(arr[j],arr[j + 1]);
                    isch = true;
                }
            }
            if(!isch){
                break;
            }
        }
        return arr;
    }
};
```

#### 插入排序

首先将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

```c++
class Solution {
public:
    vector<int> MySort(vector<int>& arr) {
        int n = arr.size();
        for(int i = 1; i < n; i++){
            int s = arr[i];
            int j = i - 1;
            for( ; j >= 0; j--){
                if(arr[j] > s){
                    arr[j + 1] = arr[j];
                }
                else{
                    break;
                }
            }
            arr[j + 1] = s;
        }
        return arr;
    }
};
```

#### 选择排序

选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

```c++
class Solution {
public:
    vector<int> MySort(vector<int>& arr) {
        int n = arr.size();
        for(int i = 0; i < n - 1; i++){
            int minInx = i;
            for(int j = i + 1; j < n; j++){
                if(arr[j] < arr[minInx]){
                    minInx = j;
                }
            }
            swap(arr[minInx],arr[i]);
        }
        return arr;
    }
};
```

#### 归并排序

使用分治思想，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10;
int q[N], tmp[N];
int n;

void merge_sort(int q[], int l, int r){
    if(l >= r){
        return;
    }
    int mid = l + r >> 1;
    
    merge_sort(q,l,mid);
    merge_sort(q,mid + 1,r);
    
    int k = 0, i = l, j = mid + 1;
    while(i <= mid && j <= r){
        if(q[i] <= q[j]){
            tmp[k++] = q[i++];
        }
        else{
            tmp[k++] = q[j++];
        }
    }
    while(i <= mid){
        tmp[k++] = q[i++];
    }
    while(j <= r){
        tmp[k++] = q[j++];
    }
    for(int i = l, j = 0; i <= r; i++, j++){
        q[i] = tmp[j];
    }
    return;
}

int main(){
    scanf("%d",&n);
    for(int i = 0; i < n; i++){
        scanf("%d",&q[i]);
    }
    merge_sort(q,0,n - 1);
    for(int i = 0; i < n; i++){
        printf("%d ",q[i]);
    }
    return 0;
}
```

#### 快速排序

使用分治思想，如果要排序数组中下标从 p 到 r 之间的一组数据，选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10;
int q[N];
int n;

void quick_sort(int q[], int l, int r){
    if(l >= r){
        return;
    }
    int x = q[l + r >> 1], i = l - 1, j = r + 1;
    while(i < j){
        do{
            i++;
        }while(q[i] < x);
        do{
            j--;
        }while(q[j] > x);
        if(i < j){
            swap(q[i],q[j]);
        }
    }
    quick_sort(q,l,j); //边界条件，选择q[l + r >> 1]，区间要用[l,j]和[j + 1,r]
    quick_sort(q,j + 1,r);
    return;
}

int main(){
    scanf("%d",&n);
    for(int i = 0; i < n; i++){
        scanf("%d",&q[i]);
    }
    quick_sort(q,0,n - 1);
    for(int i = 0; i < n; i++){
        printf("%d ",q[i]);
    }
    return 0;
}
```

#### 桶排序

桶排序核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。

**桶排序比较适合用在外部排序中**。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。比如说我们有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。

可以先扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后我们得到，订单金额最小是 1 元，最大是 10 万元。将所有订单根据金额划分到 100 个桶里，第一个桶存储金额在 1 元到 1000 元之内的订单，第二桶存储金额在 1001 元到 2000 元之内的订单，以此类推。每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02...99）。理想的情况下，如果订单金额在 1 到 10 万之间均匀分布，那订单会被均匀划分到 100 个文件中，每个小文件中存储大约 100MB 的订单数据，就可以将这 100 个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。

不过订单按照金额在 1 元到 10 万元之间并不一定是均匀分布的 ，所以 10GB 订单数据是无法均匀地被划分到 100 个文件中的。有可能某个金额区间的数据特别多，划分之后对应的文件就会很大，没法一次性读入内存。针对这些划分之后还是比较大的文件，可以继续划分，比如，订单金额在 1 元到 1000 元之间的比较多，就将这个区间继续划分为 10 个小区间，1 元到 100 元，101 元到 200 元，201 元到 300 元....901 元到 1000 元。如果划分之后，101 元到 200 元之间的订单还是太多，无法一次性读入内存，那就继续再划分，直到所有的文件都能读入内存为止。

#### 计数排序

当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。

先统计每个数值出现的次数，计算小于等于该数的数值有多少，把每个数值放在个数的位置，将个数减1，可以得到排序数组。

计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。

#### 基数排序

基数排序对要排序的数据是有要求的，**需要可以分割出独立的“位”来比较**，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。

假设有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。注意，这里按照每位来排序的排序算法要是稳定的，否则这个实现思路就是不正确的。

有时候要排序的数据并不都是等长的，比如我们排序牛津字典中的 20 万个英文单词，对于这种不等长的数据，可以把所有的单词补齐到相同长度，位数不够的可以在后面补“0”，因为根据ASCII值，所有字母都大于“0”，所以补“0”不会影响到原有的大小顺序，这样就可以继续用基数排序了。

#### 优化方法

STL中的sort并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。当数据量较大时采用快速排序，分段递归，一旦分段后的数据量小于N，为避免递归调用带来过大的额外负荷，便会改用插入排序，因为在小规模数据面前，O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长，而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。

### 二分查找

使用二分查找的情况是可以找到一个条件，正好将数组分为两段，假设目标值在闭区间[l,r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值，二分查找分为整数二分和浮点数二分，整数二分需要考虑边界条件，二分查找的时间复杂度是O(logn)。

#### 整数二分

**版本1**
当我们将区间[l,r]划分成[l,mid]和[mid + 1,r]时，其更新操作是`r = mid`或者`l = mid + 1;`，计算mid时不需要加1。

```c++
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
```

**版本2**
当我们将区间[l,r]划分成[l,mid - 1]和[mid,r]时，其更新操作是`r = mid - 1`或者`l = mid;`，此时为了防止死循环，计算mid时需要加1。

```c++
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

#### 浮点数二分

```c++
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

#### 应用情况

快速定位IP对应的省份地址。

- 二分查找需要使用数组。
- 二分查找针对的是具有一个性质可以把数组分成两份的应用，只能用在插入，删除等操作不频繁的应用中。
- 数据量太小不适合二分查找，顺序遍历就可以，如果数据之间的比较操作很耗时，则最好使用二分查找减小比较次数。
- 数据量太大不适合二分查找，需要连续的数组空间。

### 跳表

链表加多级索引的结构，就是跳表，Redis 中的有序集合（Sorted Set）就是用跳表来实现的，跳表的时间复杂度是O(logn)，而空间复杂度是O(n)，动态的插入和删除操作（删除需要删除节点和索引）也是O(logn)。为了维护平衡性，在插入的时候可以在节点和索引都插入，使用随机函数决定插入哪级索引层。

### 哈希表

散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是O(1)的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。

#### 散列冲突的解决方法

**拉链法**

当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。这两个操作的时间复杂度跟链表的长度k成正比，也就是O(k)，理论上讲，k=n/m，其中n表示散列中数据的个数，m表示散列表中“槽”的个数。基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。

```c++
int h[N], e[N], ne[N], idx;

// 向哈希表中插入一个数
void insert(int x)
{
  int k = (x % N + N) % N; //确定余数是正数
  e[idx] = x;
  ne[idx] = h[k];
  h[k] = idx ++ ;
}

// 在哈希表中查询某个数是否存在
bool find(int x)
{
  int k = (x % N + N) % N;
  for (int i = h[k]; i != -1; i = ne[i])
    if (e[i] == x)
      return true;

    return false;
}
```

**开放寻址法**

使用线性探测，二次探测和双重散列。当数据量比较小、装载因子小的时候，适合采用开放寻址法。

插入：如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。

查找：使用散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。

删除：可以将删除的元素特殊标记为deleted。当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测。

```c++
int h[N];

// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
// 开放两倍数组空间，null是数值范围外的质数
int find(int x)
{
  int t = (x % N + N) % N;
  while (h[t] != null && h[t] != x)
  {
    t ++ ;
    if (t == N) t = 0;
  }
  return t;
}
```

#### 应用情况

Word 文档中单词拼写检查功能，可以用散列表来存储整个英文单词词典，当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。

**字符串哈希**

```c++
//核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
//小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果

typedef unsigned long long ULL;
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64

// 初始化
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}

// 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
```

#### 哈希扩充优化

**哈希表碰撞攻击**

攻击者可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。如果我们使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从 O(1) 急剧退化为 O(n)。如果散列表中有 10 万个数据，退化后的散列表查询的效率就下降了 10 万倍。这样就有可能因为查询操作消耗大量 CPU 或者线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击（DoS）的目的。

**动态扩容**

针对散列表，当装载因子过大时，我们也可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。每次扩容我们都申请一个原来散列表大小两倍最近的质数的空间。

为了解决一次性扩容耗时过多的情况，我们可以**将扩容操作穿插在插入操作的过程中，分批完成**。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。

对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是 O(1)。