### 编译链接的过程

- 预处理阶段：对预处理命令进行替换，头文件展开等预处理操作，hello.c -- `g++ -E helloworld.cpp -o helloworld.i` --> hello.i
- 编译阶段：代码优化和生成汇编代码，hello.i -- `g++ -S helloworld.i -o helloworld.s` --> hello.s
- 汇编阶段：将汇编代码转化为机器语言，hello.s -- `g++ -c helloworld.cpp` --> hello.o
- 链接阶段：将目标文件彼此链接起来，hello.o -- "调用ld进行链接" --> a.out

### 动态链接库和静态链接库的区别

**静态链接库**

- 编译时期链接。

- 浪费空间和资源，如果多个程序链接了同一个库，则每一个生成的可执行文件就都会有一个库的副本，会浪费系统空间。

- 若静态库需修改，需重新编译所有链接该库的程序。

**动态链接库**

- 运行时链接。

- 运行时被链接，故程序的运行速度稍慢。

- 动态库是在程序运行时被链接的，所以磁盘上只须保留一份副本，因此节约了磁盘空间，如果要修改只要用新的库把原来的替换掉即可，可以灵活指定链接位置和链接哪个动态链接库。

**g++编译加载静态链接库**

- 将所有的.cpp文件编译成.o目标文件
  - `g++ -c add.cpp` 生成add.o
  - `g++ -c max.cpp` 生成max.o
- 对生成的.o目标文件打包生成静态链接库
  - `ar cr libfoo.a add.o max.o //libfoo.a是库的名字`
  - ar:做库的命令
  - c:创建库
  - r:将方法添加到库里
- 使用静态链接库
  - `g++ -o main main.cpp -L. -lfoo //这里写的foo是去掉前后缀后库的名字`
  - -L:指定路径 .代表当前路径
  - -l:指定库名
- 执行main文件
  - ./main

**g++编译加载动态链接库**

- 对生成的.o文件处理生成动态链接库，动态链接库的名字为libfoo.so
  - `g++ -fPIC -shared -o libfoo.so add.o max.o`
  - -shared:表示输出结果是共享库类型的
  - -fPIC:表示编译为位置独立的代码，使用地址无关代码（Position Independent Code）技术来生产输出文件
- 动态链接库的使用
  - `cp libfoo.so /usr/lib //将库拷贝到系统库路径下`（不推荐）
  - export更改LD_LIBRARY_PATH当前终端的环境变量
  - 修改/etc/ld.so.conf文件，加入库文件所在目录的路径，然后运行ldconfig 目录名字，该命令会重建/etc/ld.so.cache文件即可
  - 上面三种选一个即可`g++ -o main main.c -L. -lfoo`
- 执行main文件
  - ./main

### include头文件使用<>和""的区别

预处理阶段寻找头文件的目录不同。使用""会**先从当前目录寻找头文件，然后从编译器指定目录寻找头文件，最后从标准库目录下寻找头文件**，由开发人员定义。使用<>则只会**从编译器指定目录和标准库目录下寻找头文件**，标准库目录一般是usr/include，由系统提供。

### g++与gcc的区别

- .c文件被gcc当做C文件编译，g++当做C++文件编译；.cpp文件都会被当做C++文件编译。
- g++在编译阶段调用的是gcc，链接则由自己完成。
- 如果后缀是.c，使用gcc编译器，才不会定义__cplusplus宏。
- extern “C”与gcc和g++无关。

### extern "C"的结果和.cpp编译的区别

- 一个C语言文件p.c

```c++
#include <stdio.h>
void print(int a,int b)
{
       printf("这里调用的是C语言的函数:%d,%d\n",a,b);
}
```

- 一个头文件p.h

```c++
#ifndef _P_H
#define _P_H

void print(int a,int b);

#endif
```

- C++文件调用C函数

```c++
#include <iostream>
using namespace std;
#include "p.h"
int main()
{
       cout<<"现在调用C语言函数\n";
       print(3,4);
       return 0;
}
```

- 编译后链接出错：main.cpp对print(int, int)未定义的引用。
- 原因分析
  - p.c我们使用的是C语言的编译器gcc进行编译的，其中的函数print编译之后，在符号表中的名字为`_print`
  - 我们链接的时候采用的是g++进行链接，也就是C++链接方式，程序在运行到调用print函数的代码时，会在符号表中寻找`_print_int_int`（是按照C++的链接方法来寻找的，所以是找`_print_int_int`而不是找`_print`）的名字，发现找不到，所以会t提示“未定义的引用”。
  - 此时如果我们在对print的声明中加入 extern “C” ，这个时候，g++编译器就会按照C语言的链接方式进行寻找，也就是在符号表中寻找`_print`，这个时候是可以找到的，是不会报错的。
- 总结
  - 编译后底层解析的符号不同，C语言是`_print`，C++是`_print_int_int`。

### 目标文件

编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。

可执行文件（Windows 的 `.exe` 和 Linux 的 `ELF`）、动态链接库（Windows 的 `.dll` 和 Linux 的 `.so`）、静态链接库（Windows 的 `.lib` 和 Linux 的 `.a`）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF）。

### 调试

**系统调用**

应用程序不能直接访问Linux内核，但是应用程序可以跳转到system_call的内核位置，内核会检查系统调用号，这个号码会告诉内核进程正在请求哪种服务。然后，它查看系统调用表，找到所调用的内核函数人口地址，调用该函数，然后返回到进程。**所有操作系统在其内核都有一些内建的函数，这些函数可以用来完成一些系统级别的功能，一般称Linux系统上的这些函数为“系统调用”（system call）**。这些函数代表了用户空间到内核空间的一种转换，例如，在用户空间调用open函数，在内核空间则会调用sys_open。

**系统调用的错误码**

系统调用并不直接返回错误码，而是将错误码放入一个名为errno的全局变量中。如果一个系统调用失败，你可以读出errno的值来确定问题的所在。errno的值只在函数发生错误时设置，如果函数不发生错误，errno的值就无定义，并不会被置为0。

**strace**

strace是一个通过跟踪系统调用来让开发者知道一个程序在后台所做事情的工具。

**gdb**

gdb 是 gcc 的调试工具。要调试 C/C++ 的程序，首先在编译时，必须要使用-g把调试信息加到可执行文件中 ，`gcc -g hello.c -o hello`，`g++ -g hello.cpp -o hello`。

**启动gdb的方法**

- `gdb program`

  program是执行文件，一般在当前目录下。

- `gdb program core`

  用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。

- `gdb program 1234`

  如果程序是一个服务程序，那么可以指定这个服务程序运行时的进程ID，gdb会自动进行attach操作，并调试这个程序。并且program应该在PATH环境变量中搜索得到。

**gdb的常用命令**

l：列出函数代码及其行数。

l 2：查看第2行开始的源代码。

b 16：在代码16行处设置断点。

b func：在函数func处设置断点。

r：运行程序。

c：继续运行。

n：单条执行语句。

s：逐语句单步调试。

p i：打印i变量的值。

bt：查看函数的堆栈。

finish：退出函数。

q：结束调试。

**调试coredump**

coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等，对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。

使用gdb命令对core文件进行调试，`gdb [可执行文件名] [core文件名]`。

**top**

top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况。输入“q”，则退出top命令。

**ps**

ps命令列出的是当前在运行的进程信息，就是执行ps命令的那个时刻的那些进程。

`ps aux`（`a`代表all，`u`代表user，`x`经常与a一起使用）

`ps ajx`（可以看到进程组的信息，能够追溯进程之间的血缘关系）

ps与grep组合使用，查找特定进程，`ps aux|grep test`。

**Valgrind**

Valgrind是一款内存分析工具。

Memcheck是一个内存检查器，能够发现开发中绝大多数内存错误使用情况。

Memcheck检测原理：

（1） Valid-Value表：对于进程的整个地址空间中的每一个字节（Byte），都有与之对应的8bit;对于CPU的每个寄存器，也有一个与之对应的bit向量。这些bit负责记录该字节或者寄存器值是否具有有效的，已初始化的值。

（2） Valid-Address 表：对于进程整个地址空间中的每一个字节（Byte），还有与之对应的1bit，负责记录该地址是否能够被读写。

检测原理 : 当要读写内存中某个字节时，首先检查这个字节对应的 A bit。如果该 A bit显示该位置是无效位置 ，Memcheck则报告读写错误。

使用命令：`/home/sharexu/software/valgrind/bin/valgrind . /test`

### 内存泄漏

内存泄漏是指动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，因而造成了内存的浪费。

**内存泄漏的几种情况：**

1. 在类的构造函数和析构函数中没有匹配使用new和delete函数

   1）在堆里创建了对象占用了内存，但是没有显示地释放对象占用的内存；

   2）在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存。

2. 在释放对象数组时没有使用delete\[\]，使用了delete

   方括号是告诉编译器这个指针指向的是一个对象数组，同时也告诉编译器正确的对象地址值并调用对象的析构函数，如果没有方括号，那么这个指针就被默认为只指向一个对象，对象数组中的其他对象的析构函数就不会被调用，结果造成了内存泄露。如果在方括号中间放了一个比对象数组大小还大的数字，那么编译器就会调用无效对象（内存溢出）的析构函数，会造成堆的奔溃。如果方括号中间的数字值比对象数组的大小小的话，编译器就不能调用足够多个析构函数，结果会造成内存泄露。

   释放单个对象，单个基本数据类型的变量或者是基本数据类型的数组不需要大小参数，释放定义了析构函数的对象数组才需要大小参数。

3. 没有将基类的析构函数定义为虚函数

   当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露

4. 没有正确的清除嵌套的对象指针

5. 指向对象的指针数组只释放了每个对象的空间，没有释放每个指针的空间

   **指向对象的指针数组**不等同于**对象数组**

   对象数组是指：数组中存放的是对象，只需要调用对象数组中的每个对象的析构函数释放空间。

   指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了。

6. 缺少拷贝构造函数

   按值传递会调用（拷贝）构造函数，引用传递不会调用。在C++中，如果没有定义拷贝构造函数，那么编译器就会调用默认的拷贝构造函数，会逐个成员拷贝的方式来复制数据成员，如果是以逐个成员拷贝的方式来复制指针被定义为将一个变量的地址赋给另一个变量。这种隐式的指针复制结果就是两个对象拥有指向同一个动态分配的内存空间的指针，当释放第一个对象的时候，它的析构函数就会释放与该对象有关的动态分配的内存空间，而释放第二个对象的时候，它的析构函数会释放相同的内存，两次释放相同的内存是一种错误的做法，同时可能会造成堆的奔溃。

   所以，如果一个类里面有指针成员变量，要么必须显示的写拷贝构造函数和拷贝赋值函数，要么禁用拷贝构造函数和拷贝赋值函数。

7. 缺少拷贝赋值函数

   拷贝赋值函数也是逐个成员拷贝的方式复制对象，如果这个类的大小是可变的，那么结果就是造成内存泄露，如图：

   ![因缺少赋值运算符造成的内存泄漏](/Users/wushengna/manual/img/img-post/因缺少赋值运算符造成的内存泄漏.png)

### 如何检测内存泄漏，并定位内存泄漏的位置

Linux系统下内存泄漏的检测方法，**valgrind**，**mtrace**，或者对new/malloc进行**统计监测**，看和delete/free次数是否一致。

### 如何避免和解决内存泄漏

1. malloc/free要配套；
2. 使用智能指针；
3. 将基类的析构函数设为虚函数；

### 内存泄漏和内存溢出的区别

**内存泄漏 memory leak** ：是指程序向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果导致一直占据该内存。
**内存溢出 out of memory** ：指程序申请内存时，没有足够的内存供申请者使用，即给了一块存储int类型数据的存储空间，但是申请者却存储long类型的数据，申请者要的内存空间超过了系统实际分配的空间，结果内存不够用。

内存泄漏的堆积最终会导致内存溢出。

### Linux进程状态

TASK_RUNNING（R）：运行态和就绪态的进程；
TASK_INTERRUPTIBLE（S）：可被中断的睡眠状态；
TASK_UNINTERRUPTIBLE（D）：不可被中断的睡眠状态；
TASK_STOP/TASK_TRACED（T）：中止状态，接收到SIGSTOP信号进入该状态，收到SIGCONT后继续执行。若有其它进程在追踪该进程，则为TASK_TRACED状态。
EXIT_DEAD（X）：最终状态，进程终止并被父进程wait收集进程信息后进入该状态。
EXIT_ZOMBIE（Z）：僵尸进程。

### Linux程序内存空间布局

Linux的每个进程都有各自独立的4G逻辑地址，其中0~3G是用户态空间，3~4G是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。逻辑地址分段如下，自下而上：

- 代码段（.text），分为只读存储区和代码区，存放字符串是常量和程序机器代码和指令。

- 数据段（.data），存储已初始化的全局变量，静态变量和常量，是静态存储区。

- bss段，存储未初始化的全局变量和静态变量，及初始化为0的全局变量和静态变量。

- 堆，存放进程运行中被动态分配的内存段，当进程未调用malloc时是没有堆段的，malloc/free开辟的内存空间，向上生长。

- 映射区，存储动态链接库以及调用mmap函数进行的文件映射。

- 栈，存储函数的返回地址、参数、局部变量、返回值，向下生长。
- 命令行参数和环境变量。

### 堆和栈的区别

- **管理方式不同**
  - 栈是由**编译器自动管理**，无需我们手工控制，速度较快。
  - 堆是由**程序员自己申请**，使用new和malloc开辟的一块内存，释放工作由程序员控制，容易产生memory leak，速度较慢。
- **系统响应不同**
  - 栈是只要剩余空间大于申请空间，系统将为程序提供内存，否则报异常，提示栈溢出。
  - 堆在申请时，操作系统会遍历一个记录空闲内存地址的链表，寻找第一个空间中大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete语句才能正确的释放本内存空间。由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分重新放入空闲链表中。
- **空间大小不同**
  - 栈的生长方向是**向下的**，是向着**内存地址减小的方向增长**，是一块**连续的内存区域**，能从栈**获得的空间较小**，例如，在VC6下面，默认的栈空间大小是1M。
  - 堆的生长方向是**向上的**，是向着**内存地址增加的方向增长**，是**不连续的内存区域（链表存储）**，堆的大小受限于计算机系统中有效的虚拟内存，能从堆**获得的空间比较灵活，也比较大**，一般来讲在32位系统下，堆内存可以达到4G的空间。
- **能否产生碎片不同**
  - 栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出。
  - 堆是使用new/delete分配和释放内存，频繁的new/delete会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。