### strlen和sizeof的区别

**(1)** **strlen()**是**函数**，在**运行时**才能计算。参数必须是**字符型指针**(char*)，且必 须是**以’\0’结尾的**。当数组名作为参数传入时，实际上数组已经退化为指针了。 它的功能是**返回字符串的长度**。

**(2)** **sizeof()**是**运算符**，而不是一个函数，在**编译时**就计算好了，用于**计算数据空间的字节数**。因此，sizeof**不能用来返回动态分配的内存空间的大小**。sizeof常用于返回类型和静态分配的对象、结构或数组所占的空间（参数不退化），返回值跟对象、结构、数组所存储的内容没有关系。

```c++
1)数组一一编译时分配的数组空间大小:
char a[10] = ”hello”; //因为char占1Byte，所以sizeof(a) = 10Byte
2)指针一一存储该指针所用的空间大小: 
char *str = ”I am from China.” //因为由存储的是一个字符指针，在32位的机器上，sizeof(str) = 4Byte
3)类型一一该类型所占的空间大小:
int b = 10; //因为在32位的机器上，int类型占4Byte，sizeo(b) = 4Byte
4)对象一一对象的实际占用空间大小:
class Class Sample{
  int a,b;
  int func();
}Class_a; //两个int类型的值是8Byte，sizeof(Class_a) = 8Byte
5)函数一一函数的返回类型所占的空间大小，且函数的返回类型不能是void。
  
int main(int argc, char const *argv[]){
  const char* str = "name";
  
  sizeof(str); //取的是指针str的长度8Byte
  strlen(str); //取的是这个字符串的长度，不包含结尾的\0，大小是4Byte
}
```

### 数组和指针的区别

- **概念不同：** 指针相当于一个变量，它存放的是**数据在内存中的地址**；数组是用于储存**多个相同类型数据的集合**

- **赋值不同：** 同类型指针变量**可以相互赋值**，数组不行，**只能一个一个元素的赋值或拷贝**

- **访问数据不同：** 指针是**间接访问数据**，获取指针，先解引用，再访问指针指向的地址中的内容；数组是**直接访问**

- **sizeof意义不同：** 数组**所占存储空间的内存**：sizeof（数组名），数组的大小：sizeof（数组名）/sizeof（数据类型）；在32位平台下，sizeof（指针名）是4，在64位平台下，sizeof（指针名）是8，得到的是**一个指针变量的字节数**，而不是指针所指的内存容量

- **指针和数组名异同：** 指针和数组名**都可以表示地址**，但指针是**变量**，可以修改；数组名是**常量**，不可修改赋值

- **传参：** 数组传参时会**退化成指针**
  - 退化的意义：C语言只会以值拷贝的方式传递参数，参数传递时，如果是拷贝整个数组，效率会大大降低，并且在参数位于栈上，太大的数组拷贝将会导致栈溢出。因此，C语言将数组的传参进行了退化。将整个数组拷贝一份传入函数时，将数组名看做常量指针，传数组首元素的地址。

### 指针数组和数组指针

指针数组本质是数组，数组指针本质是指针，谁优先级高，本质是谁

- 指针数组：**它实际上是一个数组，数组的每个元素存放的是一个指针类型的元素**。 int* arr[8];
  - 优先级问题：[]的优先级比*高
  - 说明arr是一个数组，而int*是数组里面的内容
  - 这句话的意思就是：arr是一个含有8个int*的数组

- 数组指针：**它实际上是一个指针，该指针指向一个数组**。 int (*arr)[8];
  - 由于[]的优先级比* 高，因此在写数组指针的时候必须将*arr用括号括起来
  - arr先和*结合，说明p是一个指针变量
  - 这句话的意思就是：指针arr指向一个大小为8个整型的数组

### 字符数组和字符串常量

```c++
char arr[] = "hello"; //字符数组
char *arr2 = "hello"; //字符串常量
```

- `char arr[] = "hello"`，此处的赋值是将常量区的字符串"hello"拷贝到了堆栈区的数组arr的空间了。数组arr是在堆栈区开辟了空间，此时是可以修改字符串的值，因为修改的是堆栈区的字符串的值。另外此时的数组名arr是堆栈区中的"hello"的首地址。

- `char *arr2 = "hello"`，指针arr2是存储在堆栈区，但字符串是常量，存储在常量区，只是指针arr2指向了存储在常量区的字符串首地址，此时不能改变常量区的字符串的值。

```c++
const char arr[]="hello"; //这里hello本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区
const char *arr2="hello"; //字符串hello保存在常量区，const本来是修饰arr2指向的值不能通过arr2去修改，但是字符串hello在常量区，本来就不能改变，所以加不加const效果都一样
```

### 函数指针与指针函数

**含义：**

**函数指针**`int (*f)(int x)`是**指向函数入口地址的指针变量**。C++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。

**指针函数**`int* f(int x, int y)`是**返回值是指针的函数**

**声明方式：**

```c++
int func(int a); //声明一个函数
int (*f) (int a); //声明一个函数指针
int *f1(int a); //声明一个指针函数
```

上述的`f`就是一个函数指针，它指向所有返回类型为int，并带有一个int参数的函数

**函数指针的赋值方法：**

```c++
f = &func; //指针名 = &函数名
f = func; //指针名 = 函数名
```

将`func`函数的首地址赋值给函数指针，赋值时函数不带括号，也不带参数，**函数名就代表了函数的首地址**。

**函数指针的调用方法：**

```c++
#include <iostream>
using namespace std;
int Mmin(int x,int y){
  if(x < y)
    return x;
  return y;
}
int Mmax(int x,int y){
  if(x > y)
    return x;
  return y;
}
int main(){
  int (*f)(int x，int y);
  int a=l0 , b = 20;
  f = Mmin; //把Mmin函数的入口地址赋给f
  cout << (*f)(a,b) << endl; //10
  f = Mmax; //把Mmax函数的入口地址赋给f
  cout << (*f)(a,b) << endl; //20
  return 0;
}
```

有了指向函数的指针变量后，就可以实现用该指针变量使用相同参数调用不同函数了，用于调用函数和回调函数

### 引用和指针的区别

- **指针有内存分配，而引用只是一个别名：** 指针是一个变量，**存储的是一个地址**，引用跟原来的变量是同一个东西，**是原变量的别名**，引用声明时必须初始化，从而指向一个已经存在的对象。
- **引用可以看做常量指针，指针是一个存储地址的变量：** 指针在运行时**可以改变其所指向的值**，而引用一旦**和某个对象绑定后就不再改变**。这句话可以理解为：指针可以被重新赋值以指向另一个不同的对象，但是引用则总是指向在初始化时被指定的对象，以后不能改变，但是**指定的对象其内容可以改变**。
- **引用创建时必须初始化，且不为空，指针创建时可以为空：** 不存在指向空值的引用这个事实，意味着**使用引用的代码效率比使用指针的要高**。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空。
- **指针和引用的自增运算符意义不同：** 指针是对**内存地址**的自增，引用是对**值**的自增。
- **sizeof的意义不同：** 使用sizeof看一个**指针的大小**是4，而引用则是**被引用对象的大小**。
- **没有引用常量，有指针常量：** 没有`int& const p`，有`int* const p`。**常量指针和常量引用是存在的**，`const int *p`和`cosnt int &p`，都表示指向的对象为常量，常量引用形参的好处：
  - 使用引用作为形参，不会产生新的变量，**减少形参和实参传递的开销**；
  - 使用引用可能会导致实参随着形参的改变而改变，**声明为const之后就会消除这种副作用**。
- **参数传递：** 作为参数传递时，指针是**间接传递**，指针需要被解引用才可以对对象进行操作，而引用是**直接传递**，直接对引用的修改都会改变引用所指向的对象。
- **多级指针，一级引用：** 指针可以有多级指针（**p），而引用只有一级

### 如何判断大小端存储

**大端字节序**是指一个整数的高位字节存放在内存的低地址处，低位字节存放在内存的高地址处

**小端字节序**是指整数的高位字节存放在内存的内存的高地址处，低位字节存放在内存的低地址处

大端字节序也成为**网络字节序**，当两台采用不同字节序的主机通信时，在发送数据之前发送端都必须经过字节序的转换成为大端字节序后再发送

**判断方法：**

```c++
#include <iostream>

using namespace std;

union U{
    int a;
    char b;
}; //在一个联合体里可以定义多种不同的数据类型，这些数据共享一段内存，在不同的时间里保存不同的数据类型和长度的变量，以达到节省空间的目的，但同一时间只能存储其中一个成员变量的值

int main(){
    U u;
    u.a = 0x1234;
    if(u.b == 0x12){
        cout << "big endian" << endl;
    }
    else if(u.b == 0x34){
        cout << "little endian" << endl;
    }
    return 0;
}
```

### 内存字节对齐的规则和原因

#### 规则

- 对于结构的各个成员，第一个成员位于偏移为0的位置，以后的每个数据成员的偏移量必须是`min(#pragma pack()指定的数,这个数据成员的自身长度)`的倍数
- 在所有的数据成员完成各自对齐之后，结构或联合体本身也要进行对齐，对齐将按照 #pragam pack指定的数值和结构或者联合体最大数据成员长度中比较小的那个，也就是`min(#pragam pack() , 长度最长的数据成员)`

#### 原因

- **平台原因（移植原因）：** **不是所有的硬件平台都能访问任意地址上的任意数据**，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常
- **硬件原因：** 经过内存对齐之后，**CPU的内存访问速度大大提升**。访问未对齐的内存，处理器要访问两次（数据先读高位，再读低位），访问对齐的内存，处理器只要访问一次，为了提高处理器读取数据的效率，我们使用内存对齐

#### struct和union占用字节数的计算

```c++
//struct
#include <cstdio>
#include <iostream>
using namespace std;

struct E1 {
	int a; char b; char c;
}e1; //4 + 1 + 1 + 2 = 8

struct E2 {
	char b; int a; char c;
}e2; //1 + 3 + 4 + 1 + 3 = 12

struct B{
    char a;
    double b;
    int c;
}test_struct_b; //1 + 7 + 8 + 4 + 4 = 24

struct E{

}test_struct_e; //空结构体占用字节数为1，编译器默认分配了一个字节，为了确保两个不同对象的地址不同，让对象的实例能够相互区别，带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定

int main() {
	cout << sizeof(E1) << endl; //8
	
	cout << sizeof(E2) << endl; //12
  
  cout << sizeof(test_struct_b) << endl; //24
  
  cout << sizeof(test_struct_e) << endl; //1
  
	return 0;
}

//union
#include <cstdio>
#include <iostream>
using namespace std;

union A{
    int a[5];
    char b;
    double c;
}; //20 + 4 = 24

int main() {
  cout << sizeof(A) << endl; //24
	return 0;
}

//混合结构体占用字节数
#include <cstdio>
#include <iostream>
using namespace std;
#define LL long long 

struct E5 {
	char a1,a2,a3,a4,a5,a6;
}e5; //1 + 1 + 1 + 1 + 1 + 1 = 6
struct E6 {
	char a1,a2,a3;
}e6; //1 + 1 + 1 = 3
struct E7 {
	struct E5 elem5;
	struct E6 elem6;
	LL a;
}e7; //6 + 3 + 7 + 8 = 24

struct E8 {
	char a[9];
}e8; //9
struct E9 {
	struct E8 elem8;
	LL a;
}e9; //9 + 7 + 8 = 24

typedef union{
    long i;
    int k[5];
    char c;
}UDATA; //4 * 5 + 4 = 24

struct C{
    int cat;
    UDATA cow;
    double dog;
}test_struct_c; //4 + 24 + 4 + 8 = 40

UDATA temp;

int main() {
	cout << sizeof(E5) << endl; //6
  
	cout << sizeof(E6) << endl; //3
  
	cout << sizeof(E7) << endl; //24
	
	cout << sizeof(E8) << endl; //9
  
	cout << sizeof(E9) << endl; //24
  
  cout << sizeof(test_struct_c) + sizeof(temp) << endl; //40 + 24 = 64
	return 0;
}
```

### define和const的区别

- define和const都是**定义常量**的一种方法。

* define定义的常量**没有类型**，const定义的常量是**有类型**的。
* define定义的常量**没有分配内存空间**，只是进行了简单的**替换**，const定义的常量**要分配内存空间**，存放在**静态存储区**。
* define定义的常量可能会有**多个拷贝**，占用的内存空间大，const定义的常量只有**一个拷贝**，占用的内存空间小。
* define定义的常量是在**预处理阶段**进行替换，而const在**编译阶段**确定它的值。
* define**不会进行类型安全检查**（最好加上括号），而const**会进行类型安全检查**，安全性更高。
* define**可以定义函数**，而const**不可以**。
* define**不受定义域限制**，而const**有定义域限制**。
* define可以通过`#undef`来**使之前的define失效**，const常量定义后**将在定义域内永久有效**。

### extern

**extern**是一种“**外部声明**”的关键字，字面意思就是**在此处声明**某种变量或函数，**在外部定义**，即其修饰的变量或函数的定义在其它源文件中，extern关键字的主要作用是扩大变量/函数的作用域，使得其它源文件和头文件可以复用同样的变量/函数，可以实现多文件**共享**同一个变量、const常量和函数

`extern "C"`用于**告诉C++编译器这段代码要按C标准编译**，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题，以保持C++与C的兼容性

### 面向对象特性

**实例化：**通过类创建一个对象的过程，使用对象可以调用类成员函数和成员变量，其中类成员函数称为行为，类成员变量称为属性。

**类和对象的关系：**类是对象的抽象，对象是类的实例。

- **封装**
  - 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
  - public，private，protected
- **继承**
  - 让某种类型对象获得另一种类型对象的属性和方法，可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
  - 基类（父类）——> 派生类（子类）
- **多态**
  - 同一事物表现出不同事物的能力
  - 实现多态的方式：
    - 覆盖（override），子类重新定义父类的虚函数
    - 重载（overload），允许存在多个同名函数，而这些函数的参数表不同

### class和struct的区别

- class的**成员的默认访问权限是private**，struct的**成员的默认访问权限是public**

- class的**默认继承权限是private**，struct的**默认继承权限是public**

- class**可以用作模板**，而struct**不能**

### 类成员属性

- **私有权限：** 私有成员在类内部可以访问，类外不可访问，一般推荐将成员变量设置为私有成员；
- **公有权限：** 类内类外都可以进行访问；
- **保护权限：** 类内和当前类的子类可以访问，类外不可访问。

### 构造函数和析构函数

构造函数和析构函数，分别对应**变量的初始化和清理**。 当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。

- 构造函数：
  - 与类名相同，没有返回值，不写void，**可以发生重载**，可以有参数，编译器自动调用，只调用一次。
  - 系统会默认给一个类提供三个函数：默认构造函数（无参，函数体为空）、默认拷贝构造和析构函数（无参，函数体为空），其中默认拷贝构造可以实现简单的值拷贝。
  - 提供了有参构造函数，就不提供默认构造函数；提供了拷贝构造函数，就不会提供其他构造函数，若自己定义可有参构造，也需要自定义无参构造函数。

- 析构函数：
  - ~类名，没有返回值，不写void，**不可以发生重载**，不可以有参数，编译器自动调用，只调用一次。
  - 如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好自定义析构函数，在销毁类之前，释放掉申请的内存空间，避免内存泄漏。

### 初始化列表的好处和使用条件

**好处：**

- 初始化是直接初始化成员，给数据成员分配内存空间时就进行初始化
- 赋值是初始化再赋值，在所有的数据成员被分配内存空间后才进行

**初始化列表的使用条件：**

- const类型的数据
- 引用类型的数据

### static

- **修饰普通变量：**修改变量的存储区域和生命周期，使变量**存储在静态区**，在 main 函数运行前就分配了空间，**在整个程序运行期间一直存在**，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它，自动初始化为0。
  - **全局静态变量作用域：**全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。
  - **局部变量作用域：**仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

- **修饰普通函数：**其只能在定义它的源文件中使用，不能在其他源文件中被引用。

- **修饰类成员变量和成员函数：**它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过<类名>::<静态成员>来使用。在 static 函数内不能访问非静态成员。

### 静态成员变量和静态成员函数

若将成员变量声明为static，则为静态成员变量，与一般的成员变量不同，无论建立多少对象，都只有一个静态成员变量的拷贝，**静态成员变量属于一个类，所有对象共享**。静态变量**在编译阶段**就分配了空间，对象还没创建时就已经分配了空间，放到**全局静态区**。

- **静态成员变量**
  - 最好是类内声明，类外初始化（以免类名访问静态成员访问不到）。
  - 无论公有，私有，静态成员都可以在类外定义，但私有成员仍有访问权限。
  - 非静态成员类外不能初始化。
  - 静态成员数据是共享的。
- **静态成员函数**
  - 静态成员函数可以直接访问静态成员变量，不能直接访问普通成员变量，但可以通过参数传递的方式访问。
  - 普通成员函数可以访问普通成员变量，也可以访问静态成员变量。
  - 静态成员函数没有this指针。非静态数据成员为对象单独维护，但静态成员函数为共享函数，无法区分是哪个对象，因此不能直接访问普通变量成员，也没有this指针。

### 对象的存储空间

**对象的存储空间：**非静态成员变量总和加上编译器为了CPU计算做出的数据对齐处理和支持虚函数所产生的负担的总和。

**空类的大小：**1Byte，为了确保两个不同对象的地址不同。

### this指针

- **为什么会有this指针：**在类实例化对象时，只有非静态成员变量属于对象本身，剩余的静态成员变量，静态函数，非静态函数都不属于对象本身，因此非静态成员函数只会实例一份，多个同类型对象会共用一块代码，**由于类中每个实例后的对象都有独一无二的地址，因此不同的实例对象调用成员函数时，函数需要知道是谁在调用它，因此引入了this指针**。
- **this指针的作用：**this指针是隐含在对象成员函数内的一种指针，当一个对象被创建后，它的每一个成员函数都会含有一个系统自动生成的隐含指针this。**this指针指向当前被调用的成员函数所在的对象的起始地址**（谁调用成员函数，this指向谁），*this表示对象本身，非静态成员函数中才有this，静态成员函数内部没有。
  - this 并不是一个常规变量，而是个**右值**，所以不能取得 this 的地址（不能 &this）。
  - 对非静态成员函数默认添加了this指针，类型为classname *const this。
- **this指针使用**
  - 当形参与成员变量名相同时，用this指针来区分。
  - 为实现对象的链式引用，在类的非静态成员函数中返回对象本身，可以用return * this，this指向对象，*this表示对象本身。

### 类模板和函数模板

通过template实现，主要用于**数据的类型参数化**，简化代码，有类模板和函数模板，函数模板是用于生成函数的，类模板则是用于生成类的。

- **类模板和函数模板定义**
  - template声明下面是函数定义，则为函数模板，否则为类模板。
  - 注意：每个函数模板前必须有且仅有一个template声明，不允许多个template声明后只有一个函数模板，也不允许一个template声明后有多个函数模板(类模板同理)。

- **类模板与函数模板的区别**
  - 类模板不支持自动类型推导
  - 数据类型可以有默认参数

### 析构函数与构造函数的执行顺序

在一般情况下，**调用析构函数的次序正好与调用构造函数的次序相反**：最先被调用的构造函数，其对应的（同一对象中的）析构函数最后被调用;而最后被调用的构造函数，其对应的析构函数最先被调用。

- **在全局范围中定义的对象**（即在所有函数之外定义的对象），它的构造函数在文件中的所有函数（包括main函数）执行之前调用。 但如果一个程序中有多个文件，而不同的文件中都定义了全局对象，则这些对象的构造函数的执行顺序是不确定的。当 main 函数执行完毕或调用 exit 函数时（此时程序终止），调用析构函数。

- 如果定义的是**局部对象**（如在函数中定义对象），则在建立对象时调用其构造函数。 如果函数被多次调用，则在每次建立对象时都要调用构造函数。在函数调用结束，对象释放时先调用析构函数。

- 如果在函数中定义**静态（static）局部对象**，则只在程序第一次调用此函数建立对象时调用构造函数一次，在调用结束时对象并不释放，因此也不调用析构函数，只在main函数结束或调用exit函数结束程序时，才调用析构函数。

### 派生类的构造函数和析构函数

**构造函数**

- 对**基类成员**和**子对象成员**的初始化必须**在成员初始化列表中**进行，新增成员的初始化既可以在成员初始化列表中进行，也可以在构造函数体中进行。
- 派生类构造函数的**执行顺序**：
  - 先调用**基类构造函数**;
  - 再调用**子对象的构造函数**;
  - 最后调用**派生类的构造函数体**。

- 当**派生类有多个基类**时，处于同一层次的各个基类的构造函数的调用顺序取决于**定义派生类时声明的顺序**（自左向右），而与在派生类构造函数的成员初始化列表中给出的顺序无关。

- 如果**派生类的基类也是一个派生类**，则每个派生类**只需负责其直接基类的构造**，依次上溯。

- 当**派生类中有多个子对象**时，各个子对象构造函数的调用顺序也取决于**在派生类中定义的顺序（自前至后）**，而与在派生类构造函数的成员初始化列表中给出的顺序无关。

- 派生类构造函数提供了将参数传递给基类构造函数的途径，以保证在基类进行初始化时能够获得必要的数据 。 因此如果基类的构造函数定义了一个或多个参数时，派生类必须定义构造函数。

- 如果基类中定义了默认构造函数或根本没有定义任何一个构造函数（此时由编译器自动生成默认构造函数）时，在派生类构造函数的定义中可以省略对基类构造函数的调用。

- 子对象的情况与基类相同。

- 当所有的基类和子对象的构造函数都可以省略时，可以省略派生类构造函数的成员初始化列表。

- 如果所有的基类和子对象构造函数都不需要参数，派生类也不需要参数时，派生类构造函数可以不定义。

**析构函数**

在派生时，**派生类是不能继承基类的析构函数的**，也需要通过派生类的析构函数去调用基类的析构函数。在派生类中可以根据需要定义自己的析构函数，用来对派生类中所增加的成员进行清理工作;基类的清理工作仍然由基类的析构函数负责。在执行派生类的析构函数时，系统会自动调用基类的析构函数和子对象的析构函数，对基类和子对象进行清理。

**派生类构造函数的使用**

```c++
#include <iostream>
#include <string>

using namespace std;

class CStudent{
public: //声明基类Student
  CStudent(int n, string nam, char s){ //基类构造函数
    num = n;
    name = nam;
    sex = s;
  }
  ~CStudent() {} //基类析构函数
protected: //保护部分
  int num;
  string name;
  char sex;
};
class CStudentl:public CStudent{ //声明派生类Student1
public: //派生类的公用部分
  CStudentl(int n, string nam, char s, int a, string ad):CStudent(n,nam,s){ //派生类构造函数
    age = a; //在函数体中只对派生类新增的数据成员初始化
    addr = ad;
  }
  void show(){
    cout << "num: " << num << endl;
    cout << "name: " << name << endl;
    cout << "sex: " << sex << endl;
    cout << "age: " << age << endl;
    cout << "address: " << addr << endl << endl;
  }
  ~CStudentl(){ } //派生类析构函数
private: //派生类的私有部分
  int age;
  string addr;
};
int main(){
  CStudentl stud1(10010,"Wang-1i",'f',19,"115 Beijing Road,Shanghai");
  CStudentl stud2(10011,"Zhang-fun",'m',21,"213 Shanghai Road,Beijing");
  studl.show(); //输出第一个学生的数据
  stud2.show(); //输出第二个学生的数据
  return 0;
}
```

### 派生类构造函数和析构函数的调用顺序

**构造函数的调用顺序**

- **基类构造函数**。如果有多个基类，则构造函数的调用顺序是**某类在类派生表中出现的顺序**，而不是它们在成员初始化表中的顺序。

- **成员类对象构造函数**。如果有多个成员类对象，则构造函数的调用顺序是**对象在类中被声明的顺序**，而不是它们出现在成员初始化表中的顺序。

- **派生类构造函数**。

**析构函数的调用情况**

- 对象生命周期结束被销毁时（一般类成员的指针变量与引用都不自动调用析构函数）。

- delete指向对象的指针时，或者delete指向对象的基类类型指针，而其基类析构函数是虚函数时。

- 对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。

### 重载，覆盖和重写

- **重载（overload）：**是**函数名相同，参数列表不同**。重载只是在同一个类的内部存在，但是**不能靠返回类型来判断**。
- **覆盖（override）：**子类重新定义父类中有相同名称和参数的虚函数，两者的函数特征相同。
  - 被覆盖的函数不能是static的，必须是virtual的。
  - 覆盖函数必须有相同的类型，名称和参数列表。
  - 覆盖函数的访问权限可以不同。尽管virtual是private的，子类中覆盖改写为public，protected也是可以的。
- **重写（overwrite）：**也叫做隐藏，**子类重新定义父类中有相同名称的非虚函数（参数列表可以不同）**。如果一个类，存在和父类相同的函数，那么，这个类将会隐藏其父类的方法，除非你在调用的时候，强制转换为父类类型或加上父类作用域。

### 多态实现的基础

- 继承

- 虚函数覆盖

- 父类指针或引用指向子类对象访问虚函数

```c++
class Animal{
public:
	virtual  void speak(){ //在父类中声明虚函数，可以实现多态，动态联编
		cout << "Animal speak" << endl;
	}
	int m_age = 0;
};

class Sheep :public Animal{
public:
	void speak(){ //发生多态时，子类对父类中的成员函数进行重写，virtual可写可不写
		cout << "Sheep speak" << endl;
	}
	int m_age = 1;
};

void doSpeak(Animal &animal){
	animal.speak();
}

void test01(){
  //传入子类对象调用子类成员函数
	Sheep sheep;
	doSpeak(sheep); //sheep speak;
	
  //子类对象直接调用子类成员函数
	sheep.speak();  //sheep speak;
	
	//子类对象通过作用域调用父类成员函数
  sheep.Animal::speak();  //animal speak;
    
  //基类成员不能转换为子类成员，即不能向下转换
	//Animal *animal0 = new Animal();
	//Sheep * sheep0 = animal0;
	//sheep0->speak();

  //同样不能向下转换
	//Animal animal0;
	//Sheep sheep0 = animal0;

  //父类指针指向子类对象
	Sheep *sheep1 = new Sheep();
	Animal *animal1 = sheep1;
	animal1->speak(); //sheep speak;
	
	//父类引用指向子类对象
	Sheep sheep2;
	Animal &animal2 = sheep2;
	animal2.speak();    //sheep speak;
	
	//子类对象直接赋值给父类对象，不符合多态条件，符合类型兼容性原则
	Sheep sheep0;
	Animal animal0 = sheep0;
	animal0.speak();    //animal speak;
}
```

### 静态多态和动态多态

- 静态多态（运算符重载、函数重载）

- 动态多态（继承、虚函数）

两者主要的**区别**：函数地址是**早绑定（静态联编）**还是**晚绑定（动态联编）**，即在编译阶段确定好地址还是在运行时才确定地址。

### 虚函数指针和虚函数表

- 前提发生了多态，每个类中都有虚函数表，最开始的父类创建虚函数表，后面的子类继承父类的虚函数表，然后对虚函数重写。
- 虚函数重写（覆盖）的实质就是**重写父类虚函数表中的父类虚函数地址**；
- 实现多态的流程：虚函数指针->虚函数表->函数指针->入口地址，**虚函数表（vftable）属于类**，或者说这个类的所有对象共享一个虚函数表；**虚函数指针（vfptr）属于单个对象**。
- 在程序调用时，先创建对象，编译器在对象的内存结构头部添加一个虚函数指针，进行动态绑定，虚函数指针指向对象所属类的虚函数表。
- 虚函数表是一个**指针数组**，其元素是**虚函数的指针**，每个元素对应一个函数的指针。如果子类对父类中的一个或多个虚函数进行重写，子类的虚函数表中的元素顺序，会按照父类中的虚函数顺序存储，之后才是自己类的函数顺序。
- 编译器根本不会去区分传进来的是子类对象还是父类对象，而是关心调用的函数是否为虚函数。如果是虚函数，就根据不同对象的vptr指针找属于自己的函数。父类对象和子类对象都有vfptr指针，传入对象不同，编译器会根据vfptr指针，到属于自己虚函数表中找自己的函数。即：vptr--->虚函数表------>函数的入口地址，从而实现了迟绑定（在运行的时候，才会去判断）。

### 抽象类和纯虚函数

在程序设计中，如果仅仅为了设计一些虚函数接口，打算在子类中对其进行重写，那么不需要在父类中对虚函数的函数体提供无意义的代码，可以通过纯虚函数满足需求。

- 纯虚函数的语法格式：`virtual 返回值类型 函数名 () = 0; `只需要将函数体完全替换为=0即可，**纯虚函数必须在子类中进行实现**，在子类外实现是无效的。
- 注意：
  - 如果父类中出现了一个纯虚函数，则这个类变为了抽象类，抽象类不可实例对象。
  - 如果父类为抽象类，子类继承父类后，必须实现父类所有的纯虚函数，否则子类也为抽象类，也无法实例对象，**但纯虚析构函数例外，因为子类不会继承父类的析构函数**。

### 构造函数和析构函数能否是虚函数

**构造函数不能是虚函数**

- 在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要**构造函数调用完成后才会形成虚表指针**。
- 构造函数不能实现多态，对象在创建时，由编译器对vptr指针进行初始化，只有当对象的构造完全结束后vptr的指向才最终确定。

- 子类中虚函数指针的初始化过程，构造子类对象的时候会首先调用父类的构造函数然后再调用子类的构造函数。当调用父类的构造函数的时候，此时会创建vptr指针，该指针会指向父类的虚函数表；然后再调用子类的构造函数，子类继承父类的虚函数指针，此时vptr又被赋值指向子类的虚函数表。

**析构函数最好是虚函数**

- 仅仅发生继承时，创建子类对象后销毁，函数调用流程为：父类构造函数->子类构造函数->子类析构函数->父类析构函数；

- 当发生多态时（父类指针或引用指向子类对象），通过父类指针在堆上创建子类对象，然后销毁，调用流程为：父类构造函数->子类构造函数->父类析构函数，不会调用子类析构函数，因此子类中会出现内存泄漏问题。解决方法：**将父类中的析构函数设置为虚函数**，设置后会先调用子类析构函数，再调用父类析构函数。

- 纯虚析构函数
  - 纯虚析构函数需要类内声明，类外实现。
  - 纯虚析构函数也是虚函数，该类也为抽象类。
  - 子类不会继承父类的析构函数，当父类纯虚析构函数没有实现时，子类不是抽象类，可以创建对象。

- **C++的默认析构函数不是虚析构函数**，因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存，**而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存**。
- **静态函数不可以是虚函数**，因为虚函数属于对象，不属于类，静态函数属于类。

### 单例模式

定义一个单例类，使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法来获取该实例。单例模式的作用就是保证在整个应用程序的生命周期中的任何一个时刻，单例类的实例都只存在一个（当然也可以不存在）。

单例模式通过类本身来管理其唯一实例，唯一的实例是类的一个普通对象，但设计这个类时，让它只能创建一个实例并提供对此实例的全局访问。

**单例模式使用**

```c++
#include <iostream>

using namespace std;

class CSingleton{
private:
  CSingleton(){ //构造函数是私有的
    
  }
  static CSingleton *m_pInstance;
public:
  static CSingleton *GetInstance(){
    if(m_pInstance == NULL){ //判断是否第一次调用
      m_pInstance = new CSingleton();
    }
    return m_pInstance;
  }
};
CSingleton *CSingleton::m_pInstance = NULL; //初始化静态数据成员
int main(){
  CSingleton *s1 = CSingleton::GetInstance();
  CSingleton *s2 = CSingleton::GetInstance();
  if(s1 == s2){
    cout << "s1 = s2" << endl; //程序的执行结果是输出了s1 = s2
  }
  return 0;
}
```

单例类CSingleton有以下特征：

- 有一个指向唯一实例的静态指针m_plnstance，并且是私有的;

- 有一个公有的函数，可以获取这个唯一的实例，并且在需要的时候创建该实例; 

- 其构造函数是私有的，这样就不能从别处创建该类的实例。

