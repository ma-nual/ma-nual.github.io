### strlen和sizeof的区别

**(1)** **strlen()**是**函数**，在**运行时**才能计算。参数必须是**字符型指针**(char*)，且必须是**以’\0’结尾的**。当数组名作为参数传入时，实际上数组已经退化为指针了。 它的功能是**返回字符串的长度**。

**(2)** **sizeof()**是**运算符**，而不是一个函数，在**编译时**就计算好了，用于**计算数据空间的字节数**。因此，sizeof**不能用来返回动态分配的内存空间的大小**。sizeof常用于返回类型和静态分配的对象、结构或数组所占的空间（参数不退化），返回值跟对象、结构、数组所存储的内容没有关系。

```c++
1)数组一一编译时分配的数组空间大小:
char a[10] = ”hello”; //因为char占1Byte，所以sizeof(a) = 10Byte
2)指针一一存储该指针所用的空间大小: 
char *str = ”I am from China.” //因为由存储的是一个字符指针，在32位的机器上，sizeof(str) = 4Byte
3)类型一一该类型所占的空间大小:
int b = 10; //因为在32位的机器上，int类型占4Byte，sizeof(b) = 4Byte
4)对象一一对象的实际占用空间大小:
class Class Sample{
  int a,b;
  int func();
}Class_a; //两个int类型的值是8Byte，sizeof(Class_a) = 8Byte
5)函数一一函数的返回类型所占的空间大小，且函数的返回类型不能是void。
  
int main(int argc, char const *argv[]){
  const char* str = "name";
  
  sizeof(str); //取的是指针str的长度8Byte
  strlen(str); //取的是这个字符串的长度，不包含结尾的\0，大小是4Byte
}
```

### 数组和指针的区别

- **概念不同：** 指针相当于一个变量，它存放的是**数据在内存中的地址**；数组是用于储存**多个相同类型数据的集合**。

- **赋值不同：** 同类型指针变量**可以相互赋值**，数组不行，**只能一个一个元素的赋值或拷贝**。

- **访问数据不同：** 指针是**间接访问数据**，获取指针，先解引用，再访问指针指向的地址中的内容；数组是**直接访问**。

- **sizeof意义不同：** 数组**所占存储空间的内存**：sizeof（数组名），数组的大小：sizeof（数组名）/sizeof（数据类型）；在32位平台下，sizeof（指针名）是4，在64位平台下，sizeof（指针名）是8，得到的是**一个指针变量的字节数**，而不是指针所指的内存容量。

- **指针和数组名异同：** 指针和数组名**都可以表示地址**，但指针是**变量**，可以修改；数组名是**常量**，不可修改赋值。

- **传参：** 数组传参时会**退化成指针**。
  - 退化的意义：C语言只会以值拷贝的方式传递参数，参数传递时，如果是拷贝整个数组，效率会大大降低，并且在参数位于栈上，太大的数组拷贝将会导致栈溢出。因此，C语言将数组的传参进行了退化。将整个数组拷贝一份传入函数时，将数组名看做常量指针，传数组首元素的地址。

### 函数传入指针是值传递还是引用传递（1）

- 函数传参有**值传递**和**引用传递**。
- 函数传入指针是**值传递**。
- 函数传递指针只是传递指针的值，如果有变量a，传递进去的是a的地址，这个值是复制给了函数体内的形参，在函数体内可以通过这个地址绕回来修改a的内容，但是修改了函数体内的形参，并不能就因此修改a的地址，而引用从原则而言，则是变量自己，在函数体内修改就会作用到原来的变量上。

### 指针数组和数组指针

指针数组本质是数组，数组指针本质是指针，谁优先级高，本质是谁。

- 指针数组：**它实际上是一个数组，数组的每个元素存放的是一个指针类型的元素**。 int* arr[8];
  - 优先级问题：[]的优先级比*高。
  - 说明arr是一个数组，而int*是数组里面的内容。
  - 这句话的意思就是：arr是一个含有8个int*的数组。

- 数组指针：**它实际上是一个指针，该指针指向一个数组**。 int (*arr)[8];
  - 由于[]的优先级比* 高，因此在写数组指针的时候必须将*arr用括号括起来。
  - arr先和*结合，说明arr是一个指针变量。
  - 这句话的意思就是：指针arr指向一个大小为8个整型的数组。

### 字符数组和字符串常量

```c++
char arr[] = "hello"; //字符数组
char *arr2 = "hello"; //字符串常量
```

- `char arr[] = "hello"`，此处的赋值是将常量区的字符串"hello"拷贝到了堆栈区的数组arr的空间了。数组arr是在堆栈区开辟了空间，此时是可以修改字符串的值，因为修改的是堆栈区的字符串的值。另外此时的数组名arr是堆栈区中的"hello"的首地址。

- `char *arr2 = "hello"`，指针arr2是存储在堆栈区，但字符串是常量，存储在常量区，只是指针arr2指向了存储在常量区的字符串首地址，此时不能改变常量区的字符串的值。

```c++
const char arr[] = "hello"; //这里hello本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区
const char *arr2 = "hello"; //字符串hello保存在常量区，const本来是修饰arr2指向的值不能通过arr2去修改，但是字符串hello在常量区，本来就不能改变，所以加不加const效果都一样
```

### 函数指针与指针函数（1）

**含义：**

**函数指针**`int (*f)(int x)`是**指向函数入口地址的指针变量**。C++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。

**指针函数**`int* f(int x, int y)`是**返回值是指针的函数**。

**声明方式：**

```c++
int func(int a); //声明一个函数
int (*f) (int a); //声明一个函数指针
int *f1(int a); //声明一个指针函数
```

上述的`f`就是一个函数指针，它指向所有返回类型为int，并带有一个int参数的函数。

**函数指针的赋值方法：**

```c++
f = &func; //指针名 = &函数名
f = func; //指针名 = 函数名
```

将`func`函数的首地址赋值给函数指针，赋值时函数不带括号，也不带参数，**函数名就代表了函数的首地址**。func的函数名与f函数指针都是一样的，即都是函数指针，func函数名是一个函数指针常量，而f是一个函数指针变量。

**函数指针的调用方法：**

```c++
#include <iostream>

using namespace std;

int Mmin(int x, int y){
    if(x < y)
        return x;
    return y;
}

int Mmax(int x, int y){
    if(x > y)
        return x;
    return y;
}

int main(){
    int (*f)(int x, int y);
    int a = 10, b = 20;
    f = Mmin; //把Mmin函数的入口地址赋给f
    cout << (*f)(a,b) << endl; //10
    f = Mmax; //把Mmax函数的入口地址赋给f
    cout << (*f)(a,b) << endl; //20
    return 0;
}
```

有了指向函数的指针变量后，就可以实现用该指针变量使用相同参数调用不同函数了，用于调用函数和回调函数。

### 引用和指针的区别（2）

- **指针有内存分配，而引用只是一个别名：** 指针是一个变量，**存储的是一个地址**，引用跟原来的变量是同一个东西，**是原变量的别名**，引用声明时必须初始化，从而指向一个已经存在的对象。
- **引用可以看做常量指针，指针是一个存储地址的变量：** 指针在运行时**可以改变其所指向的值**，而引用一旦**和某个对象绑定后就不再改变**。这句话可以理解为：指针可以被重新赋值以指向另一个不同的对象，但是引用则总是指向在初始化时被指定的对象，以后不能改变，但是**指定的对象其内容可以改变**。
- **引用创建时必须初始化，且不为空，指针创建时可以为空：** 不存在指向空值的引用这个事实，意味着**使用引用的代码效率比使用指针的要高**。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空。
- **指针和引用的自增运算符意义不同：** 指针是对**内存地址**的自增，引用是对**值**的自增。
- **sizeof的意义不同：** 使用sizeof看一个**指针的大小**是4，而引用则是**被引用对象的大小**。
- **没有引用常量，有指针常量：** 没有`int& const p`，有`int* const p`。**常量指针和常量引用是存在的**，`const int *p`和`cosnt int &p`，都表示指向的对象为常量，常量引用形参的好处：
  - 使用引用作为形参，不会产生新的变量，**减少形参和实参传递的开销**；
  - 使用引用可能会导致实参随着形参的改变而改变，**声明为const之后就会消除这种副作用**。
- **参数传递：** 作为参数传递时，指针是**间接传递**，指针需要被解引用才可以对对象进行操作，而引用是**直接传递**，直接对引用的修改都会改变引用所指向的对象。
- **多级指针，一级引用：** 指针可以有多级指针（**p），而引用只有一级。

### 在函数参数传递的时候，什么时候使用指针，什么时候使用引用

* 需要返回函数内局部变量的内存的时候用static指针，使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏，而返回局部变量的引用是没有意义的。
* 对栈空间大小比较敏感（比如递归）的时候使用常量引用，使用引用传递不需要创建临时变量，开销要更小。
* 类对象作为参数传递的时候使用常量引用，这是C++类对象传递的标准方式。

### 如何判断大小端存储

**大端字节序**是指一个整数的高位字节存放在内存的低地址处，低位字节存放在内存的高地址处。

**小端字节序**是指整数的高位字节存放在内存的内存的高地址处，低位字节存放在内存的低地址处。

大端字节序也称为**网络字节序**，当两台采用不同字节序的主机通信时，在发送数据之前发送端都必须经过字节序的转换成为大端字节序后再发送。

**判断方法：**

```c++
#include <iostream>

using namespace std;

union U{
    int a;
    char b;
}; //在一个联合体里可以定义多种不同的数据类型，这些数据共享一段内存，在不同的时间里保存不同的数据类型和长度的变量，以达到节省空间的目的，但同一时间只能存储其中一个成员变量的值

int main(){
    U u;
    u.a = 0x1234;
    if(u.b == 0x12){
        cout << "big endian" << endl;
    }
    else if(u.b == 0x34){
        cout << "little endian" << endl;
    }
    return 0;
}
```

### 存储空间（1）

常用数据类型占用的存储空间。

| 数据类型        | 32位编译器 | 64位编译器 |
| :-------------- | :--------- | :--------- |
| char            | 1byte      | 1byte      |
| int             | 4byte      | 4byte      |
| float           | 4byte      | 4byte      |
| double          | 8byte      | 8byte      |
| short           | 2byte      | 2byte      |
| unsigned int    | 4byte      | 4byte      |
| long            | 4byte      | 8byte      |
| unsigned long   | 4byte      | 8byte      |
| long long       | 8byte      | 8byte      |
| 指针            | 4byte      | 8byte      |
| enum(占用同int) | 4byte      | 4byte      |

### 代码判断32位和64位系统

写一个指针，输出指针所占的字节大小。

### 内存字节对齐的规则和原因（3）

#### 规则

- 对于结构的各个成员，第一个成员位于偏移为0的位置，以后的每个数据成员的偏移量必须是`min(#pragma pack()指定的数,这个数据成员的自身长度)`的倍数，使用pragma pack可以通知给编译器传递预编译指令而改变对指定数据的对齐方法。
- 在所有的数据成员完成各自对齐之后，结构体或联合体本身也要进行对齐，对齐将按照 #pragam pack指定的数值和结构或者联合体最大数据成员长度中比较小的那个，也就是`min(#pragam pack() , 长度最长的数据成员)`。

#### 原因

- **平台原因（移植原因）：** **不是所有的硬件平台都能访问任意地址上的任意数据**，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
- **硬件原因：** 经过内存对齐之后，**CPU的内存访问速度大大提升**。访问未对齐的内存，处理器要访问两次（数据先读高位，再读低位），访问对齐的内存，处理器只要访问一次，为了提高处理器读取数据的效率，我们使用内存对齐。

#### struct和union占用字节数的计算

```c++
//struct
#include <cstdio>
#include <iostream>
using namespace std;

struct E1 {
	int a; char b; char c;
}e1; //4 + 1 + 1 + 2 = 8

struct E2 {
	char b; int a; char c;
}e2; //1 + 3 + 4 + 1 + 3 = 12

struct B{
    char a;
    double b;
    int c;
}test_struct_b; //1 + 7 + 8 + 4 + 4 = 24

struct E{

}test_struct_e; //空结构体占用字节数为1，编译器默认分配了一个字节，为了确保两个不同对象的地址不同，让对象的实例能够相互区别，当该空类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小，带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定

class E3{
  static int a;
}; //静态成员变量存放在静态存储区，不占用类的大小，普通函数也不占用类大小

int main() {
	cout << sizeof(E1) << endl; //8
	
	cout << sizeof(E2) << endl; //12
  
  cout << sizeof(test_struct_b) << endl; //24
  
  cout << sizeof(test_struct_e) << endl; //1
  
  cout << sizeof(E3) << endl; //1
  
	return 0;
}

//union
#include <cstdio>
#include <iostream>
using namespace std;

union A{
    int a[5];
    char b;
    double c;
}; //20 + 4 = 24

int main() {
  cout << sizeof(A) << endl; //24
	return 0;
}

//混合结构体占用字节数
#include <cstdio>
#include <iostream>
using namespace std;
#define LL long long 

struct E5 {
	char a1,a2,a3,a4,a5,a6;
}e5; //1 + 1 + 1 + 1 + 1 + 1 = 6
struct E6 {
	char a1,a2,a3;
}e6; //1 + 1 + 1 = 3
struct E7 {
	struct E5 elem5;
	struct E6 elem6;
	LL a;
}e7; //6 + 3 + 7 + 8 = 24

struct E8 {
	char a[9];
}e8; //9
struct E9 {
	struct E8 elem8;
	LL a;
}e9; //9 + 7 + 8 = 24

typedef union{
    long i;
    int k[5];
    char c;
}UDATA; //4 * 5 + 4 = 24

struct C{
    int cat;
    UDATA cow;
    double dog;
}test_struct_c; //4 + 24 + 4 + 8 = 40

UDATA temp;

int main() {
	cout << sizeof(E5) << endl; //6
  
	cout << sizeof(E6) << endl; //3
  
	cout << sizeof(E7) << endl; //24
	
	cout << sizeof(E8) << endl; //9
  
	cout << sizeof(E9) << endl; //24
  
  cout << sizeof(test_struct_c) + sizeof(temp) << endl; //40 + 24 = 64
	return 0;
}
```

### define和const的区别（2）

- define和const都是**定义常量**的一种方法。

* define定义的常量**没有类型**，const定义的常量是**有类型**的。
* define定义的常量**没有分配内存空间**，只是进行了简单的**替换**，const定义的常量**要分配内存空间**，存放在**静态存储区**。
* define定义的常量可能会有**多个拷贝**，占用的内存空间大，const定义的常量只有**一个拷贝**，占用的内存空间小。
* define定义的常量是在**预处理阶段**进行替换，而const在**编译阶段**确定它的值。
* define**不会进行类型安全检查**（最好加上括号），而const**会进行类型安全检查**，安全性更高。
* define**可以定义函数**，而const**不可以**。
* define**不受定义域限制**，而const**有定义域限制**。
* define可以通过`#undef`来**使之前的define失效**，const常量定义后**将在定义域内永久有效**。

### typdef和define区别

- #define是预处理命令，在预处理是执行简单的替换，不做正确性的检查。
- typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名，当const和typedef一起出现时，const给予了整个指针本身以常量性，typedef不会是简单的字符串替换。

### extern（2）

**extern**是一种“**外部声明**”的关键字，字面意思就是**在此处声明**某种变量或函数，**在外部定义**，即其修饰的变量或函数的定义在其它源文件中，extern关键字的主要作用是扩大变量/函数的作用域，使得其它源文件和头文件可以复用同样的变量/函数，可以实现多文件**共享**同一个变量，const常量和函数。

`extern "C"`用于**告诉C++编译器这段代码要按C标准编译**，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题，以保持C++与C的兼容性。

### 面向对象特性（1）

**实例化：**通过类创建一个对象的过程，使用对象可以调用类成员函数和成员变量，其中类成员函数称为行为，类成员变量称为属性。

**类和对象的关系：**类是对象的抽象，对象是类的实例。

- **封装**
  - 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
  - public，private，protected。
- **继承**
  - 让某种类型对象获得另一种类型对象的属性和方法，可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
  - 基类（父类）——> 派生类（子类）
- **多态**
  - 同一事物表现出不同事物的能力。
  - 实现多态的方式：
    - 覆盖（override），子类重新定义父类的虚函数。
    - 重载（overload），允许存在多个同名函数，而这些函数的参数表不同。

### class和struct的区别

- class的**成员的默认访问权限是private**，struct的**成员的默认访问权限是public**。

- class的**默认继承权限是private**，struct的**默认继承权限是public**。

- class**可以用作模板**，而struct**不能**。

### 类成员属性

- **私有权限：** 私有成员在类内部可以访问，类外不可访问，一般推荐将成员变量设置为私有成员；
- **公有权限：** 类内类外都可以进行访问；
- **保护权限：** 类内和当前类的子类可以访问，类外不可访问。

### 构造函数和析构函数（1）

构造函数和析构函数，分别对应**变量的初始化和清理**。 当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。

- 构造函数：
  - 与类名相同，没有返回值，不写void，**可以发生重载**，可以有参数，编译器自动调用，只调用一次。
  - 系统会默认给一个类提供四个函数：默认构造函数（无参，函数体为空）、默认拷贝构造、默认拷贝赋值和析构函数（无参，函数体为空），其中默认拷贝构造和默认拷贝赋值可以实现简单的值拷贝。
  - 提供了有参构造函数，就不提供默认构造函数；提供了拷贝构造函数，就不会提供其他构造函数，若自己定义可有参构造，也需要自定义无参构造函数。

- 析构函数：
  - ~类名，没有返回值，不写void，**不可以发生重载**，不可以有参数，编译器自动调用，只调用一次。
  - 如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好自定义析构函数，在销毁类之前，释放掉申请的内存空间，避免内存泄漏。

### 调用构造函数的方式（1）

- 栈上调用：`A a;`
- 堆上调用：`A* a = new A();`

### 初始化列表的好处和使用条件（1）

**好处：**

- 初始化列表是直接初始化成员，给数据成员分配内存空间时就进行初始化。
- 赋值初始化是初始化再赋值，在所有的数据成员被分配内存空间后才进行。
- 因为使用成员初始化列表进行初始化，会直接使用传入参数的拷贝构造函数进行初始化，省去了一次执行传入参数的默认构造函数的过程，否则会调用一次传入参数的默认构造函数，所以使用成员初始化列表效率会高一些。

**初始化列表的使用条件：**

- const类型的数据，因为const类型数据要在声明后马上初始化，而在构造函数中，做的是对他们的赋值。
- 引用类型的数据，因为引用类型数据要在声明后马上初始化，而在构造函数中，做的是对他们的赋值。
- 没有默认构造函数的对象必须使用成员初始化列表的方式进行初始化。

**成员变量的初始化顺序**

成员是按照他们在类中出现的顺序进行初始化的，而不是按照他们在初始化列表出现的顺序初始化的。

```c++
struct foo
{
    int i ;
    int j ;
    foo(int x):i(x), j(i){}; //ok, 先初始化i，后初始化j
};

struct foo
{
    int i ;
    int j ;
    foo(int x):j(x), i(j){} //i值未定义
};
```

这里i的值是未定义的，虽然j在初始化列表里面出现在i前面，但是i先于j定义，所以先初始化i，但i由j初始化，此时j尚未初始化，所以导致i的值未定义，所以好的习惯是按照成员定义的顺序进行初始化。

### 能否通过初始化列表初始化静态成员变量（1）

不能，静态成员变量最好类内声明，类外初始化。静态成员是单独存储的，并不是对象的组成部分，如果在类的内部进行定义，在建立多个对象时会多次声明和定义该变量的存储位置，在名字空间和作用域相同的情况下会导致重名的问题。

### static（3）

- **修饰普通变量：**修改变量的存储区域和生命周期，使变量**存储在静态区**，在 main 函数运行前就分配了空间，**在整个程序运行期间一直存在**，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它，自动初始化为0。
  - **全局静态变量作用域：**全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。
  - **局部变量作用域：**仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；因为存储在静态存储区，所以**只能初始化一次**，具有记忆性，而以后调用函数的时候不再进行重新分配内存，在函数调用的过程中其值都维持不变。

- **修饰普通函数：**其**只能在定义它的源文件中使用**，不能在其他源文件中被引用。

- **修饰类成员变量和成员函数：**它们是**属于类的**，而不是某个对象，**所有对象共享一个静态成员**。静态成员通过<类名>::<静态成员>来使用。在 static 函数内不能访问非静态成员，**不能被声明为const，虚函数和volatile**。

### 静态成员变量和静态成员函数（1）

若将成员变量声明为static，则为静态成员变量，与一般的成员变量不同，无论建立多少对象，都只有一个静态成员变量的拷贝，**静态成员变量属于一个类，所有对象共享**。静态变量**在编译阶段**就分配了空间，对象还没创建时就已经分配了空间，放到**全局静态区**。

- **静态成员变量**
  - 最好是**类内声明，类外初始化**（保证只被定义和初始化一次，以免类名访问静态成员访问不到）。
  - 无论公有，私有，静态成员都可以在类外定义，但私有成员仍有访问权限。
  - 非静态成员类外不能初始化。
  - 静态成员数据是共享的。
- **静态成员函数**
  - 静态成员函数可以直接访问静态成员变量，不能直接访问普通成员变量，但可以通过参数传递的方式访问。
  - 普通成员函数可以访问普通成员变量，也可以访问静态成员变量。
  - 静态成员函数没有this指针。非静态数据成员为对象单独维护，但静态成员函数为共享函数，无法区分是哪个对象，因此不能直接访问普通变量成员，也没有this指针。

### 对象的存储空间（1）

**对象的存储空间：**非静态成员变量总和加上编译器为了CPU计算做出的数据对齐处理和支持虚函数所产生的负担的总和。

**空类的大小：**1Byte，为了确保两个不同对象的地址不同。

### this指针（1）

- **为什么会有this指针：**在类实例化对象时，只有非静态成员变量属于对象本身，剩余的静态成员变量，静态函数，非静态函数都不属于对象本身，因此非静态成员函数只会实例一份，多个同类型对象会共用一块代码，**由于类中每个实例后的对象都有独一无二的地址，因此不同的实例对象调用成员函数时，函数需要知道是谁在调用它，因此引入了this指针**。
- **this指针的作用：**this指针是隐含在对象成员函数内的一种指针，当一个对象被创建后，它的每一个成员函数都会含有一个系统自动生成的隐含指针this。**this指针指向当前被调用的成员函数所在的对象的起始地址**（谁调用成员函数，this指向谁），*this表示对象本身，非静态成员函数中才有this，静态成员函数内部没有。
  - this 并不是一个常规变量，而是个**右值**，所以不能取得 this 的地址（不能 &this）。
  - 对非静态成员函数默认添加了this指针，类型为classname *const this。
- **this指针使用**
  - 当形参与成员变量名相同时，用this指针来区分。
  - 为实现对象的链式引用，在类的非静态成员函数中返回对象本身，可以用return * this，this指向对象，*this表示对象本身。

### delete this合法吗

合法，但有前提：

- 必须保证this对象是通过new（不是new[]，不是placement new，不是栈上，不是全局，不是其他对象成员）分配的。
- 必须保证调用delete this的成员函数是最后一个调用this的成员函数。
- 必须保证成员函数的delete this后面没有调用this了。
- 必须保证delete this后没有人使用了。

### 定义和声明的区别

* 声明是告诉编译器变量的类型和名字，不会为变量分配空间。

* 定义就是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次。

### 前向声明的优点（1）

可以声明一个类而不定义它，在声明之后，定义之前，类Screen是一个不完全类型(incompete type)，即已知Screen是一个类型，但不知道包含哪些成员，**不完全类型只能以有限方式使用，不能定义该类型的对象，不完全类型只能用于定义指向该类型的指针及引用，或者用于声明(而不是定义)使用该类型作为形参类型或返回类型的函数**。

- 不必再include头文件了，节省编译时间。
- 方便的解决两种类类型互相使用的问题。

### 类模板和函数模板（2）

通过template实现，主要用于**数据的类型参数化**，简化代码，有类模板和函数模板，函数模板是用于生成函数的，类模板则是用于生成类的。

- **类模板和函数模板定义**
  - template声明下面是函数定义，则为函数模板，否则为类模板。
  - 注意：每个函数模板前必须有且仅有一个template声明，不允许多个template声明后只有一个函数模板，也不允许一个template声明后有多个函数模板（类模板同理）。
  - 编译器会对函数模板进行两次编译：**在声明的地方对模板代码本身进行编译，这次编译只会进行语法检查，并不会生成具体的代码，在运行时对代码进行参数替换后再进行编译，生成具体的函数代码**。
  
- **类模板与函数模板的区别**
  - 类模板不支持自动类型推导。
  - 数据类型可以有默认参数。

### 模板特化（1）

模板特化是因为编译器认为，对于特定的类型能对某一功能有更好的实现。模板特化分为全特化与偏特化，全特化就是限定模板实现的具体类型，偏特化就是如果这个模板有多个类型，那么只限定其中的一部分。对于类模板，有全特化也有偏特化，对于函数模板，只有全特化，没有偏特化。

```c++
template<typename T1, typename T2>
class Test
{
public:
  Test(T1 i, T2 j):a(i),b(j){cout<<"模板类"<<endl;}
private:
	T1 a;
	T2 b;
};
 
template<>
class Test<int, char>
{
public:
	Test(int i, char j):a(i),b(j){cout<<"全特化"<<endl;}
private:
	int a;
	char b;
};
 
template <typename T2>
class Test<char, T2>
{
public:
	Test(char i, T2 j):a(i),b(j){cout<<"偏特化"<<endl;}
private:
	char a;
	T2 b;
};
```

### Impl手法的优点（1）

Impl手法是指类的接口和实现分离。

- 公共头文件里面只有接口定义，而不包括实现，即使实现部分有改变不影响接口。类CSample仅向外界暴露了最小的接口，真正的实现由其内部类CImpl来完成。这样无论CImpl如何修改，外界对此一无所知，从而保持接口的不变性。
- 提升编译速度。
- 减少了头文件之间的依赖关系。
- 方便未来重构，接口和实现分离，即使大的架构改动，原有的接口代码改动小，容易平滑过度。

### 析构函数与构造函数的执行顺序（2）

在一般情况下，**调用析构函数的次序正好与调用构造函数的次序相反**：最先被调用的构造函数，其对应的（同一对象中的）析构函数最后被调用;而最后被调用的构造函数，其对应的析构函数最先被调用。

- **在全局范围中定义的对象**（即在所有函数之外定义的对象），它的构造函数在文件中的所有函数（包括main函数）执行之前调用。 但如果一个程序中有多个文件，而不同的文件中都定义了全局对象，则这些对象的构造函数的执行顺序是不确定的。当 main 函数执行完毕或调用 exit 函数时（此时程序终止），调用析构函数。

- 如果定义的是**局部对象**（如在函数中定义对象），则在建立对象时调用其构造函数。 如果函数被多次调用，则在每次建立对象时都要调用构造函数。在函数调用结束，对象释放时先调用析构函数。

- 如果在函数中定义**静态（static）局部对象**，则只在程序第一次调用此函数建立对象时调用构造函数一次，在调用结束时对象并不释放，因此也不调用析构函数，只在main函数结束或调用exit函数结束程序时，才调用析构函数。

### 派生类的构造函数和析构函数

**构造函数**

- 对**基类成员**和**子对象成员**的初始化必须**在成员初始化列表中**进行，新增成员的初始化既可以在成员初始化列表中进行，也可以在构造函数体中进行。
- 派生类构造函数的**执行顺序**：
  - 先调用**基类构造函数**;
  - 再调用**子对象的构造函数**;
  - 最后调用**派生类的构造函数体**。

- 当**派生类有多个基类**时，处于同一层次的各个基类的构造函数的调用顺序取决于**定义派生类时声明的顺序**（自左向右），而与在派生类构造函数的成员初始化列表中给出的顺序无关。

- 如果**派生类的基类也是一个派生类**，则每个派生类**只需负责其直接基类的构造**，依次上溯。

- 当**派生类中有多个子对象**时，各个子对象构造函数的调用顺序也取决于**在派生类中定义的顺序（自前至后）**，而与在派生类构造函数的成员初始化列表中给出的顺序无关。

- 派生类构造函数提供了将参数传递给基类构造函数的途径，以保证在基类进行初始化时能够获得必要的数据 。 因此如果基类的构造函数定义了一个或多个参数时，派生类必须定义构造函数。

- 如果基类中定义了默认构造函数或根本没有定义任何一个构造函数（此时由编译器自动生成默认构造函数）时，在派生类构造函数的定义中可以省略对基类构造函数的调用。

- 子对象的情况与基类相同。

- 当所有的基类和子对象的构造函数都可以省略时，可以省略派生类构造函数的成员初始化列表。

- 如果所有的基类和子对象构造函数都不需要参数，派生类也不需要参数时，派生类构造函数可以不定义。

**析构函数**

在派生时，**派生类是不能继承基类的析构函数的**，也需要通过派生类的析构函数去调用基类的析构函数。在派生类中可以根据需要定义自己的析构函数，用来对派生类中所增加的成员进行清理工作;基类的清理工作仍然由基类的析构函数负责。在执行派生类的析构函数时，系统会自动调用基类的析构函数和子对象的析构函数，对基类和子对象进行清理。

**派生类构造函数的使用**

```c++
#include <iostream>
#include <string>

using namespace std;

class CStudent{
public: //声明基类Student
  CStudent(int n, string nam, char s){ //基类构造函数
    num = n;
    name = nam;
    sex = s;
  }
  ~CStudent() {} //基类析构函数
protected: //保护部分
  int num;
  string name;
  char sex;
};
class CStudentl:public CStudent{ //声明派生类Student1
public: //派生类的公用部分
  CStudentl(int n, string nam, char s, int a, string ad):CStudent(n,nam,s){ //派生类构造函数
    age = a; //在函数体中只对派生类新增的数据成员初始化
    addr = ad;
  }
  void show(){
    cout << "num: " << num << endl;
    cout << "name: " << name << endl;
    cout << "sex: " << sex << endl;
    cout << "age: " << age << endl;
    cout << "address: " << addr << endl << endl;
  }
  ~CStudentl(){ } //派生类析构函数
private: //派生类的私有部分
  int age;
  string addr;
};
int main(){
  CStudentl stud1(10010,"Wang-1i",'f',19,"115 Beijing Road,Shanghai");
  CStudentl stud2(10011,"Zhang-fun",'m',21,"213 Shanghai Road,Beijing");
  studl.show(); //输出第一个学生的数据
  stud2.show(); //输出第二个学生的数据
  return 0;
}
```

### 派生类构造函数和析构函数的调用顺序

**构造函数的调用顺序**

- **基类构造函数**。如果有多个基类，则构造函数的调用顺序是**某类在类派生表中出现的顺序**，而不是它们在成员初始化表中的顺序。

- **成员类对象构造函数**。如果有多个成员类对象，则构造函数的调用顺序是**对象在类中被声明的顺序**，而不是它们出现在成员初始化表中的顺序。

- **派生类构造函数**。

**析构函数的调用情况**

- 对象生命周期结束被销毁时（一般类成员的指针变量与引用都不自动调用析构函数）。

- delete指向对象的指针时，或者delete指向对象的基类类型指针，而其基类析构函数是虚函数时。

- 对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。

### 重载，覆盖和重写（1）

- **重载（overload）：**是**函数名相同，参数列表不同**。重载只是在同一个类的内部存在，但是**不能靠返回类型来判断**。
- **覆盖（override）：**子类重新定义父类中有相同名称和参数的虚函数，两者的函数特征相同。
  - 被覆盖的函数不能是static的，必须是virtual的。
  - 覆盖函数必须有相同的类型，名称和参数列表。
  - 覆盖函数的访问权限可以不同。尽管virtual是private的，子类中覆盖改写为public，protected也是可以的。
- **重写（overwrite）：**也叫做隐藏，**子类重新定义父类中有相同名称的非虚函数（参数列表可以不同）**。如果一个类，存在和父类相同的函数，那么，这个类将会隐藏其父类的方法，除非你在调用的时候，强制转换为父类类型或加上父类作用域。

### 多态实现的基础（5）

- 继承

- 虚函数覆盖

- 父类指针或引用指向子类对象访问虚函数

```c++
class Animal{
public:
	virtual void speak(){ //在父类中声明虚函数，可以实现多态，动态联编
		cout << "Animal speak" << endl;
	}
	int m_age = 0;
};

class Sheep:public Animal{
public:
	void speak(){ //发生多态时，子类对父类中的成员函数进行重写，virtual可写可不写
		cout << "Sheep speak" << endl;
	}
	int m_age = 1;
};

void doSpeak(Animal &animal){
	animal.speak();
}

void test01(){
  //传入子类对象调用子类成员函数
	Sheep sheep;
	doSpeak(sheep); //sheep speak;
	
  //子类对象直接调用子类成员函数
	sheep.speak();  //sheep speak;
	
	//子类对象通过作用域调用父类成员函数
  sheep.Animal::speak();  //animal speak;
    
  //基类成员不能转换为子类成员，即不能向下转换
	//Animal *animal0 = new Animal();
	//Sheep * sheep0 = animal0;
	//sheep0->speak();

  //同样不能向下转换
	//Animal animal0;
	//Sheep sheep0 = animal0;

  //父类指针指向子类对象
	Sheep *sheep1 = new Sheep();
	Animal *animal1 = sheep1;
	animal1->speak(); //sheep speak;
	
	//父类引用指向子类对象
	Sheep sheep2;
	Animal &animal2 = sheep2;
	animal2.speak();    //sheep speak;
	
	//子类对象直接赋值给父类对象，不符合多态条件，符合类型兼容性原则
	Sheep sheep0;
	Animal animal0 = sheep0;
	animal0.speak();    //animal speak;
}
```

### 静态多态和动态多态（4）

- 静态多态（运算符重载、函数重载）。

- 动态多态（继承、虚函数）。

两者主要的**区别**：函数地址是**早绑定（静态联编）**还是**晚绑定（动态联编）**，即在编译阶段确定好地址还是在运行时才确定地址。

### 虚函数指针和虚函数表（6）

- 前提发生了多态，每个类中都有虚函数表，存放在数据段，最开始的父类创建虚函数表，后面的子类继承父类的虚函数表，子类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段（.text）中，然后对虚函数重写，将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。
- 虚函数重写（覆盖）的实质就是**重写父类虚函数表中的父类虚函数地址**；
- 实现多态的流程：虚函数指针->虚函数表->函数指针->入口地址，**虚函数表（vftable）属于类**，或者说这个类的所有对象共享一个虚函数表；**虚函数指针（vptr）属于单个对象**。
- 在程序调用时，先创建对象，编译器在对象的内存结构头部添加一个虚函数指针，进行动态绑定，虚函数指针指向对象所属类的虚函数表。
- 虚函数表是一个**指针数组**，其元素是**虚函数的指针**，在编译阶段创建，每个元素对应一个函数的指针。如果子类对父类中的一个或多个虚函数进行重写，子类的虚函数表中的元素顺序，会按照父类中的虚函数顺序存储，之后才是自己类的函数顺序。
- 编译器根本不会去区分传进来的是子类对象还是父类对象，而是关心调用的函数是否为虚函数。如果是虚函数，就根据不同对象的vptr指针找属于自己的函数，vptr是通过this指针调用的。父类对象和子类对象都有vptr指针，传入对象不同，编译器会根据vptr指针，到属于自己虚函数表中找自己的函数。即：this--->vptr--->虚函数表------>函数的入口地址，从而实现了迟绑定（在运行的时候，才会去判断）。

### 抽象类和纯虚函数（4）

在程序设计中，如果仅仅为了设计一些虚函数接口，打算在子类中对其进行重写，那么不需要在父类中对虚函数的函数体提供无意义的代码，可以通过纯虚函数满足需求。

- 纯虚函数的语法格式：`virtual 返回值类型 函数名 () = 0; `只需要将函数体完全替换为=0即可，**纯虚函数必须在子类中进行实现**，在子类外实现是无效的。
- 注意：
  - 如果父类中出现了一个纯虚函数，则这个类变为了抽象类，抽象类不可实例对象。
  - 如果父类为抽象类，子类继承父类后，必须实现父类所有的纯虚函数，否则子类也为抽象类，也无法实例对象，**但纯虚析构函数例外，因为子类不会继承父类的析构函数**。

### 构造函数和析构函数能否是虚函数（6）

**构造函数不能是虚函数**

- 在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要**构造函数调用完成后才会形成虚表指针**。
- 构造函数不能实现多态，对象在创建时，由编译器对vptr指针进行初始化，只有当对象的构造完全结束后vptr的指向才最终确定。
- 子类中虚函数指针的初始化过程，构造子类对象的时候会首先调用父类的构造函数然后再调用子类的构造函数。当调用父类的构造函数的时候，此时会创建vptr指针，该指针会指向父类的虚函数表；然后再调用子类的构造函数，子类继承父类的虚函数指针，此时vptr又被赋值指向子类的虚函数表。
- 因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的，在构造一个对象时，**由于对象还未创建成功，编译器无法知道对象的实际类型**，是类本身还是类的派生类等。

**析构函数最好是虚函数**

- 仅仅发生继承时，创建子类对象后销毁，函数调用流程为：父类构造函数->子类构造函数->子类析构函数->父类析构函数；
- 当发生多态时（父类指针或引用指向子类对象），通过父类指针在堆上创建子类对象，然后销毁，调用流程为：父类构造函数->子类构造函数->父类析构函数，不会调用子类析构函数，因此子类中会出现内存泄漏问题。解决方法：**将父类中的析构函数设置为虚函数**，如果删除该父类的指针，就会调用该指针指向的子类析构函数，而子类的析构函数又自动调用父类的析构函数，这样整个子类的对象完全被释放。
- 纯虚析构函数
  - 纯虚析构函数需要类内声明，类外实现。
  - 纯虚析构函数也是虚函数，该类也为抽象类。
  - 子类不会继承父类的析构函数，当父类纯虚析构函数没有实现时，子类不是抽象类，可以创建对象。
- **C++的默认析构函数不是虚析构函数**，因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存，**而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存**。
- **静态函数不可以是虚函数**，因为虚函数属于对象，不属于类，静态函数属于类。

**构造函数或者析构函数中调用虚函数会怎样**

- 在基类构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式，不会下放到子类。
- 在析构函数中调用虚函数，此时调用的是子类的函数实现方式，调用这一层对应的函数实现方式而不会是多态。

### 静态绑定和动态绑定

- 静态类型：对象在声明时采用的类型，在编译期既已确定；
- 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；
- 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；
- 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；

非虚函数一般都是静态绑定，而虚函数都是动态绑定。

- 静态绑定发生在编译期，动态绑定发生在运行期；
- 对象的动态类型可以更改，但是静态类型无法更改；
- 要想实现动态，必须使用动态绑定；
- 在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定。

### 虚函数的动态绑定

#### 实例一

```c++
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};

class B : public A {
public:
    virtual void vfunc1();
    void func1();
private:
    int m_data3;
};

class C: public B {
public:
    virtual void vfunc2();
    void func2();
private:
    int m_data1, m_data4;
};
```

声明一个类 A 的指针p来指向对象bObject。虽然p是基类的指针只能指向基类的部分，但是虚表指针亦属于基类部分，所以p可以访问到对象bObject的虚表指针。bObject的虚表指针指向类 B 的虚表，所以p可以访问到 B vtbl。

**使用p来指向类B的对象**

```c++
int main() 
{
    B bObject;
    A *p = & bObject;
    p->vfunc1(); //B::vfunc1()
}
```

程序在执行p->vfunc1()时，会发现p是个指针，且调用的函数是虚函数。

- 首先，根据虚表指针p->`__vptr`来访问对象bObject对应的虚表。虽然指针p是基类`A*`类型，但是`*__vptr`也是基类的一部分，所以可以通过p->`__vptr`可以访问到对象对应的虚表。

- 然后，在虚表中查找所调用的函数对应的条目。由于虚表在**编译阶段**就可以构造出来了，所以可以根据所调用的函数定位到虚表中的对应条目。对于 p->vfunc1()的调用，B vtbl 的第一项即是vfunc1对应的条目。

- 最后，根据虚表中找到的函数指针，调用函数。B vtbl 的第一项指向B::vfunc1()，所以 p->vfunc1()实质会调用B::vfunc1() 函数。

**使用p指向类 A 的对象**

```c++
int main() 
{
    A aObject;
    A *p = &aObject;
    p->vfunc1(); //A::vfunc1()
}
```

当aObject在创建时，它的虚表指针`__vptr`已设置为指向 A vtbl，这样p->`__vptr`就指向 A vtbl。vfunc1在 A vtbl 对应在条目指向了A::vfunc1()函数，所以 p->vfunc1()实质会调用A::vfunc1()函数。

<img src="/Users/wushengna/manual/img/img-post/虚函数的动态绑定.png" alt="虚函数的动态绑定" style="zoom:80%;" />

#### 实例二

```c++
class ClassA
{
public:
	ClassA() { cout << "ClassA::ClassA()" << endl; }
	virtual ~ClassA() { cout << "ClassA::~ClassA()" << endl; }

	void func1() { cout << "ClassA::func1()" << endl; }
	void func2() { cout << "ClassA::func2()" << endl; }

	virtual void vfunc1() { cout << "ClassA::vfunc1()" << endl; }
	virtual void vfunc2() { cout << "ClassA::vfunc2()" << endl; }
private:
	int aData;
};

class ClassB : public ClassA
{
public:
	ClassB() { cout << "ClassB::ClassB()" << endl; }
	virtual ~ClassB() { cout << "ClassB::~ClassB()" << endl; }

	void func1() { cout << "ClassB::func1()" << endl; }
	virtual void vfunc1() { cout << "ClassB::vfunc1()" << endl; }
private:
	int bData;
};

class ClassC : public ClassB
{
public:
	ClassC() { cout << "ClassC::ClassC()" << endl; }
	virtual ~ClassC() { cout << "ClassC::~ClassC()" << endl; }

	void func2() { cout << "ClassC::func2()" << endl; }
	virtual void vfunc2() { cout << "ClassC::vfunc2()" << endl; }
private:
	int cData;
};
```

**基类的虚函数表和子类的虚函数表不是同一个表**。虚函数在代码段，仅有一份。

![虚函数实例1](/Users/wushengna/manual/img/img-post/虚函数实例1.png)

ClassB继承与ClassA，其虚函数表是在ClassA虚函数表的基础上有所改动的，变化的仅仅是在子类中重写的虚函数。如果子类没有重写任何父类虚函数，那么子类的虚函数表和父类的虚函数表在**内容上是一致的**。

```c++
ClassA *a = new ClassB();
a->func1();                    // "ClassA::func1()"   隐藏了ClassB的func1()
a->func2();                    // "ClassA::func2()"
a->vfunc1();                   // "ClassB::vfunc1()"  重写了ClassA的vfunc1()
a->vfunc2();                   // "ClassA::vfunc2()"
```

ClassA类型的指针a能操作的范围只能是黑框中的范围，之所以实现了多态完全是因为子类的虚函数表指针与虚函数表的内容与基类不同，这个结果已经说明了C++的隐藏、重写(覆盖)特性。

![虚函数实例2](/Users/wushengna/manual/img/img-post/虚函数实例2.png)

```c++
ClassA *a = new ClassC();
a->func1();        // "ClassA::func1()"   隐藏ClassB::func1()
a->func2();        // "ClassA::func2()"	  隐藏ClassC::func2()
a->vfunc1();	     // "ClassB::vfunc1()"	ClassB把ClassA::vfunc1()覆盖了
a->vfunc2();	     // "ClassC::vfunc2()"	ClassC把ClassA::vfunc2()覆盖了

ClassB *b = new ClassC();
b->func1();				// "ClassB::func1()"	有权限操作时，子类优先
b->func2();				// "ClassA::func2()"	隐藏ClassC::func2()
b->vfunc1();			// "ClassB::vfunc1()"	ClassB把ClassA::vfunc1()覆盖了
b->vfunc2();			// "ClassC::vfunc2()"	ClassC把ClassA::vfunc2()覆盖了
```

### new/delete和malloc/free的区别（4）

malloc和calloc间的主要区别在于后者在返回指向内存的指针之前把它初始化为0，另一个区别是calloc的参数包括所需的元素的数量和每个元素的字节数。

- **属性不同：**new/delete是**C++关键字**，需要**编译器支持**。malloc/free是**库函数**，需要**头文件支持c**。

- **申请的内存所在位置：**new操作符从**自由存储区**（free store）上为对象动态分配内存空间，而malloc函数从**堆**上动态分配内存。

- **返回类型安全性：**new操作符内存分配成功时，返回的是**对象类型的指针**，类型严格与对象匹配，**无须进行类型转换**，故new是**符合类型安全性**的操作符。 而malloc内存分配成功则是返回**void*类型**，需要通过**强制类型转换将空类型指针转换成我们需要的类型**。

- **内存分配失败时的返回值：**new内存分配失败时，会抛出**bac_alloc异常**，它不会返回NULL；malloc分配内存失败时**返回NULL**。

- **是否需要指定内存大小：**使用new操作符申请内存分配时**无须指定内存块的大小**，编译器会根据类型信息自行计算。而malloc则**需要显式地指出所需内存的大小**。
  - `int *pi = new int; //在自由存储区中分配创建了一个整形对象，并返回一个指向该对象的地址来初始化指针pi`
  - `int *pi = new int(); //对指针pi指向的地址的值进行了初始化为0`
  - `int *pi = new int(1024); //初始化为1024`
  - `int *p = (int *)malloc(100); //指向整型的指针p指向一个大小为100字节的内存的地址`
  - `int *p = (int *)malloc(25*sizeof(int)); //指向整型的指针p指向一个25个int整型空间的地址`

- **数组分配内存（与前一个特点类似）：**new中分配内存**对于变量和数组不同**，malloc分配内存则**相同**。
  - `int *pi = new int[]; //指针pi所指向的数组未初始化`
  - `int *pi = new int[n]; //指针pi指向长度为n的数组，未初始化`
  - `int *pi = new int(); //指针pi所指向的地址初始化为0`

- **是否调用构造函数/析构函数：**new会**先调用operator_ new函数，申请足够的内存（通常底层使用malloc实现），然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针**。delete**先调用析构函数，然后调用operator_ delete函数释放内存（通常底层使用free实现）**。malloc/free是库函数，**只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作**。

- **能否重载：**opeartor_new/operator_delete**允许重载**，malloc/free**不允许重载**。

- **已分配内存的扩充：**malloc/free**可以通过realloc函数扩充**，new/delete**无法直观地处理**。

- **能否相互调用：**operator_new /operator _delete的实现**可以基于malloc/free**，而malloc的实现**不可以去调用new**。

### new运算符的原理（1）

- **内存分配**
  - 调用相应的operator new(size_t)函数，动态分配内存。如果operator new(size_t)不能成功获得内存，则调用new_handler()函数用于处理new失败问题。如果没有设置new_handler()函数或者new_handler()未能分配足够内存，则抛出std::bad_alloc异常。
- **构造函数**
  - 在分配到的动态内存块上初始化相应类型的对象（构造函数）并返回其首地址。如果调用构造函数初始化对象时抛出异常，则自动调用operator delete(void* ,void*)函数释放已经分配到的内存。

### malloc的内存分配机制

首先会扫描之前由free()所释放的空闲内存块列表，以求找到尺寸大于或等于要求的一块空闲内存。如果这一内存块的尺寸正好与要求相当，就将它返回给调用者，如果是一块较大的内存，那么将对其进行分割，在将一块大小相当的内存返回给调用者的同时，把较小的那块空闲内存块保留在空闲列表中。

### 既然有了malloc/free，C++中为什么还需要new/delete呢（1）

* malloc/free和new/delete都是用来申请内存和回收内存的。
* 在对非基本数据类型的对象（类对象）使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数，而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free。

### new，operator new和placement new的区别（1）

- new：不能被重载，先调用operator new分配内存，然后调用构造函数初始化那段内存，最后返回相应指针。
- operator new：要实现不同的内存分配行为，应该重载operator new，而不是new，operator new是可以重载的，如果类中没有重载operator new，那么调用的就是全局的::operator new来完成堆的分配。
- placement new：只是operator new重载的一个版本，并不分配内存，只是返回指向已经分配好的某段内存的一个指针，因此不能删除它，但需要调用对象的析构函数。使用placement new构造对象是在一个预先准备好了的内存缓冲区中进行，不需要查找内存，内存分配的时间是常数，具有较高的效率；而且不会出现在程序运行中途内存不足的异常。

### delete和delete\[\]的区别

* delete只会调用一次析构函数，而delete\[\]会调用每个成员的析构函数。

* 用new分配的内存用delete释放，用new\[\]分配的内存用delete\[\]释放。

### 被free回收的内存是立即返还给操作系统吗

不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回，这样就避免了频繁的系统调用，占用过多的系统资源，同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。

### 面向对象和面向过程的区别（1）

面向对象就是**高度实物抽象化**，面向过程就是**自顶向下的编程**。

- 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用。

- 面向对象是把要解决的问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。

- 面向过程的优缺点
  - 优点：**性能比面向对象高**，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机，嵌入式开发，Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
  - 缺点：没有面向对象易维护，易复用，易扩展。

- 面向对象的优缺点
  - 优点：**易维护，易复用，易扩展**，由于面向对象有封装，继承，多态性的特性，可以设计出低耦合的系统，使系统更加灵活，更加易于维护。
  - 缺点：性能比面向过程低。

### C++和Java的联系与区别（1）

* C++和JAVA都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++ 高。
* C++的内存管理由程序员手动管理，JAVA的内存管理是由JAVA虚拟机完成的，它的垃圾回收使用的是标记-回收算法。
* C++有指针，JAVA没有指针，只有引用。
* C++和JAVA都有构造函数，C++有析构函数但是JAVA没有。

### C++和python的区别（1）

- python是一种脚本语言，是解释执行的，而C++是编译语言，编译后需要在特定平台运行，python可以很方便的跨平台，但是效率没有C++高。
- python使用缩进来区分不同的代码块，C++使用花括号来区分。
- C++中需要事先定义变量的类型，而python不需要，python的基本数据类型只有数字，布尔值，字符串，列表，元组等。
- python的库函数比C++的多，调用起来很方便。

### C++的调用惯例

函数的调用过程：

- 从栈空间分配存储空间。
- 从实参的存储空间复制值到形参栈空间。
- 进行运算。

形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。

数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。

当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递。

### const

- **修饰变量：**说明该变量不可以被改变；

- **修饰指针：**分为常量指针和指针常量；
  - **常量指针**，`const int *p`是指指向常量的指针，就是指针指向的是常量，它不能指向变量，指向的内容不能被改变，不能通过指针来修改它指向的内容，但是指针自身不是常量，它自身的值可以改变，从而指向另一个常量。
  - **指针常量**，`int *const p`是指指针本身是常量，它指向的地址是不可改变的，但地址里的内容可以通过指针改变，注意指针常量在定义时必须同时赋初值。

- **常量引用：**经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；

- **修饰成员函数：**说明该成员函数内不能修改成员变量，不会调用其他非const的成员函数，本质是const this指针。

### volatile

- **不可优化性：**volatile关键字是一种类型修饰符，用它声明的类型变量表示不可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改，所以使用volatile**告诉编译器不应对这样的对象进行优化**。
- **易变性：**volatile关键字声明的变量，**每次访问时都必须从内存中取出值**（没有被volatile修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）。

### mutable（1）

mutable是为了突破const的限制而设置的，被**mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中**。const关键字修饰的函数的一个重要作用就是为了能够保护类中的成员变量，即该函数可以使用类中的所有成员变量，但是不能修改他们的值，然而在某些特殊情况下，我们还是需要在const函数中修改类的某些成员变量，因为即使修改了也不会对类造成多少影响，而且我只想修改某个成员变量，其余成员变量仍然希望被const保护，可以使用mutable修饰变量，需要注意的是mutable不能修饰const 和 static 类型的变量。

### explicit

explicit关键字的作用就是**防止对象间实现=赋值，防止类构造函数的隐式自动转换**，类构造函数默认情况下即声明为implicit（隐式），另外explicit只用于单参数的构造函数，或者除了第一个参数以外的其他参数都有默认值。

- explicit修饰构造函数时，可以防止隐式转换和拷贝初始化。

- explicit修饰转换函数时，可以防止隐式转换。

**explicit用法**

```c++
class Person{
public:
    Person(){
      
    }
    //有参构造初始化数据
    explicit Person(const char *str_){
        str = (char *)malloc(sizeof(char)*100);
        strcpy(str,str_);
    }
    ~Person() {
        if (str != NULL){
            free(str);
            str = NULL;
        }
    }
    char *str;
};
void test05(){
    //Person p = "abc"; 隐式调用
    Person p("abc"); //显式调用
}
```

### strcpy，memcpy和memmove的区别（1）

strcpy和memcpy都是标准C库函数。

- strcpy的函数原型是：**char\* strcpy(char\* dest, const char\* src);**

- memcpy的函数原型是：**void \*memcpy(void \*dest, const char\* src, size_t count);**

**strcpy和memcpy的区别：**

- 复制的内容不同。strcpy只能复制字符串，并且它还会复制字符串的结束符，而memcpy可以复制任意内容，例如字符串、整型、结构体、类等。

- 复制的方法不同。strcpy不需要指定长度，它遇到被复制字符串的结束符"\0”才结束，所以容易溢出。memcpy则是根据第3个参数决定复制的长度。

- 用途不同。通常在复制字符串时用strcpy，而需要复制其它类型的数据是用memcpy。

memcpy和memmove都是C语言中的库函数，在库函数 string.h中，其原型相似，它们都是从src所指向的内存中复制count个字节到dest所指内存中，并返回dest的值。

**memcpy和memmove的区别：**

- 当源内存区域和目标内存区域无交叉重叠时，两者的结果是一样的。

- memcpy是从src的起始部分开始复制，如果有交叉则会发生错误，交叉部分的src内容就会被覆盖掉了。而memmove则由于采用不同的复制机制，所以可以正确处理有交叉的情况。

### 双冒号，using和namespace（1）

- 双冒号::作用域运算符
  - 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间。
  - 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的。
  - 命名空间作用域符（namespace::name）：用于表示指定类型的作用域范围是具体某个命名空间的。
- using分为using声明和using编译指令。
  - `using std::cout; //声明`
  - `using namespace std; //编译指令`
  - 尽量使用声明而不是编译指令，不同命名空间中可能会有相同的变量名，编译指令执行两个命名空间后，会产生二义性。

- namespace主要用来**解决命名冲突的问题**。
  - 必须在全局作用域下声明。
  - 命名空间下可以放函数，变量，结构体和类。
  - 命名空间可以嵌套命名空间。
  - 命名空间是开放的，可以随时加入新成员（添加时只需要再次声明namespace，然后添加新成员即可）。

### 怎样避免头文件冲突（1）

在头文件中使用#ifdef和#ifndef可以防止双重定义的错误，在头文件aaa.h中定义一个类aaa，如果两次#include "aaa.h"（有可能两个不同的头文件中都包含了这个头文件）就会出错，因为相同的类不能定义两次，使用#ifdef和#ifndef，当你已经包含过这个文件，\_aaa_就会有了定义，那么#ifndef的条件为假，就不会再执行后面的类定义了。

```c++
#ifndef   _aaa_
#define   _aaa_
class aaa
{
  
};
#endif
```

### 内联函数和函数重载（1）

- **内联函数**
  - 相当于把内联函数里面的内容写在调用内联函数处；
  - 相当于不用执行进入函数的步骤，直接执行函数体；
  - 相当于宏，却比宏多了类型检查，真正具有函数特性；
  - 不能包含循环，递归，switch等复杂操作；
  - 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数，内联函数对于编译器而言只是一个建议，编译器不一定会接受这种建议，即使没有声明内联函数，编译器可能也会内联一些小的简单的函数。
- C++的函数名称可以重复，称为**函数重载**。
  - 其中必须在同一作用域下的函数名称相同，不能是一个在全局，一个局部，或者不同的代码块中。
  - 可以根据函数参数的个数，类型（const也可以作为重载条件），顺序不同进行函数重载，但**不能用函数返回值进行重载**。
  - 当函数重载遇到函数默认参数时，要注意二义性。

### 虚函数可以是内联函数吗（1）

- 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
- 内联是在**编译期**内联，而虚函数的多态性在**运行期**，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
- 内联函数，需要展开，不存在函数地址，不会写在虚函数表里。
- inline virtual 唯一可以内联的时候是：**编译器知道所调用的对象是哪个类**（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

### #define和内联函数的区别（2）

- 内联函数**在运行时可调试**，而宏定义不可以;
- 编译器会对内联函数的参数类型做**安全检查或自动类型转换**（同普通函数），而宏定义没有安全检查;
- 内联函数是将代码**直接插入调用处**，而减少了普通函数调用时的资源消耗，宏是在代码处不加任何验证的**替换**;
- 内联函数可以**在运行时调用**，而宏只能**在编译时调用**;
- 内联函数可以**访问类的成员变量**，宏定义则不能;
- 在类中声明同时定义的成员函数，自动转化为内联函数。

### 拷贝构造函数与深浅拷贝（1）

**拷贝构造函数的参数必须加const**，因为防止修改，本来就是用现有的对象初始化新的对象。**拷贝构造函数需要传引用而不能传值**，使用拷贝构造函数来初始化一个非引用类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归。

- **拷贝构造函数的使用时机**
  - 使用已经创建好的对象初始化新对象 `A a; A b = a; A c(a); b = c;//b = c不是初始化，调用赋值运算符`
  - 以值传递的方式来给函数参数传值。
  - 以值方式返回局部对象（不常用，一般不返回局部对象）。
- **深拷贝和浅拷贝**，只有当对象的成员属性在**堆区**开辟空间内存时，才会涉及深浅拷贝，如果仅仅是在栈区开辟内存，则默认的拷贝构造函数和析构函数就可以满足要求。
  - **浅拷贝**：使用默认拷贝构造函数，拷贝过程中是**按字节复制**的，对于指针型成员变量**只复制指针本身，而不复制指针所指向的目标**，因此涉及堆区开辟内存时，会将两个成员属性指向相同的内存空间，从而在释放时导致内存空间被多次释放，使得程序down掉。
  - **浅拷贝的问题**：当出现类的等号赋值时，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次free函数，指向的内存空间已经被释放掉，再次free会报错；另外，一片空间被两个不同的子对象共享了，只要其中的一个子对象改变了其中的值，那另一个对象的值也跟着改变了，所以这时必须采用深拷贝。
  - **深拷贝**：自定义拷贝构造函数，**在堆内存中另外申请空间来储存数据**，从而解决指针悬挂的问题，**需要注意自定义析构函数中应该释放掉申请的内存**。

我们在定义类或者结构体，这些结构的时候，最后都重写拷贝函数，避免浅拷贝这类不易发现但后果严重的错误产生。

### 对象复用和零拷贝

对象复用是指设计模式，**对象可以采用不同的设计模式达到复用的目的**，最常见的就是继承和组合模式了。

零拷贝是指**在进行操作时，避免CPU从一处存储拷贝到另一处存储**。在Linux中，可以减少数据在内核空间和用户空间的来回拷贝实现，比如通过调用mmap()来代替read()调用。用程序调用mmap()，磁盘上的数据会通过DMA被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write()，操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。

### 只在堆上/栈上创建对象（1）

- **只能在堆上生成对象：将析构函数设置为私有。** 原因：C++是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。

- **只能在栈上生成对象：将 new 和 delete 重载为私有。** 原因：在堆上生成对象，使用new关键词操作，其过程分为两阶段：第一阶段，使用new在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。 将new操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。

### POD数据类型（Plain old data）（1）

POD是 C++ 定义的一类数据结构概念，Plain 代表它是一个普通类型，Old 代表它是旧的，与几十年前的 C 语言兼容，那么就意味着可以使用 memcpy() 这种最原始的函数进行操作。两个系统进行交换数据，如果没有办法对数据进行语义检查和解释，那就只能以非常底层的数据形式进行交互，而拥有 POD 特征的类或者结构体通过二进制拷贝后依然能保持数据结构不变，即能用 C 的 memcpy() 等函数进行操作的类，结构体就是 POD 类型的数据。

是不是 POD 类型的，可以用`is_pod<T>::value`来判断，STL容器可以使用`type_traits`来判断。

- 不能写构造/析构函数，拷贝/移动构造函数，拷贝/移动运算符，而是用编译器自动生成的，那这个数据就是“平凡的”，如果一定要写，可以用 C++ 11 的 default 关键字。
- 不能有虚函数和虚基类。
- 布局要有序，非静态数据有相同的访问级别。
- 第一个成员必须是自己的，而不能是父类的。
- 只要有父类，非静态数据只能在其中一个类中，不可分散。

### 常函数和常对象

```c++
void func() const //常函数，此处func为类成员函数
const Person p2; //常对象
```

- 常函数修饰的是this指针，不允许修改this指针指向的值，如果执意要修改常函数，可以在成员属性前加**mutable**。
- 常对象不允许修改属性，不可以调用普通成员函数，可以调用常函数。

### 友元全局函数，友元类，友元成员函数（1）

友元主要是**为了访问类中的私有成员（包括属性和方法）**，会破坏C++的封装性，尽量不使用。

- **友元全局函数**
  - 友元函数声明可以在类中的任何地方，一般放在类定义的开始或结尾。
  - 一个函数可以是多个类的友元函数，只需要在各个类中分别声明。
  - 友元函数在类内声明，类外定义，定义和使用时不需加作用域和类名，与普通函数无异。
- **友元类**
  - 友元**不可继承**。
  - 友元是**单向的**，类A是类B的友元类，但类B不一定是类A的。
  - 友元**不具有传递性**，类A是类B的友元类，类B是类C的友元类，但类A不一定是类C的友元类。
- **友元成员函数**
  - 使类B中的成员函数成为类A的友元函数，这样类B的该成员函数就可以访问类A的所有成员，需注意友元声明和友元定义之间的相互依赖，必须先定义包含成员函数的类B，才能在类A将成员函数设为友元，另一方面，不必预先声明类和非成员函数来将它们设为友元。

### 运算符重载与++重载实现

#### 运算符重载基本属性

- 运算符重载的目的是扩展C++中提供的运算符的适用范围，使之能作用于对象，或自定义的数据类型。
- 运算符重载的实质是函数重载，可以重载为普通函数，也可以重载为成员函数。
- 运算符重载也是多态的一种，和函数重载称为静态多态，表示函数地址早绑定，在编译阶段就确定好了地址。

#### 运算符重载总结

- 重载运算符()，[] ，->，=的时候，运算符重载函数必须声明为类的成员函数。
- 重载运算符<<，>>的时候，运算符只能通过全局函数配合友元函数进行重载。
- 不要重载&&和||运算符，因为无法实现短路原则。

#### i++和++i实现

C++内置类型的后置++返回的是**变量的拷贝**，也就是不可修改的值；前置++返回的是**变量的引用**，因此可以作为修改的左值。即++（++a）或（++a）++都可以，但++（a++）不可以，（C++默认必须修改a的值，如果不修改则报错）。

```c++
//++i
int& int::operator++()
{
    *this +=1;
    return *this;
}

//i++，注意后置++有占位参数以区分跟前置++不同
const int int::operator++(int)
{
    int oldValue = *this;
    ++(*this);
    return oldValue;
}
```

### 继承方式，对象模型，同名处理（1）

继承主要是为了减少代码的重复内容，解决代码复用问题。通过抽象出一个基类（父类），将重复代码写到基类中，在派生类（子类）中实现不同的方法。

#### 继承方式

- 公有继承：保持父类中的访问属性。
- 私有继承：将父类中的所有访问属性改为private。
- 保护继承：除父类中的私有属性，其他改为保护属性。

#### 继承的对象模型

- 子类中会继承父类的私有成员，只是被编译器隐藏起来了，无法访问到，通过sizeof(子类class)可以检查出。
- 子类创建对象时，先调用父类的构造函数，然后再调用自身的构造，析构顺序与构造顺序相反。
  - 由于继承中父类和子类的构造，析构顺序原因，当父类中只提供了有参构造（默认构造等函数会被隐藏），而子类仅仅调用默认构造时，会因为子类创建对象时无法调用父类构造函数而报错，这里可以**让子类利用初始化列表来显式调用父类有参构造函数来进行父类构造，然后进行子类构造**。
- 子类会继承父类的成员属性和成员函数，但子类不会继承父类构造函数和析构函数。

#### 继承中的同名处理

- 父类和子类**成员属性**同名，**用子类声明对象调用子类属性，若想调用父类成员，则加上父类的作用域**。
- 父类和子类**成员函数**同名，子类函数不会覆盖父类的成员，只是隐藏起来，**用子类声明对象调用子类成员函数，若想调用父类函数（包括重载），则加上父类的作用域**。
- 若子类中**没有与父类同名的成员函数**，子类声明对象后，**可以直接调用父类成员函数**。

#### 继承中静态成员处理

同名成员和非静态成员基本一致，同样可以被子类继承，但**静态成员可以通过类名直接访问，不需要创建对象。**

### 多继承和菱形继承（1）

#### 多继承

多继承会产生二义性的问题，如果继承的多个父类中有同名的成员属性和成员函数，在子类调用时，需要指定作用域从而确定父类。

#### 菱形继承

两个子类继承于同一个父类，同时又有另外一个类多继承于两个子类，这种继承称为菱形继承。比如羊和驼继承于动物类，同时羊驼继承于羊和驼。

#### 菱形继承会产生问题

- **浪费空间：**羊驼继承了两份动物类中的某些数据和函数，但只需要一份即可。
- **二义性：从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题。** 羊驼调用数据和函数时，会出现二义性，通过sheep类得到一个age，通过camel类得到一个age，两个数据不会相互影响，相互修改，导致同一份数据不一致。

#### 解决菱形继承的问题

使用虚继承，在**继承方式前加virtual**，这样的话羊驼可以直接访问m_Age，不用添加作用域，且这样操作的是共享的一份数据。

```c++
class Animal{
public:
    int m_Age;
};
class Sheep:virtual public Animal{
    int m_sheep;
};
class Camel :virtual public Animal{
    int m_camel;
};

class Son :public Sheep, public Camel{
    int m_son;
};
void test01(){
    Son son;
    son.m_Age = 10;
    cout << sizeof(Animal) << endl; //m_Age
    cout << sizeof(Sheep) << endl;  //sheep-Vbptr,m_sheep,m_Age
    cout << sizeof(Camel) << endl;  //camel-Vbptr,m_camel,m_Age
    cout << sizeof(Son) << endl;    //sheep-Vbptr,m_sheep,camel-Vbptr,m_camel,m_son,m_Age
}
```

- **特别注意：**此时son没有自己的虚基类表和虚基类指针，只是继承了sheep和camel的虚基类指针和虚基类表，只是修改了两个虚基类表中的值，修改为当前类中，如何通过继承的虚基类指针查找虚基类数据。
- Son继承Sheep父类，父类中有虚基类指针vbptr(virtual base pointer)，对象结构类似结构体，首元素是虚基类指针，其余为自身数据（不包括静态成员和成员函数）。
- Sheep的虚指针指向下面Sheep的虚基类表vbtale@Sheep(virtual base table)，虚基类表是一个整型数组，数组第二个元素值为20，即Sheep的虚指针地址偏移20指向Animal的m_Age地址。Camel父类同理，因此，类中只有一个m_Age元素。
- Son中包含了两个指针和四个int类型，所以大小为24。

```c++
class Animal{
public:
    int m_Age;
};
class Sheep:virtual public Animal{
    int m_sheep;
};
class Camel :virtual public Animal{
    int m_camel;
};

class Son :virtual public Sheep, virtual public Camel{
    int m_son;
};
void test01(){
    Son son;
    son.m_Age = 10;
    cout << sizeof(Animal) << endl; //m_Age
    cout << sizeof(Sheep) << endl;  //sheep-Vbptr,m_sheep,m_Age
    cout << sizeof(Camel) << endl;  //camel-Vbptr,m_camel,m_Age
    cout << sizeof(Son) << endl;    //son-vbptr,m_son,m_Age,sheep-Vbptr,m_sheep,camel-Vbptr,m_camel
}
```

- 注意跟上面的区别，一个是son类中的元素顺序，一个是son类有了自己的虚基类指针和虚基类表。

**虚继承**

- 一般通过虚基类指针和虚基类表实现，将共同基类设置为虚基类。
- **每个虚继承的子类（虚基类本身没有）**都有一个虚基类指针（占用一个指针的存储空间）和虚基类表（不占用类对象的存储空间），**虚基类指针属于对象，虚基类表属于类**。
- 当虚继承的子类被当做父类继承时，虚基类指针也会被继承。
- 虚表中只记录了虚基类数据在派生类对象中与派生类对象首地址（虚基类指针）之间的偏移量，以此来访问虚基类数据。
- 虚继承不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。
- 虚基类表本质是一个**整型数组**。

### 静态函数可以是虚函数吗（1）

不可以，因为虚函数属于对象，不属于类，静态函数属于类。

### 类型兼容性原则，为什么会有多态

类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代，如使用子类对象可以直接赋值给父类对象或子类对象可以直接初始化父类对象时，**对于同样的一条语句，不管传入子类还是父类对象，都是调用的父类函数，但我们想实现的是同样的一条语句，传入不同的对象，调用不同的函数**，我们想**传入子类对象调用子类函数，传入父类对象调用父类函数**，即同样的调用语句有多种不同的表现形态，这样就出现了**多态**。

### 构造函数可以抛出异常吗，有什么问题

构造函数中应该避免抛出异常。

- 构造函数中抛出异常后，对象的析构函数将不会被执行。

- 构造函数抛出异常时，本应该在析构函数中被delete的对象没有被delete，会导致内存泄露。

- 当对象发生部分构造时，已经构造完毕的子对象（非动态分配）将会逆序地被析构。

### 初始化列表的异常怎么捕获

- 初始化列表构造，当初始化列表出现异常时，程序还未进入函数体，因此函数体中的try-catch不能执行，catch也无法处理异常。可以通过函数try块解决该问题。
- 函数try块中的try出现在表示构造函数初始值列表的冒号以及表示构造函数体的花括号之前，与这个try关联的catch既能处理构造函数体抛出的异常，也能处理成员初始化列表抛出的异常。

### 析构函数可以抛出异常吗，有什么问题

析构函数不应该抛出异常

- **其他正常，仅析构函数异常**。 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。

- **其他异常，且析构函数异常**。 通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。

### 析构函数如何处理异常

- 若析构函数抛出异常，调用`std::abort()`来终止程序；
- 在析构函数中catch捕获异常并作处理，吞下异常；
- 如果客户需要对某个操作函数运行期间抛出的异常做出反应，class应该提供普通函数执行该操作，而非在析构函数中。

### 智能指针（4）

C++中的智能指针有auto_ptr，shared_ptr，weak_ptr和unique_ptr。智能指针其实是将指针进行了封装，可以像普通指针一样进行使用，同时可以在函数结束时自动释放内存空间，不需要手动释放内存空间，避免忘记释放指针指向的内存地址或者在释放指针之前出错造成内存泄漏。

发生情况有如下三种：

**1.忘记释放不再使用的内存，造成内存泄漏**

```c++
int main(){
  int *ptr = new int(1);
  return 0;
}
```

**2.最后释放了申请内存，但是会留下空悬指针（野指针）带来隐患**

```c++
int main(){
  int *ptr = new int(1);
  delete ptr;
  //ptr = nullptr; //在释放内存后要将指针置为空
}
```

**3.在new之后在对应的delete之前发生异常**

```c++
int main(){
  int *ptr = new int(1);
  //在此抛出一个异常，则内存不会被释放，可用try...catch...
  delete ptr;
}
```

#### auto_ptr

auto_ptr是C++98的智能指针，C++11已经抛弃，auto_ptr在进行指针拷贝和赋值的时候，新指针直接接管旧指针的资源并且将旧指针指向空，但是这种方式在需要访问旧指针的时候，就会出现问题。

```c++
auto_ptr<string> p1(new string("I"));
auto_ptr<string> p2;
p2 = p1; //auto_ptr不会报错，p2剥夺了p1的所有权，但是需要访问p1时会出错
```

#### unique_ptr

unique_ptr是auto_ptr的一个改良版，**不能赋值也不能拷贝**，当unique_ptr是一个临时右值可以赋值，避免了旧指针不再指向有效数据的问题，保证一个对象同一时间只有一个智能指针。

```c++
unique_ptr<string> p3(new string("auto"));
unique_ptr<string> p4;
p4 = p3; //此时会报错，避免了p3不再指向有效数据的问题

unique_ptr<string> u1(new string("hello"));
unique_ptr<string> u2;
u2 = u1; //不允许，会留下悬挂的u1，unique_ptr不支持赋值
unique_ptr<string> u3(u1); //错误：unique_ptr不支持拷贝
unique_ptr<string> u4;
u4 = unique_ptr<string>(new string("You")); //允许，构造函数创建的临时对象在其所有权给u4后就会被摧毁，不会留下悬挂的unique_ptr
```

#### shared_ptr

shared_ptr可以使得一个对象可以有多个智能指针，当这个对象所有的智能指针被销毁时就会自动进行回收。对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类，可以直接初始化或者通过make_shared函数或者通过构造函数传入普通指针（内部使用计数机制进行维护）。不要把一个原生指针给多个shared_ptr，不要把this指针交给智能指针管理，这样会重复释放，**shared_ptr之间的资源共享是通过shared_ptr智能指针拷贝，赋值实现的**，因为这样可以引起计数器的更新；而如果直接通过原生指针来初始化，就会导致p1和p2都根本不知道对方的存在，然而却两者都管理同一块地方。

```c++
shared_ptr<int> p1 = new int(1024); //错误：必须使用直接初始化形式
shared_ptr<int> p2(new int(1024)); //正确：使用了直接初始化形式
shared_ptr<int> p3 = make_shared<int>(42);

int* ptr = new int(1);
shared_ptr<int> p1(ptr);
shared_ptr<int> p2(ptr); //这样会导致更新，两者不知对方存在
shared_ptr<int> p3(p1);//这样会导致计数器更新
```

#### weak_ptr

weak_ptr是为了协助shared_ptr而出现的，它是一种不控制对象生命周期的智能指针，只是提供了对管理对象的一个访问手段，它指向一个shared_ptr管理的对象，只可以从一个shared_ptr或另一个weak_ptr对象构造，它的构造和析构不会引起引用计数的增加或减少，只能观测shared_ptr的引用计数，防止出现死锁。`expired()`用于检测所管理的对象是否已经释放；`lock()`用于获取所管理的对象的强引用指针，不能直接访问弱引用，需要将其先通过lock转换为强引用再访问。

```c++
auto p = make_shared<int>(42);
weak_ptr<int> wp(p); //wp弱共享p，p的引用计数不改变
```

#### 循环引用

当两个shared_ptr相互引用，会造成循环引用，那么这两个指针的引用计数不可能下降为0，资源不会释放，从而导致内存泄漏。

```c++
class B;

class A{
public:
  A(){cout << "A()" << endl;}
  A(int i):a(i){cout << "A(int)" << endl;}
  ~A(){cout << "~A()" << endl;}
  
  shared_ptr<B> _bptr;
  int a;
};

class B{
public:
  B(){cout << "B()" << endl;}
  B(int i):b(i){cout << "B(int)" << endl;}
  ~B(){cout << "~B()" << endl;}
  
  shared_ptr<A> _aptr;
  int b;
};

int main(){
  shared_ptr<A> aptr(new A(10));
  shared_ptr<B> bptr(new B(10));
  cout << aptr.use_count() << endl; //1
  aptr -> _bptr = bptr;
  bptr -> _aptr = aptr;
  cout << aptr.use_count() << endl; //2
  return 0;
}
```

##### 解决方法

使用weak_ptr解决循环引用。

```c++
class B;

class A{
public:
  A(){cout << "A()" << endl;}
  A(int i):a(i){cout << "A(int)" << endl;}
  ~A(){cout << "~A()" << endl;}
  
  weak_ptr<B> _bptr;
  int a;
};

class B{
public:
  B(){cout << "B()" << endl;}
  B(int i):b(i){cout << "B(int)" << endl;}
  ~B(){cout << "~B()" << endl;}
  
  weak_ptr<A> _aptr;
  int b;
};

int main(){
  shared_ptr<A> aptr(new A(10));
  shared_ptr<B> bptr(new B(10));
  cout << aptr.use_count() << endl; //1
  aptr -> _bptr = bptr;
  bptr -> _aptr = aptr;
  cout << aptr.use_count() << endl; //1
  return 0;
}
```

#### 智能指针的实现

基于引用计数的智能指针的实现：

1. 一个模板指针T* ptr，指向实际的对象。

2. 一个引用次数（必须new出来的，不然会多个shared_ptr里面会有不同的引用次数而导致多次delete）。

3. 重载operator*和operator->，使得能像指针一样使用shared_ptr。

4. 重载copy constructor，使其引用次数加一。

5. 重载operator=，如果原来的shared_ptr已经有对象，则让其引用次数减一并判断引用是否为零（是否调用delete），然后将新的对象引用次数加一。

6. 重载析构函数，使引用次数减一并判断引用是否为零（是否调用delete）。

```c++
#include <iostream>

using namespace std;

template <typename T>
class smart_ptr{
public:
    smart_ptr(T* p = nullptr):_ptr(p){
      if(_ptr){
        count = new int(1);
      }
      else{
        count = new int(0);
      }
      cout << "Constructor is called!" << endl;
    }
    smart_ptr(const smart_ptr<T>& other){
      if(this->_ptr != other._ptr){
        this->count = other.count;
        this->_ptr = other._ptr;
        (*this->count)++;
      }
      cout << "Copy constructor is called!" << endl;
    }
    T* operator->(){return _ptr;}
    T& operator*(){return *_ptr;}
    smart_ptr<T>& operator=(const smart_ptr<T>& other){
      if(this->_ptr == other._ptr){
        return *this;
      }
      if(this->_ptr){
        if(0 == --*this->count){ //将左操作数对象的引用计数减1，若该对象的引用计数减至0，则删除该对象
        	delete count;
        	delete _ptr;
        	count = nullptr;
        	_ptr = nullptr;
      	}
      }
      this->_ptr = other._ptr;
      this->count = other.count;
      (*this->count)++;
      cout << "Assignment operator overloaded is called!" << endl;
      return *this;
    }
    ~smart_ptr(){
      if(*count == 0 || --*count == 0){
        delete count;
        delete _ptr;
        count = nullptr;
        _ptr = nullptr;
        cout << "Destructor is called!" << endl;
      }
    }
    int get_Ref(){
        return *count;
    }
private:
    int* count; //相同指针共同维护一个引用计数，所以使用指针实现引用计数，计数指针传递的是地址
    T* _ptr;
};
```

测试程序：

```c++
#include <iostream>
#include "smartptr.h"

using namespace std;

int main(){
  smart_ptr<int> p1(new int(0));
  cout << p1.get_Ref() << endl;
  p1 = p1;
  cout << p1.get_Ref() << endl;
  smart_ptr<int> p2(p1);
  cout << p2.get_Ref() << endl;
  smart_ptr<int> p3(new int(1));
  cout << p3.get_Ref() << endl;
  p3 = p1;
  cout << p3.get_Ref() << endl;
  return 0;
}
```

### 野指针和悬空指针

都是指向无效内存区域，访问行为会未定义，野指针是指针变量未初始化，在使用的时候编译器就会报错，产生非法内存访问，悬空指针是指针释放未置空，继续使用指针行为不可预料，设置为空再使用，编译器会直接报错。

### 强制转换（1）

* **static_cast**
  **用于各种隐式转换**，具体的说，就是用于各种基本数据类型之间的转换，比如把int换成char，float换成int等，以及派生类（子类）的指针转换成基类（父类）指针的转换。
  * 它**没有运行时类型检查**，所以**有安全隐患**。
  * **在派生类指针转换到基类指针时（上行转换），是没有任何问题的，在基类指针转换到派生类指针时（下行转换），会有安全问题。**
  * static_cast**不能转换const，volatile等属性**。
* **dynamic_cast**
  * **用于动态类型转换**，具体的说，就是**在基类指针到派生类指针转换（下行转换）比较安全**，而**派生类到基类指针的转换（上行转换）不太安全**。
  * dynamic_cast**能够提供运行时类型检查**，**只用于含有虚函数的类**。
  * 如果下行转换是安全的（基类指针或者引用指向一个派生类对象），dynamic_cast会传回适当转型过的指针，如果下行转换不安全（基类指针或者引用没有指向一个派生类对象），dynamic_cast会传回空指针。
* **const_cast**
  **用于去除const常量或volatile属性**，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改。
* **reinterpret_cast**
  几乎什么都可以**强制转换**，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等，**不能丢掉 const，volatile特性**，但是**不够安全**。

```c++
#include <iostream>

using namespace std;

class Base{
public:
  Base():b(1){}
  virtual void fun(){}
private:
  int b;
};

class Son:public Base{
public:
  Son():d(2){}
  void get_son(){
    cout << this->d << endl;
  }
private:
  int d;
};

int main(){
  int n = 97;
  
  int *p = &n;
  //以下两者效果相同
  char *c = reinterpret_cast<char*> (p);
  char *c2 = (char*)(p);
  cout << "reinterpret_cast输出：" << *c2 << endl;
  
  const int *p2 = &n;
  int *p3 = const_cast<int*>(p2);
  *p3 = 100;
  cout << "const_cast输出：" << *p3 << endl;
  
  Base* b1 = new Son;
  Base* b2 = new Base;
  
  Son* s1 = static_cast<Son*>(b1); //同类型转换
  Son* s2 = static_cast<Son*>(b2); //下行转换，不安全
  cout << "static_cast输出：" << endl;
  s1->get_son();
  s2->get_son(); //下行转换，原先父对象没有d成员，输出随机值
  
  Son* s3 = dynamic_cast<Son*>(b1); //同类型转换
  Son* s4 = dynamic_cast<Son*>(b2); //下行转换，安全
  cout << "dynamic_cast输出：" << endl;
  s3->get_son();
  if(s4 == nullptr){
    cout << "s4指针为nullptr" << endl;
  }
  else{
    s4->get_son();
  }
  return 0;
}
//输出结果
//reinterpret_cast输出：a
//const_cast输出：100
//static_cast输出：
//2
//-33683019
//dynamic_cast输出：
//2
//s4指针为nullptr
```

### RTTI

**运行时类型检查**，在C++层面主要体现在dynamic_cast和typeid。

- dynamic_cast 动态类型转换。

- typeid 运算符允许在运行时确定对象的类型，获取对象的实际类型。

### RAII

RAII全称是“Resource Acquisition is Initialization”，直译过来是**“资源获取即初始化”**。

- 在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。
- RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过C++的语言机制，实现资源和状态的安全管理，智能指针是RAII最好的例子。

### C++11新特性

#### nullptr和std::nullptr

```c++
void f(int);
void f(void*); //函数重载
f(0); //调用f(int)
f(NULL); //如果NULL是0，调用f(int)，有歧义
f(nullptr); //调用f(void*)
```

使用`nullptr`代替`NULL`和0来代表指针没有指向值，这可以避免把空指针当int而引发错误，如上函数调用的实例，使用`nullptr`不会出现歧义，因为`nullptr`是`std::nullptr_t`类型，C++11以后，`std::nullptr_t`也是基础类型了，可以自己定义变量。

#### auto

```c++
list<string> c;
...
list<string>::iterator ite;
ite = find(c.begin(),c.end(),target);
//使用auto可以转换为
list<string> c;
...
auto ite = find(c.begin(),c.end(),target);
```

C++11之后，可以使用auto自动推导变量和对象的类型，主要用于类型名称长和类型复杂的情况，另外auto还可以自动推导lambda表达式的类型，然后就可以把lambda函数当普通函数使用。

#### decltype

```c++
map<string,float> coll;
decltype(coll)::value_type elem;
//相当于
map<string,float>::value_type elem;

decltype(f()) sum = x; //并不实际调用函数f()，只是使用f()的返回值当做sum的类型
decltype(i) sum = x; //i为int类型，为int类型
decltype((i)) sum = x; //i为int类型，为int&引用
```

使用`decltype`关键字，可以让编译器找到一个表达式它的类型，这个很像typeof的功能。

`decltype`的应用有三种：

**（1）用作返回值的类型**

```c++
template<typename T1, typename T2>
decltype(x+y) add(T1 x, T2 y); //编译不能通过
//修改写法
template<typename T1, typename T2>
auto add(T1 x, T2 y)->decltype(x+y);
```

第一个代码块编译无法通过，因为return表达式所用的对象没有在定义域内（`x`和`y`还没声明），C++11则允许的一种写法是第二个代码块，返回类型用`auto`暂定，但在后面写出，用`-> decltype(x+y)`，`-> decltype(x+y)`与lambda的返回类似。

**（2）元编程**

```c++
template<typename T>
void test_decltype(T obj){
  typedef typename decltype(obj)::iterator iType;
  //相当于
  typedef typename T::iterator iType;
}
```

用于元编程推导实参的类型，由于加了`::iterator`，传入的实参必须是容器，传入复数会报错，这就是模板的半成品特性。

**（3）lambda函数的类型**

```c++
auto cmp = [](const Person& p1, const Person& p2){
  return p1.lastname() < p2.lastname() || (p1.lastname() == p2.lastname() && p1.firstname() < p2.firstname());
};
...
std::set<Person,decltype(cmp)> coll(cmp);
```

对于lambda函数，很少有人能够写出它的类型，而有时就需要知道它的类型，这时候就可以使用`decltype`来自动推导lambda函数的类型。

#### Variadic Templates（可变模板参数）

允许任意个数，任意类别的模板参数，不必在定义时将参数的个数固定。长参数模板中，变长参数包无法如同一般参数在类或函数中使用； 因此典型的手法是以递归的方法取出可用参数，在可变模板参数内部可以使用`sizeof...(args)`得到实参的个数。

```c++
//递归终结条件函数
void print()
{

}

//使用递归实现打印
template <typename T, typename... Types>                //这里的...是关键字的一部分
void print(const T& firstArg, const Types&... args)     //这里的...要写在自定义类型Types后面
{
  cout << firstArg << endl;
  print(args...);                                     //这里的...要写在变量args后面，代表args的所有参数
}

//输入
//print(7.5,"hello",bitset<16>(377),42);

//输出
//7.5
//hello
//0000000101111001
//42
```

#### 范围for语句

多与auto配合使用。

```c++
string str("somthing");
for(auto i:str) //对于str中的每个字符，i类型为char
    cout << c << endl;

for(auto &i:str) //对于若要改变每个字符的值，需要加引用
    cout << c << endl;
```

#### 定义双层vector

`vector<vector<int>>(m, vector<int>(n, 0))` 创建m行n列的二维数组，全部初始化为0。

#### Lambdas

```c++
//使用方法
auto l = []{
  std::cout << "hello lambda" << std::endl;
};
...
l(); //prints "hello lambda"
```

C++11介绍了lambdas（可以说是匿名函数或仿函数），允许定义在声明和表达式中，作为一种内联函数，最简单的lambda通过一个`[]{statements};`表示，可以直接加()运行，或者使用`auto l = []{statements};`，`l`则代表lambda函数，可以在后面进行调用。

**lambda的通用格式**

![Lambda函数的通用格式](/Users/wushengna/manual/img/img-post/Lambda函数的通用格式.png)

这是lambda函数的通用格式，**中括号`[]`**内部是可以抓取外面的非静态对象进行函数内部的使用，有以值`[x]`进行抓取和以引用`[&x]`进行抓取，如果只抓取部分对象，可以进行指定，这种写法也可以省略，比如只写`[=]`代表所有对象都是传值，至于用了哪些对象，在lambda函数里面直接写就好了，再比如`[=, &y]`表示对`y`传引用，其他都是传值，但是不建议省略写，因为可读性比较差，所以以后用的时候还是要把每个使用的变量都写上，**小括号`()`**里面则是可以接受函数参数，**`mutable`**是指以值进行抓取的对象是否可变，可变就需要加上，否则会报错，**`throwSepc`**是指这个函数可以不可以抛出异常，**`->retType`**是指lambda函数的返回类型，这三个部分都是可选的，如果都不写，甚至可以省略前面的小括号，但只要写一个，前面的小括号就必须写，对于返回类型来说，如果不写，编译器会对返回值自动进行类型推导，**大括号`{}`**内部则是函数的主体。

```c++
//类的形式
class LambdaFunctor{
public:
  LambdaFunctor(int a, int b):m_a(a),m_b(b){}
  bool operator()(int n)const{
    return m_a < n && n < m_b;
  }
private:
  int m_a;
  int m_b;
};
v.erase(remove_if(v.begin(),v.end(),LambdaFunctor(x,y)),v.end());
//lambda函数的形式
vector<int> vi{5,28,50,83,70,590,245,59,24};
int x = 30;
int y = 100;
vi.erase(remove_if(vi.begin(),vi.end(),[x,y](int n){return x < n && n < y;}),vi.end());
for(auto i:vi){
  cout << i << ' '; //5 28 590 245 24
}
cout << endl;
```

lambda函数的使用方法，函数对象就是指重载了函数调用运算符的类，可以封装代码和数据来自定义标准库的行为，但需要写出函数对象需要写出整个类，其定义和使用的地方是分开的，而且它们不是`inline`的，效率会低一些（算法效率还是最重要的），而lambda函数要简短许多，功能一样很直观。

#### 智能指针

- shared_ptr
- weak_ptr
- unique_ptr

#### 右值引用（2）

```c++
int a = 9;
int b = 4;

a = b; //a是左值
b = a; //b是左值
a = a + b;

//!a + b = 42 //a + b是右值
```

**右值引用**是为了**减少不必要的拷贝使能完美转交**而引入的新的引用类型，当右边的赋值类型是一个右值，左边的对象可以从右边的对象中偷取资源而不是重新分配拷贝，这个偷取的过程叫做移动语义。

`a+b`和临时对象就是右值，**右值**只能出现在右边，不能取地址，且没有名字，右值由将亡值和纯右值组成，将亡值如`a+b`赋给`a`后就死掉，临时对象也是一样，纯右值指的是`2`，`'a'`，`true`等，**左值**则可以两边都出现，可以取地址，且有名字。

![右值引用](/Users/wushengna/manual/img/img-post/右值引用.png)

上述的是测试程序，在`vector`尾端插入`Mystring`的临时对象，调用的`vector`需要实现带有右值插入的版本即`insert(..., &&x)`，`insert`函数移动元素需要调用`MyString`的构造函数，调用的就是移动构造函数，除了拷贝构造函数需要对应的移动构造函数以外，还有拷贝赋值函数也需要对应的移动赋值函数，`noexcept`是为了让编译器知道构造和析构不会抛出异常。

关于copy和move的区别，可以看到copy中的数据是有两份的，其中一份是拷贝过来的，即深拷贝，而move操作的数据是只有一份的，原来可能指向临时对象，现在指向搬移后的对象，原来的对象会设置为空指针，即浅拷贝，要保证原来的对象不再使用，这才安全，调用`std:move()`可以**得到一个左值的右值引用**。

```c++
//不完美的转交
void process(int &i){
  cout << "process(int&):" << i << endl;
}
void process(int &&i){
  cout << "process(int&&):" << i << endl;
}

void forward(int &&i){
  cout << "forward(int&&)" << i << " ";
  process(i);
}

forward(2); //2是右值，调用的是forward(int&& i)函数，但在forward(int&& i)函数里面使用i，i就会变为左值，从而调用process(int& i)函数，引发错误
```

不完美转交会因为转交函数的错误而使得不能调用对应函数，**完美转交**可以允许将有任意个参数的函数模板，透明地转发给另一个函数，其中参数的本质（可修改性，const，左值，右值）都会在转发过程中保留下来，使用的是`std::forward`模板函数。

#### 移动构造函数和移动赋值函数的实现（2）

![移动构造函数和移动赋值函数1](/Users/wushengna/manual/img/img-post/移动构造函数和移动赋值函数1.png)

![移动构造函数和移动赋值函数2](/Users/wushengna/manual/img/img-post/移动构造函数和移动赋值函数2.png)

以上是带有移动构造函数和移动赋值函数的`Mystring`实现，拷贝构造函数和拷贝赋值函数需要分配新的空间，调用`memcpy`函数进行拷贝，移动构造函数和移动赋值函数本质上都是浅拷贝，对指针和长度直接赋值，在完成以后要把原来对象与资源的联系切断，即将内部长度设为0，指针置为NULL，如果不将指针置为NULL，在函数结束之时会调用析构函数释放指针，而此时两个指针指向一个区域，移动之后的指针也会受到影响，所以要把指针置为NULL，而在析构函数中，释放资源之前要先判断指针是否为NULL，当指针为NULL时，不进行`delete`操作。

#### lock_guard和unique_lock

**lock_guard**是一个互斥量包装程序，它提供了一种方便的RAII风格的机制来在作用域块的持续时间内拥有一个互斥量，创建lock_guard对象时，它将尝试获取提供给它的互斥锁的所有权，当控制流离开lock_guard对象的作用域时，lock_guard析构并释放互斥量。

- 创建即加锁，作用域结束自动析构并解锁，无需手工解锁。
- 不能中途解锁，必须等作用域结束才解锁。
- 不能复制。

**unique_lock**是一个通用的互斥量锁定包装器，它允许延迟锁定，限时深度锁定，递归锁定，锁定所有权的转移以及与条件变量一起使用，unique_lock 是 lock_guard 的升级加强版，它具有 lock_guard 的所有功能，同时又具有其他很多方法，使用起来更强灵活方便，能够应对更复杂的锁定需要，但是占用空间也相对更大一点且相对更慢一点。

- 创建时可以不锁定（通过指定第二个参数为std::defer_lock），而在需要时再锁定。
- 可以随时加锁解锁。
- 作用域规则同 lock_grard，析构时自动释放锁。
- 不可复制，可移动。
- 条件变量需要该类型的锁作为参数（此时必须使用unique_lock）。
- 需要使用锁的时候，首先考虑使用 lock_guard，因为它更简单。

#### 函数对象（仿函数）

仿函数（functor）又称之为函数对象（function object），其实就是**重载了operator()操作符的struct或class**，是**一个能行使函数功能的类**，它使一个类的使用看上去像一个函数，这个类就有了类似函数的行为，就是通过“对象名+（参数列表）” 的方式使用一个类，这个就是仿函数类。

**函数对象示例：**

```c++
template <class T>
struct less:binary_function<T,T,bool>{
  bool operator()(const T& x, const T& y)const{
    return x < y;
  }
};
```
