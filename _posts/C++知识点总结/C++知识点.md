### strlen和sizeof的区别

**(1)** **strlen()**是**函数**，在**运行时**才能计算。参数必须是**字符型指针**(char*)，且必须是**以’\0’结尾的**。当数组名作为参数传入时，实际上数组已经退化为指针了。 它的功能是**返回字符串的长度**。

**(2)** **sizeof()**是**运算符**，而不是一个函数，在**编译时**就计算好了，用于**计算数据空间的字节数**。因此，sizeof**不能用来返回动态分配的内存空间的大小**。sizeof常用于返回类型和静态分配的对象、结构或数组所占的空间（参数不退化），返回值跟对象、结构、数组所存储的内容没有关系。

```c++
1)数组一一编译时分配的数组空间大小:
char a[10] = ”hello”; //因为char占1Byte，所以sizeof(a) = 10Byte
2)指针一一存储该指针所用的空间大小: 
char *str = ”I am from China.” //因为由存储的是一个字符指针，在32位的机器上，sizeof(str) = 4Byte
3)类型一一该类型所占的空间大小:
int b = 10; //因为在32位的机器上，int类型占4Byte，sizeof(b) = 4Byte
4)对象一一对象的实际占用空间大小:
class Class Sample{
  int a,b;
  int func();
}Class_a; //两个int类型的值是8Byte，sizeof(Class_a) = 8Byte
5)函数一一函数的返回类型所占的空间大小，且函数的返回类型不能是void。
  
int main(int argc, char const *argv[]){
  const char* str = "name";
  
  sizeof(str); //取的是指针str的长度8Byte
  strlen(str); //取的是这个字符串的长度，不包含结尾的\0，大小是4Byte
}
```

### 数组和指针的区别

- **概念不同：** 指针相当于一个变量，它存放的是**数据在内存中的地址**；数组是用于储存**多个相同类型数据的集合**。

- **赋值不同：** 同类型指针变量**可以相互赋值**，数组不行，**只能一个一个元素的赋值或拷贝**。

- **访问数据不同：** 指针是**间接访问数据**，获取指针，先解引用，再访问指针指向的地址中的内容；数组是**直接访问**。

- **sizeof意义不同：** 数组**所占存储空间的内存**：sizeof（数组名），数组的大小：sizeof（数组名）/sizeof（数据类型）；在32位平台下，sizeof（指针名）是4，在64位平台下，sizeof（指针名）是8，得到的是**一个指针变量的字节数**，而不是指针所指的内存容量。

- **指针和数组名异同：** 指针和数组名**都可以表示地址**，但指针是**变量**，可以修改；数组名是**常量**，不可修改赋值。

- **传参：** 数组传参时会**退化成指针**。
  - 退化的意义：C语言只会以值拷贝的方式传递参数，参数传递时，如果是拷贝整个数组，效率会大大降低，并且在参数位于栈上，太大的数组拷贝将会导致栈溢出。因此，C语言将数组的传参进行了退化。将整个数组拷贝一份传入函数时，将数组名看做常量指针，传数组首元素的地址。

### 指针数组和数组指针

指针数组本质是数组，数组指针本质是指针，谁优先级高，本质是谁。

- 指针数组：**它实际上是一个数组，数组的每个元素存放的是一个指针类型的元素**。 int* arr[8];
  - 优先级问题：[]的优先级比*高。
  - 说明arr是一个数组，而int*是数组里面的内容。
  - 这句话的意思就是：arr是一个含有8个int*的数组。

- 数组指针：**它实际上是一个指针，该指针指向一个数组**。 int (*arr)[8];
  - 由于[]的优先级比* 高，因此在写数组指针的时候必须将*arr用括号括起来。
  - arr先和*结合，说明p是一个指针变量。
  - 这句话的意思就是：指针arr指向一个大小为8个整型的数组。

### 字符数组和字符串常量

```c++
char arr[] = "hello"; //字符数组
char *arr2 = "hello"; //字符串常量
```

- `char arr[] = "hello"`，此处的赋值是将常量区的字符串"hello"拷贝到了堆栈区的数组arr的空间了。数组arr是在堆栈区开辟了空间，此时是可以修改字符串的值，因为修改的是堆栈区的字符串的值。另外此时的数组名arr是堆栈区中的"hello"的首地址。

- `char *arr2 = "hello"`，指针arr2是存储在堆栈区，但字符串是常量，存储在常量区，只是指针arr2指向了存储在常量区的字符串首地址，此时不能改变常量区的字符串的值。

```c++
const char arr[]="hello"; //这里hello本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区
const char *arr2="hello"; //字符串hello保存在常量区，const本来是修饰arr2指向的值不能通过arr2去修改，但是字符串hello在常量区，本来就不能改变，所以加不加const效果都一样
```

### 函数指针与指针函数

**含义：**

**函数指针**`int (*f)(int x)`是**指向函数入口地址的指针变量**。C++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。

**指针函数**`int* f(int x, int y)`是**返回值是指针的函数**。

**声明方式：**

```c++
int func(int a); //声明一个函数
int (*f) (int a); //声明一个函数指针
int *f1(int a); //声明一个指针函数
```

上述的`f`就是一个函数指针，它指向所有返回类型为int，并带有一个int参数的函数。

**函数指针的赋值方法：**

```c++
f = &func; //指针名 = &函数名
f = func; //指针名 = 函数名
```

将`func`函数的首地址赋值给函数指针，赋值时函数不带括号，也不带参数，**函数名就代表了函数的首地址**。func的函数名与f函数指针都是一样的，即都是函数指针，func函数名是一个函数指针常量，而f是一个函数指针变量。

**函数指针的调用方法：**

```c++
#include <iostream>
using namespace std;
int Mmin(int x,int y){
  if(x < y)
    return x;
  return y;
}
int Mmax(int x,int y){
  if(x > y)
    return x;
  return y;
}
int main(){
  int (*f)(int x，int y);
  int a=l0 , b = 20;
  f = Mmin; //把Mmin函数的入口地址赋给f
  cout << (*f)(a,b) << endl; //10
  f = Mmax; //把Mmax函数的入口地址赋给f
  cout << (*f)(a,b) << endl; //20
  return 0;
}
```

有了指向函数的指针变量后，就可以实现用该指针变量使用相同参数调用不同函数了，用于调用函数和回调函数。

### 引用和指针的区别

- **指针有内存分配，而引用只是一个别名：** 指针是一个变量，**存储的是一个地址**，引用跟原来的变量是同一个东西，**是原变量的别名**，引用声明时必须初始化，从而指向一个已经存在的对象。
- **引用可以看做常量指针，指针是一个存储地址的变量：** 指针在运行时**可以改变其所指向的值**，而引用一旦**和某个对象绑定后就不再改变**。这句话可以理解为：指针可以被重新赋值以指向另一个不同的对象，但是引用则总是指向在初始化时被指定的对象，以后不能改变，但是**指定的对象其内容可以改变**。
- **引用创建时必须初始化，且不为空，指针创建时可以为空：** 不存在指向空值的引用这个事实，意味着**使用引用的代码效率比使用指针的要高**。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空。
- **指针和引用的自增运算符意义不同：** 指针是对**内存地址**的自增，引用是对**值**的自增。
- **sizeof的意义不同：** 使用sizeof看一个**指针的大小**是4，而引用则是**被引用对象的大小**。
- **没有引用常量，有指针常量：** 没有`int& const p`，有`int* const p`。**常量指针和常量引用是存在的**，`const int *p`和`cosnt int &p`，都表示指向的对象为常量，常量引用形参的好处：
  - 使用引用作为形参，不会产生新的变量，**减少形参和实参传递的开销**；
  - 使用引用可能会导致实参随着形参的改变而改变，**声明为const之后就会消除这种副作用**。
- **参数传递：** 作为参数传递时，指针是**间接传递**，指针需要被解引用才可以对对象进行操作，而引用是**直接传递**，直接对引用的修改都会改变引用所指向的对象。
- **多级指针，一级引用：** 指针可以有多级指针（**p），而引用只有一级。

### 如何判断大小端存储

**大端字节序**是指一个整数的高位字节存放在内存的低地址处，低位字节存放在内存的高地址处。

**小端字节序**是指整数的高位字节存放在内存的内存的高地址处，低位字节存放在内存的低地址处。

大端字节序也成为**网络字节序**，当两台采用不同字节序的主机通信时，在发送数据之前发送端都必须经过字节序的转换成为大端字节序后再发送。

**判断方法：**

```c++
#include <iostream>

using namespace std;

union U{
    int a;
    char b;
}; //在一个联合体里可以定义多种不同的数据类型，这些数据共享一段内存，在不同的时间里保存不同的数据类型和长度的变量，以达到节省空间的目的，但同一时间只能存储其中一个成员变量的值

int main(){
    U u;
    u.a = 0x1234;
    if(u.b == 0x12){
        cout << "big endian" << endl;
    }
    else if(u.b == 0x34){
        cout << "little endian" << endl;
    }
    return 0;
}
```

### 代码判断32位和64位系统

写一个指针，输出指针所占的字节大小。

### 内存字节对齐的规则和原因

#### 规则

- 对于结构的各个成员，第一个成员位于偏移为0的位置，以后的每个数据成员的偏移量必须是`min(#pragma pack()指定的数,这个数据成员的自身长度)`的倍数。
- 在所有的数据成员完成各自对齐之后，结构或联合体本身也要进行对齐，对齐将按照 #pragam pack指定的数值和结构或者联合体最大数据成员长度中比较小的那个，也就是`min(#pragam pack() , 长度最长的数据成员)`。

#### 原因

- **平台原因（移植原因）：** **不是所有的硬件平台都能访问任意地址上的任意数据**，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
- **硬件原因：** 经过内存对齐之后，**CPU的内存访问速度大大提升**。访问未对齐的内存，处理器要访问两次（数据先读高位，再读低位），访问对齐的内存，处理器只要访问一次，为了提高处理器读取数据的效率，我们使用内存对齐。

#### struct和union占用字节数的计算

```c++
//struct
#include <cstdio>
#include <iostream>
using namespace std;

struct E1 {
	int a; char b; char c;
}e1; //4 + 1 + 1 + 2 = 8

struct E2 {
	char b; int a; char c;
}e2; //1 + 3 + 4 + 1 + 3 = 12

struct B{
    char a;
    double b;
    int c;
}test_struct_b; //1 + 7 + 8 + 4 + 4 = 24

struct E{

}test_struct_e; //空结构体占用字节数为1，编译器默认分配了一个字节，为了确保两个不同对象的地址不同，让对象的实例能够相互区别，带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定

int main() {
	cout << sizeof(E1) << endl; //8
	
	cout << sizeof(E2) << endl; //12
  
  cout << sizeof(test_struct_b) << endl; //24
  
  cout << sizeof(test_struct_e) << endl; //1
  
	return 0;
}

//union
#include <cstdio>
#include <iostream>
using namespace std;

union A{
    int a[5];
    char b;
    double c;
}; //20 + 4 = 24

int main() {
  cout << sizeof(A) << endl; //24
	return 0;
}

//混合结构体占用字节数
#include <cstdio>
#include <iostream>
using namespace std;
#define LL long long 

struct E5 {
	char a1,a2,a3,a4,a5,a6;
}e5; //1 + 1 + 1 + 1 + 1 + 1 = 6
struct E6 {
	char a1,a2,a3;
}e6; //1 + 1 + 1 = 3
struct E7 {
	struct E5 elem5;
	struct E6 elem6;
	LL a;
}e7; //6 + 3 + 7 + 8 = 24

struct E8 {
	char a[9];
}e8; //9
struct E9 {
	struct E8 elem8;
	LL a;
}e9; //9 + 7 + 8 = 24

typedef union{
    long i;
    int k[5];
    char c;
}UDATA; //4 * 5 + 4 = 24

struct C{
    int cat;
    UDATA cow;
    double dog;
}test_struct_c; //4 + 24 + 4 + 8 = 40

UDATA temp;

int main() {
	cout << sizeof(E5) << endl; //6
  
	cout << sizeof(E6) << endl; //3
  
	cout << sizeof(E7) << endl; //24
	
	cout << sizeof(E8) << endl; //9
  
	cout << sizeof(E9) << endl; //24
  
  cout << sizeof(test_struct_c) + sizeof(temp) << endl; //40 + 24 = 64
	return 0;
}
```

### define和const的区别

- define和const都是**定义常量**的一种方法。

* define定义的常量**没有类型**，const定义的常量是**有类型**的。
* define定义的常量**没有分配内存空间**，只是进行了简单的**替换**，const定义的常量**要分配内存空间**，存放在**静态存储区**。
* define定义的常量可能会有**多个拷贝**，占用的内存空间大，const定义的常量只有**一个拷贝**，占用的内存空间小。
* define定义的常量是在**预处理阶段**进行替换，而const在**编译阶段**确定它的值。
* define**不会进行类型安全检查**（最好加上括号），而const**会进行类型安全检查**，安全性更高。
* define**可以定义函数**，而const**不可以**。
* define**不受定义域限制**，而const**有定义域限制**。
* define可以通过`#undef`来**使之前的define失效**，const常量定义后**将在定义域内永久有效**。

### extern

**extern**是一种“**外部声明**”的关键字，字面意思就是**在此处声明**某种变量或函数，**在外部定义**，即其修饰的变量或函数的定义在其它源文件中，extern关键字的主要作用是扩大变量/函数的作用域，使得其它源文件和头文件可以复用同样的变量/函数，可以实现多文件**共享**同一个变量、const常量和函数。

`extern "C"`用于**告诉C++编译器这段代码要按C标准编译**，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题，以保持C++与C的兼容性。

### 面向对象特性

**实例化：**通过类创建一个对象的过程，使用对象可以调用类成员函数和成员变量，其中类成员函数称为行为，类成员变量称为属性。

**类和对象的关系：**类是对象的抽象，对象是类的实例。

- **封装**
  - 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
  - public，private，protected。
- **继承**
  - 让某种类型对象获得另一种类型对象的属性和方法，可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
  - 基类（父类）——> 派生类（子类）
- **多态**
  - 同一事物表现出不同事物的能力。
  - 实现多态的方式：
    - 覆盖（override），子类重新定义父类的虚函数。
    - 重载（overload），允许存在多个同名函数，而这些函数的参数表不同。

### class和struct的区别

- class的**成员的默认访问权限是private**，struct的**成员的默认访问权限是public**。

- class的**默认继承权限是private**，struct的**默认继承权限是public**。

- class**可以用作模板**，而struct**不能**。

### 类成员属性

- **私有权限：** 私有成员在类内部可以访问，类外不可访问，一般推荐将成员变量设置为私有成员；
- **公有权限：** 类内类外都可以进行访问；
- **保护权限：** 类内和当前类的子类可以访问，类外不可访问。

### 构造函数和析构函数

构造函数和析构函数，分别对应**变量的初始化和清理**。 当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。

- 构造函数：
  - 与类名相同，没有返回值，不写void，**可以发生重载**，可以有参数，编译器自动调用，只调用一次。
  - 系统会默认给一个类提供三个函数：默认构造函数（无参，函数体为空）、默认拷贝构造和析构函数（无参，函数体为空），其中默认拷贝构造可以实现简单的值拷贝。
  - 提供了有参构造函数，就不提供默认构造函数；提供了拷贝构造函数，就不会提供其他构造函数，若自己定义可有参构造，也需要自定义无参构造函数。

- 析构函数：
  - ~类名，没有返回值，不写void，**不可以发生重载**，不可以有参数，编译器自动调用，只调用一次。
  - 如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好自定义析构函数，在销毁类之前，释放掉申请的内存空间，避免内存泄漏。

### 初始化列表的好处和使用条件

**好处：**

- 初始化列表是直接初始化成员，给数据成员分配内存空间时就进行初始化。
- 赋值初始化是初始化再赋值，在所有的数据成员被分配内存空间后才进行。

**初始化列表的使用条件：**

- const类型的数据。
- 引用类型的数据。

### 能否通过初始化列表初始化静态成员变量

不能，静态成员变量最好类内声明，类外初始化。静态成员是单独存储的，并不是对象的组成部分，如果在类的内部进行定义，在建立多个对象时会多次声明和定义该变量的存储位置，在名字空间和作用域相同的情况下会导致重名的问题。

### static

- **修饰普通变量：**修改变量的存储区域和生命周期，使变量**存储在静态区**，在 main 函数运行前就分配了空间，**在整个程序运行期间一直存在**，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它，自动初始化为0。
  - **全局静态变量作用域：**全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。
  - **局部变量作用域：**仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

- **修饰普通函数：**其只能在定义它的源文件中使用，不能在其他源文件中被引用。

- **修饰类成员变量和成员函数：**它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过<类名>::<静态成员>来使用。在 static 函数内不能访问非静态成员。

### 静态成员变量和静态成员函数

若将成员变量声明为static，则为静态成员变量，与一般的成员变量不同，无论建立多少对象，都只有一个静态成员变量的拷贝，**静态成员变量属于一个类，所有对象共享**。静态变量**在编译阶段**就分配了空间，对象还没创建时就已经分配了空间，放到**全局静态区**。

- **静态成员变量**
  - 最好是类内声明，类外初始化（以免类名访问静态成员访问不到）。
  - 无论公有，私有，静态成员都可以在类外定义，但私有成员仍有访问权限。
  - 非静态成员类外不能初始化。
  - 静态成员数据是共享的。
- **静态成员函数**
  - 静态成员函数可以直接访问静态成员变量，不能直接访问普通成员变量，但可以通过参数传递的方式访问。
  - 普通成员函数可以访问普通成员变量，也可以访问静态成员变量。
  - 静态成员函数没有this指针。非静态数据成员为对象单独维护，但静态成员函数为共享函数，无法区分是哪个对象，因此不能直接访问普通变量成员，也没有this指针。

### 对象的存储空间

**对象的存储空间：**非静态成员变量总和加上编译器为了CPU计算做出的数据对齐处理和支持虚函数所产生的负担的总和。

**空类的大小：**1Byte，为了确保两个不同对象的地址不同。

### this指针

- **为什么会有this指针：**在类实例化对象时，只有非静态成员变量属于对象本身，剩余的静态成员变量，静态函数，非静态函数都不属于对象本身，因此非静态成员函数只会实例一份，多个同类型对象会共用一块代码，**由于类中每个实例后的对象都有独一无二的地址，因此不同的实例对象调用成员函数时，函数需要知道是谁在调用它，因此引入了this指针**。
- **this指针的作用：**this指针是隐含在对象成员函数内的一种指针，当一个对象被创建后，它的每一个成员函数都会含有一个系统自动生成的隐含指针this。**this指针指向当前被调用的成员函数所在的对象的起始地址**（谁调用成员函数，this指向谁），*this表示对象本身，非静态成员函数中才有this，静态成员函数内部没有。
  - this 并不是一个常规变量，而是个**右值**，所以不能取得 this 的地址（不能 &this）。
  - 对非静态成员函数默认添加了this指针，类型为classname *const this。
- **this指针使用**
  - 当形参与成员变量名相同时，用this指针来区分。
  - 为实现对象的链式引用，在类的非静态成员函数中返回对象本身，可以用return * this，this指向对象，*this表示对象本身。

### delete this合法吗

合法，但有前提：

- 必须保证this对象是通过new（不是new[]，不是placement new，不是栈上，不是全局，不是其他对象成员）分配的。
- 必须保证调用delete this的成员函数是最后一个调用this的成员函数。
- 必须保证成员函数的delete this后面没有调用this了。
- 必须保证delete this后没有人使用了。

### 类模板和函数模板

通过template实现，主要用于**数据的类型参数化**，简化代码，有类模板和函数模板，函数模板是用于生成函数的，类模板则是用于生成类的。

- **类模板和函数模板定义**
  - template声明下面是函数定义，则为函数模板，否则为类模板。
  - 注意：每个函数模板前必须有且仅有一个template声明，不允许多个template声明后只有一个函数模板，也不允许一个template声明后有多个函数模板（类模板同理）。

- **类模板与函数模板的区别**
  - 类模板不支持自动类型推导。
  - 数据类型可以有默认参数。

### 析构函数与构造函数的执行顺序

在一般情况下，**调用析构函数的次序正好与调用构造函数的次序相反**：最先被调用的构造函数，其对应的（同一对象中的）析构函数最后被调用;而最后被调用的构造函数，其对应的析构函数最先被调用。

- **在全局范围中定义的对象**（即在所有函数之外定义的对象），它的构造函数在文件中的所有函数（包括main函数）执行之前调用。 但如果一个程序中有多个文件，而不同的文件中都定义了全局对象，则这些对象的构造函数的执行顺序是不确定的。当 main 函数执行完毕或调用 exit 函数时（此时程序终止），调用析构函数。

- 如果定义的是**局部对象**（如在函数中定义对象），则在建立对象时调用其构造函数。 如果函数被多次调用，则在每次建立对象时都要调用构造函数。在函数调用结束，对象释放时先调用析构函数。

- 如果在函数中定义**静态（static）局部对象**，则只在程序第一次调用此函数建立对象时调用构造函数一次，在调用结束时对象并不释放，因此也不调用析构函数，只在main函数结束或调用exit函数结束程序时，才调用析构函数。

### 派生类的构造函数和析构函数

**构造函数**

- 对**基类成员**和**子对象成员**的初始化必须**在成员初始化列表中**进行，新增成员的初始化既可以在成员初始化列表中进行，也可以在构造函数体中进行。
- 派生类构造函数的**执行顺序**：
  - 先调用**基类构造函数**;
  - 再调用**子对象的构造函数**;
  - 最后调用**派生类的构造函数体**。

- 当**派生类有多个基类**时，处于同一层次的各个基类的构造函数的调用顺序取决于**定义派生类时声明的顺序**（自左向右），而与在派生类构造函数的成员初始化列表中给出的顺序无关。

- 如果**派生类的基类也是一个派生类**，则每个派生类**只需负责其直接基类的构造**，依次上溯。

- 当**派生类中有多个子对象**时，各个子对象构造函数的调用顺序也取决于**在派生类中定义的顺序（自前至后）**，而与在派生类构造函数的成员初始化列表中给出的顺序无关。

- 派生类构造函数提供了将参数传递给基类构造函数的途径，以保证在基类进行初始化时能够获得必要的数据 。 因此如果基类的构造函数定义了一个或多个参数时，派生类必须定义构造函数。

- 如果基类中定义了默认构造函数或根本没有定义任何一个构造函数（此时由编译器自动生成默认构造函数）时，在派生类构造函数的定义中可以省略对基类构造函数的调用。

- 子对象的情况与基类相同。

- 当所有的基类和子对象的构造函数都可以省略时，可以省略派生类构造函数的成员初始化列表。

- 如果所有的基类和子对象构造函数都不需要参数，派生类也不需要参数时，派生类构造函数可以不定义。

**析构函数**

在派生时，**派生类是不能继承基类的析构函数的**，也需要通过派生类的析构函数去调用基类的析构函数。在派生类中可以根据需要定义自己的析构函数，用来对派生类中所增加的成员进行清理工作;基类的清理工作仍然由基类的析构函数负责。在执行派生类的析构函数时，系统会自动调用基类的析构函数和子对象的析构函数，对基类和子对象进行清理。

**派生类构造函数的使用**

```c++
#include <iostream>
#include <string>

using namespace std;

class CStudent{
public: //声明基类Student
  CStudent(int n, string nam, char s){ //基类构造函数
    num = n;
    name = nam;
    sex = s;
  }
  ~CStudent() {} //基类析构函数
protected: //保护部分
  int num;
  string name;
  char sex;
};
class CStudentl:public CStudent{ //声明派生类Student1
public: //派生类的公用部分
  CStudentl(int n, string nam, char s, int a, string ad):CStudent(n,nam,s){ //派生类构造函数
    age = a; //在函数体中只对派生类新增的数据成员初始化
    addr = ad;
  }
  void show(){
    cout << "num: " << num << endl;
    cout << "name: " << name << endl;
    cout << "sex: " << sex << endl;
    cout << "age: " << age << endl;
    cout << "address: " << addr << endl << endl;
  }
  ~CStudentl(){ } //派生类析构函数
private: //派生类的私有部分
  int age;
  string addr;
};
int main(){
  CStudentl stud1(10010,"Wang-1i",'f',19,"115 Beijing Road,Shanghai");
  CStudentl stud2(10011,"Zhang-fun",'m',21,"213 Shanghai Road,Beijing");
  studl.show(); //输出第一个学生的数据
  stud2.show(); //输出第二个学生的数据
  return 0;
}
```

### 派生类构造函数和析构函数的调用顺序

**构造函数的调用顺序**

- **基类构造函数**。如果有多个基类，则构造函数的调用顺序是**某类在类派生表中出现的顺序**，而不是它们在成员初始化表中的顺序。

- **成员类对象构造函数**。如果有多个成员类对象，则构造函数的调用顺序是**对象在类中被声明的顺序**，而不是它们出现在成员初始化表中的顺序。

- **派生类构造函数**。

**析构函数的调用情况**

- 对象生命周期结束被销毁时（一般类成员的指针变量与引用都不自动调用析构函数）。

- delete指向对象的指针时，或者delete指向对象的基类类型指针，而其基类析构函数是虚函数时。

- 对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。

### 重载，覆盖和重写

- **重载（overload）：**是**函数名相同，参数列表不同**。重载只是在同一个类的内部存在，但是**不能靠返回类型来判断**。
- **覆盖（override）：**子类重新定义父类中有相同名称和参数的虚函数，两者的函数特征相同。
  - 被覆盖的函数不能是static的，必须是virtual的。
  - 覆盖函数必须有相同的类型，名称和参数列表。
  - 覆盖函数的访问权限可以不同。尽管virtual是private的，子类中覆盖改写为public，protected也是可以的。
- **重写（overwrite）：**也叫做隐藏，**子类重新定义父类中有相同名称的非虚函数（参数列表可以不同）**。如果一个类，存在和父类相同的函数，那么，这个类将会隐藏其父类的方法，除非你在调用的时候，强制转换为父类类型或加上父类作用域。

### 多态实现的基础

- 继承

- 虚函数覆盖

- 父类指针或引用指向子类对象访问虚函数

```c++
class Animal{
public:
	virtual  void speak(){ //在父类中声明虚函数，可以实现多态，动态联编
		cout << "Animal speak" << endl;
	}
	int m_age = 0;
};

class Sheep :public Animal{
public:
	void speak(){ //发生多态时，子类对父类中的成员函数进行重写，virtual可写可不写
		cout << "Sheep speak" << endl;
	}
	int m_age = 1;
};

void doSpeak(Animal &animal){
	animal.speak();
}

void test01(){
  //传入子类对象调用子类成员函数
	Sheep sheep;
	doSpeak(sheep); //sheep speak;
	
  //子类对象直接调用子类成员函数
	sheep.speak();  //sheep speak;
	
	//子类对象通过作用域调用父类成员函数
  sheep.Animal::speak();  //animal speak;
    
  //基类成员不能转换为子类成员，即不能向下转换
	//Animal *animal0 = new Animal();
	//Sheep * sheep0 = animal0;
	//sheep0->speak();

  //同样不能向下转换
	//Animal animal0;
	//Sheep sheep0 = animal0;

  //父类指针指向子类对象
	Sheep *sheep1 = new Sheep();
	Animal *animal1 = sheep1;
	animal1->speak(); //sheep speak;
	
	//父类引用指向子类对象
	Sheep sheep2;
	Animal &animal2 = sheep2;
	animal2.speak();    //sheep speak;
	
	//子类对象直接赋值给父类对象，不符合多态条件，符合类型兼容性原则
	Sheep sheep0;
	Animal animal0 = sheep0;
	animal0.speak();    //animal speak;
}
```

### 静态多态和动态多态

- 静态多态（运算符重载、函数重载）。

- 动态多态（继承、虚函数）。

两者主要的**区别**：函数地址是**早绑定（静态联编）**还是**晚绑定（动态联编）**，即在编译阶段确定好地址还是在运行时才确定地址。

### 虚函数指针和虚函数表

- 前提发生了多态，每个类中都有虚函数表，最开始的父类创建虚函数表，后面的子类继承父类的虚函数表，子类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段（.text）中，然后对虚函数重写，将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。
- 虚函数重写（覆盖）的实质就是**重写父类虚函数表中的父类虚函数地址**；
- 实现多态的流程：虚函数指针->虚函数表->函数指针->入口地址，**虚函数表（vftable）属于类**，或者说这个类的所有对象共享一个虚函数表；**虚函数指针（vfptr）属于单个对象**。
- 在程序调用时，先创建对象，编译器在对象的内存结构头部添加一个虚函数指针，进行动态绑定，虚函数指针指向对象所属类的虚函数表。
- 虚函数表是一个**指针数组**，其元素是**虚函数的指针**，每个元素对应一个函数的指针。如果子类对父类中的一个或多个虚函数进行重写，子类的虚函数表中的元素顺序，会按照父类中的虚函数顺序存储，之后才是自己类的函数顺序。
- 编译器根本不会去区分传进来的是子类对象还是父类对象，而是关心调用的函数是否为虚函数。如果是虚函数，就根据不同对象的vptr指针找属于自己的函数。父类对象和子类对象都有vfptr指针，传入对象不同，编译器会根据vfptr指针，到属于自己虚函数表中找自己的函数。即：vptr--->虚函数表------>函数的入口地址，从而实现了迟绑定（在运行的时候，才会去判断）。

### 抽象类和纯虚函数

在程序设计中，如果仅仅为了设计一些虚函数接口，打算在子类中对其进行重写，那么不需要在父类中对虚函数的函数体提供无意义的代码，可以通过纯虚函数满足需求。

- 纯虚函数的语法格式：`virtual 返回值类型 函数名 () = 0; `只需要将函数体完全替换为=0即可，**纯虚函数必须在子类中进行实现**，在子类外实现是无效的。
- 注意：
  - 如果父类中出现了一个纯虚函数，则这个类变为了抽象类，抽象类不可实例对象。
  - 如果父类为抽象类，子类继承父类后，必须实现父类所有的纯虚函数，否则子类也为抽象类，也无法实例对象，**但纯虚析构函数例外，因为子类不会继承父类的析构函数**。

### 构造函数和析构函数能否是虚函数

**构造函数不能是虚函数**

- 在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要**构造函数调用完成后才会形成虚表指针**。
- 构造函数不能实现多态，对象在创建时，由编译器对vptr指针进行初始化，只有当对象的构造完全结束后vptr的指向才最终确定。

- 子类中虚函数指针的初始化过程，构造子类对象的时候会首先调用父类的构造函数然后再调用子类的构造函数。当调用父类的构造函数的时候，此时会创建vptr指针，该指针会指向父类的虚函数表；然后再调用子类的构造函数，子类继承父类的虚函数指针，此时vptr又被赋值指向子类的虚函数表。

**析构函数最好是虚函数**

- 仅仅发生继承时，创建子类对象后销毁，函数调用流程为：父类构造函数->子类构造函数->子类析构函数->父类析构函数；

- 当发生多态时（父类指针或引用指向子类对象），通过父类指针在堆上创建子类对象，然后销毁，调用流程为：父类构造函数->子类构造函数->父类析构函数，不会调用子类析构函数，因此子类中会出现内存泄漏问题。解决方法：**将父类中的析构函数设置为虚函数**，设置后会先调用子类析构函数，再调用父类析构函数。

- 纯虚析构函数
  - 纯虚析构函数需要类内声明，类外实现。
  - 纯虚析构函数也是虚函数，该类也为抽象类。
  - 子类不会继承父类的析构函数，当父类纯虚析构函数没有实现时，子类不是抽象类，可以创建对象。

- **C++的默认析构函数不是虚析构函数**，因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存，**而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存**。
- **静态函数不可以是虚函数**，因为虚函数属于对象，不属于类，静态函数属于类。

### 单例模式

定义一个单例类，使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法来获取该实例。单例模式的作用就是保证在整个应用程序的生命周期中的任何一个时刻，单例类的实例都只存在一个（当然也可以不存在）。

单例模式通过类本身来管理其唯一实例，唯一的实例是类的一个普通对象，但设计这个类时，让它只能创建一个实例并提供对此实例的全局访问。

**单例模式使用**

```c++
#include <iostream>

using namespace std;

class CSingleton{
private:
  CSingleton(){ //构造函数是私有的
    
  }
  static CSingleton *m_pInstance;
public:
  static CSingleton *GetInstance(){
    if(m_pInstance == NULL){ //判断是否第一次调用
      m_pInstance = new CSingleton();
    }
    return m_pInstance;
  }
};
CSingleton *CSingleton::m_pInstance = NULL; //初始化静态数据成员
int main(){
  CSingleton *s1 = CSingleton::GetInstance();
  CSingleton *s2 = CSingleton::GetInstance();
  if(s1 == s2){
    cout << "s1 = s2" << endl; //程序的执行结果是输出了s1 = s2
  }
  return 0;
}
```

单例类CSingleton有以下特征：

- 有一个指向唯一实例的静态指针m_plnstance，并且是私有的;

- 有一个公有的函数，可以获取这个唯一的实例，并且在需要的时候创建该实例; 

- 其构造函数是私有的，这样就不能从别处创建该类的实例。

### new/delete和malloc/free的区别

malloc和calloc间的主要区别在于后者在返回指向内存的指针之前把它初始化为0，另一个区别是calloc的参数包括所需的元素的数量和每个元素的字节数。

- **属性不同：**new/delete是**C++关键字**，需要**编译器支持**。malloc/free是**库函数**，需要**头文件支持c**。

- **申请的内存所在位置：**new操作符从**自由存储区**（free store）上为对象动态分配内存空间，而malloc函数从**堆**上动态分配内存。

- **返回类型安全性：**new操作符内存分配成功时，返回的是**对象类型的指针**，类型严格与对象匹配，**无须进行类型转换**，故new是**符合类型安全性**的操作符。 而malloc内存分配成功则是返回**void*类型**，需要通过**强制类型转换将空类型指针转换成我们需要的类型**。

- **内存分配失败时的返回值：**new内存分配失败时，会抛出**bac_alloc异常**，它不会返回NULL；malloc分配内存失败时**返回NULL**。

- **是否需要指定内存大小：**使用new操作符申请内存分配时**无须指定内存块的大小**，编译器会根据类型信息自行计算。而malloc则**需要显式地指出所需内存的大小**。
  - `int *pi = new int; //在自由存储区中分配创建了一个整形对象，并返回一个指向该对象的地址来初始化指针pi`
  - `int *pi = new int(); //对指针pi指向的地址的值进行了初始化为0`
  - `int *pi = new int(1024); //初始化为1024`
  - `int *p = (int *)malloc(100); //指向整型的指针p指向一个大小为100字节的内存的地址`
  - `int *p = (int *)malloc(25*sizeof(int)); //指向整型的指针p指向一个25个int整型空间的地址`

- **数组分配内存（与前一个特点类似）：**new中分配内存**对于变量和数组不同**，malloc分配内存则**相同**。
  - `int *pi = new int[]; //指针pi所指向的数组未初始化`
  - `int *pi = new int[n]; //指针pi指向长度为n的数组，未初始化`
  - `int *pi = new int(); //指针pi所指向的地址初始化为0`

- **是否调用构造函数/析构函数：**new会**先调用operator_ new函数，申请足够的内存（通常底层使用malloc实现），然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针**。delete**先调用析构函数，然后调用operator_ delete函数释放内存（通常底层使用free实现）**。malloc/free是库函数，**只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作**。

- **能否重载：**opeartor_new/operator_delete**允许重载**，malloc/free**不允许重载**。

- **已分配内存的扩充：**malloc/free**可以通过realloc函数扩充**，new/free**无法直观地处理**。

- **能否相互调用：**operator_new /operator _delete的实现**可以基于malloc/free**，而malloc的实现**不可以去调用new**。

### new运算符的原理

- **内存分配**
  - 调用相应的operator new(size_t)函数，动态分配内存。如果operator new(size_t)不能成功获得内存，则调用new_handler()函数用于处理new失败问题。如果没有设置new_handler()函数或者new_handler()未能分配足够内存，则抛出std::bad_alloc异常。
- **构造函数**
  - 在分配到的动态内存块上初始化相应类型的对象（构造函数）并返回其首地址。如果调用构造函数初始化对象时抛出异常，则自动调用operator delete(void* ,void*)函数释放已经分配到的内存。

### malloc的内存分配机制

首先会扫描之前由free()所释放的空闲内存块列表，以求找到尺寸大于或等于要求的一块空闲内存。如果这一内存块的尺寸正好与要求相当，就将它返回给调用者，如果是一块较大的内存，那么将对其进行分割，在将一块大小相当的内存返回给调用者的同时，把较小的那块空闲内存块保留在空闲列表中。

### 面向对象和面向过程的区别

面向对象就是**高度实物抽象化**，面向过程就是**自顶向下的编程**。

- 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用。

- 面向对象是把要解决的问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。

- 面向过程的优缺点
  - 优点：**性能比面向对象高**，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机，嵌入式开发，Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
  - 缺点：没有面向对象易维护，易复用，易扩展。

- 面向对象的优缺点
  - 优点：**易维护，易复用，易扩展**，由于面向对象有封装，继承，多态性的特性，可以设计出低耦合的系统，使系统更加灵活，更加易于维护。
  - 缺点：性能比面向过程低。

### const

- **修饰变量：**说明该变量不可以被改变；

- **修饰指针：**分为常量指针和指针常量；
  - **常量指针**，`const int *p`是指指向常量的指针，就是指针指向的是常量，它不能指向变量，指向的内容不能被改变，不能通过指针来修改它指向的内容，但是指针自身不是常量，它自身的值可以改变，从而指向另一个常量。
  - **指针常量**，`int *const p`是指指针本身是常量，它指向的地址是不可改变的，但地址里的内容可以通过指针改变，注意指针常量在定义时必须同时赋初值。

- **常量引用：**经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；

- **修饰成员函数：**说明该成员函数内不能修改成员变量，本质是const this指针。

### volatile

- **不可优化性：**volatile关键字是一种类型修饰符，用它声明的类型变量表示不可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改，所以使用volatile**告诉编译器不应对这样的对象进行优化**。
- **易变性：**volatile关键字声明的变量，**每次访问时都必须从内存中取出值**（没有被volatile修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）。

### explicit

explicit关键字的作用就是**防止对象间实现=赋值，防止类构造函数的隐式自动转换**，类构造函数默认情况下即声明为implicit（隐式），另外explicit只用于单参数的构造函数，或者除了第一个参数以外的其他参数都有默认值。

- explicit修饰构造函数时，可以防止隐式转换和拷贝初始化。

- explicit修饰转换函数时，可以防止隐式转换。

**explicit用法**

```c++
class Person{
public:
    Person(){
    }
    //有参构造初始化数据
    explicit Person(const char*str_){
        str = (char *)malloc(sizeof(char)*100);
        strcpy(str,str_);
    }
    ~Person() {
        if (str != NULL){
            free(str);
            str = NULL;
        }
    }
    char *str;
};
void test05(){
    //Person p = "abc"; 隐式调用
    Person p ("abc"); //显式调用
}
```

### 双冒号，using和namespace

- 双冒号::作用域运算符
  - 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间。
  - 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的。
  - 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的。
- using分为using声明和using编译指令。
  - `using std::cout; //声明`
  - `using namespace std; //编译指令`
  - 尽量使用声明而不是编译指令，不同命名空间中可能会有相同的变量名，编译指令执行两个命名空间后，会产生二义性。

- namespace主要用来**解决命名冲突的问题**。
  - 必须在全局作用域下声明。
  - 命名空间下可以放函数，变量，结构体和类。
  - 命名空间可以嵌套命名空间。
  - 命名空间是开放的，可以随时加入新成员（添加时只需要再次声明namespace，然后添加新成员即可）。

### 内联函数和函数重载

- **内联函数**
  - 相当于把内联函数里面的内容写在调用内联函数处；
  - 相当于不用执行进入函数的步骤，直接执行函数体；
  - 相当于宏，却比宏多了类型检查，真正具有函数特性；
  - 不能包含循环，递归，switch等复杂操作；
  - 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数，内联函数对于编译器而言只是一个建议，编译器不一定会接受这种建议，即使没有声明内联函数，编译器可能也会内联一些小的简单的函数。
- C++的函数名称可以重复，称为**函数重载**。
  - 其中必须在同一作用域下的函数名称相同，不能是一个在全局，一个局部，或者不同的代码块中。
  - 可以根据函数参数的个数，类型（const也可以作为重载条件），顺序不同进行函数重载，但**不能用函数返回值进行重载**。
  - 当函数重载遇到函数默认参数时，要注意二义性。

### 虚函数可以是内联函数吗

- 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
- 内联是在**编译期**内联，而虚函数的多态性在**运行期**，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
- inline virtual 唯一可以内联的时候是：**编译器知道所调用的对象是哪个类**（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

### 拷贝构造函数与深浅拷贝

拷贝构造函数的参数必须加const，因为防止修改，本来就是用现有的对象初始化新的对象。拷贝构造函数需要传引用而不能传值，使用拷贝构造函数来初始化一个非引用类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归。

- 拷贝构造函数的使用时机
  - 使用已经创建好的对象初始化新对象 `A a; A b = a; A c(a); b = c;//b = c不是初始化，调用赋值运算符`
  - 以值传递的方式来给函数参数传值。
  - 以值方式返回局部对象（不常用，一般不返回局部对象）。
- 深拷贝和浅拷贝，只有当对象的成员属性在**堆区**开辟空间内存时，才会涉及深浅拷贝，如果仅仅是在栈区开辟内存，则默认的拷贝构造函数和析构函数就可以满足要求。
  - **浅拷贝**：使用默认拷贝构造函数，拷贝过程中是**按字节复制**的，对于指针型成员变量**只复制指针本身，而不复制指针所指向的目标**，因此涉及堆区开辟内存时，会将两个成员属性指向相同的内存空间，从而在释放时导致内存空间被多次释放，使得程序down掉。
  - **浅拷贝的问题**：当出现类的等号赋值时，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次free函数，指向的内存空间已经被释放掉，再次free会报错；另外，一片空间被两个不同的子对象共享了，只要其中的一个子对象改变了其中的值，那另一个对象的值也跟着改变了，所以这时必须采用深拷贝。
  - **深拷贝**：自定义拷贝构造函数，**在堆内存中另外申请空间来储存数据**，从而解决指针悬挂的问题，**需要注意自定义析构函数中应该释放掉申请的内存**。

我们在定义类或者结构体，这些结构的时候，最后都重写拷贝函数，避免浅拷贝这类不易发现但后果严重的错误产生。

### 只在堆上/栈上创建对象

- **只能在堆上生成对象：将析构函数设置为私有。** 原因：C++是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。

- **只能在栈上生成对象：将new 和 delete 重载为私有。** 原因：在堆上生成对象，使用new关键词操作，其过程分为两阶段：第一阶段，使用new在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。 将new操作设置为私有，那么第一阶段就无法完成，就不能够再堆上生成对象。

### 常函数和常对象

```c++
void func() const //常函数，此处func为类成员函数
const Person p2; //常对象
```

- 常函数修饰的是this指针，不允许修改this指针指向的值，如果执意要修改常函数，可以在成员属性前加**mutable**。
- 常对象不允许修改属性，不可以调用普通成员函数，可以调用常函数。

### 友元全局函数，友元类，友元成员函数

友元主要是**为了访问类中的私有成员（包括属性和方法）**，会破坏C++的封装性，尽量不使用。

- **友元全局函数**
  - 友元函数声明可以在类中的任何地方，一般放在类定义的开始或结尾。
  - 一个函数可以是多个类的友元函数，只需要在各个类中分别声明。
  - 友元函数在类内声明，类外定义，定义和使用时不需加作用域和类名，与普通函数无异。
- **友元类**
  - 友元**不可继承**。
  - 友元是**单向的**，类A是类B的友元类，但类B不一定是类A的。
  - 友元**不具有传递性**，类A是类B的友元类，类B是类C的友元类，但类A不一定是类C的友元类。
- **友元成员函数**
  - 使类B中的成员函数成为类A的友元函数，这样类B的该成员函数就可以访问类A的所有成员，需注意友元声明和友元定义之间的相互依赖，必须先定义包含成员函数的类B，才能在类A将成员函数设为友元，另一方面，不必预先声明类和非成员函数来将它们设为友元。

### 运算符重载与++重载实现

#### 运算符重载基本属性

- 运算符重载的目的是扩展C++中提供的运算符的适用范围，使之能作用于对象，或自定义的数据类型。
- 运算符重载的实质是函数重载，可以重载为普通函数，也可以重载为成员函数。
- 运算符重载也是多态的一种，和函数重载称为静态多态，表示函数地址早绑定，在编译阶段就确定好了地址。

#### 运算符重载总结

- 重载运算符()，[] ，->，=的时候，运算符重载函数必须声明为类的成员函数。
- 重载运算符<<，>>的时候，运算符只能通过全局函数配合友元函数进行重载。
- 不要重载&&和||运算符，因为无法实现短路原则。

#### i++和++i实现

C++内置类型的后置++返回的是**变量的拷贝**，也就是不可修改的值；前置++返回的是**变量的引用**，因此可以作为修改的左值。即++（++a）或（++a）++都可以，但++（a++）不可以，（C++默认必须修改a的值，如果不修改则报错）。

```c++
//++i
int& int::operator++()
{
    *this +=1;
    return *this;
}

//i++，注意后置++有占位参数以区分跟前置++不同
const int int::operator++(int)
{
    int oldValue = *this;
    ++(*this);
    return oldValue;
}
```

### 继承方式，对象模型，同名处理

继承主要是为了减少代码的重复内容，解决代码复用问题。通过抽象出一个基类（父类），将重复代码写到基类中，在派生类（子类）中实现不同的方法。

#### 继承方式

- 公有继承：保持父类中的访问属性。
- 私有继承：将父类中的所有访问属性改为private。
- 保护继承：除父类中的私有属性，其他改为保护属性。

#### 继承的对象模型

- 子类中会继承父类的私有成员，只是被编译器隐藏起来了，无法访问到，通过sizeof(子类class)可以检查出。
- 子类创建对象时，先调用父类的构造函数，然后再调用自身的构造，析构顺序与构造顺序相反。
  - 由于继承中父类和子类的构造，析构顺序原因，当父类中只提供了有参构造（默认构造等函数会被隐藏），而子类仅仅调用默认构造时，会因为子类创建对象时无法调用父类构造函数而报错，这里可以**让子类利用初始化列表来显式调用父类有参构造函数来进行父类构造，然后进行子类构造**。
- 子类会继承父类的成员属性和成员函数，但子类不会继承父类构造函数和析构函数。

#### 继承中的同名处理

- 父类和子类**成员属性**同名，**用子类声明对象调用子类属性，若想调用父类成员，则加上父类的作用域**。
- 父类和子类**成员函数**同名，子类函数不会覆盖父类的成员，只是隐藏起来，**用子类声明对象调用子类成员函数，若想调用父类函数（包括重载），则加上父类的作用域**。
- 若子类中**没有与父类同名的成员函数**，子类声明对象后，**可以直接调用父类成员函数**。

#### 继承中静态成员处理

同名成员和非静态成员基本一致，同样可以被子类继承，但**静态成员可以通过类名直接访问，不需要创建对象。**

### 多继承和菱形继承

#### 多继承

多继承会产生二义性的问题，如果继承的多个父类中有同名的成员属性和成员函数，在子类调用时，需要指定作用域从而确定父类。

#### 菱形继承

两个子类继承于同一个父类，同时又有另外一个类多继承于两个子类，这种继承称为菱形继承。比如羊和驼继承于动物类，同时羊驼继承于羊和驼。

#### 菱形继承会产生问题

- **浪费空间：**羊驼继承了两份动物类中的某些数据和函数，但只需要一份即可。
- **二义性：从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题。** 羊驼调用数据和函数时，会出现二义性，通过sheep类得到一个age，通过camel类得到一个age，两个数据不会相互影响，相互修改，导致同一份数据不一致。

#### 解决菱形继承的问题

使用虚继承，在**继承方式前加virtual**，这样的话羊驼可以直接访问m_Age，不用添加作用域，且这样操作的是共享的一份数据。

```c++
class Animal{
public:
    int m_Age;
};
class Sheep:virtual public Animal{
    int m_sheep;
};
class Camel :virtual public Animal{
    int m_camel;
};

class Son :public Sheep, public Camel{
    int m_son;
};
void test01(){
    Son son;
    son.m_Age = 10;
    cout << sizeof(Animal) << endl; //m_Age
    cout << sizeof(Sheep) << endl;  //sheep-Vbptr,m_sheep,m_Age
    cout << sizeof(Camel) << endl;  //camel-Vbptr,m_camel,m_Age
    cout << sizeof(Son) << endl;    //sheep-Vbptr,m_sheep,camel-Vbptr,m_camel,m_son,m_Age
}
```

- **特别注意：**此时son没有自己的虚基类表和虚基类指针，只是继承了sheep和camel的虚基类指针和虚基类表，只是修改了两个虚基类表中的值，修改为当前类中，如何通过继承的虚基类指针查找虚基类数据。
- Son继承Sheep父类，父类中有虚基类指针vbptr(virtual base pointer)，对象结构类似结构体，首元素是虚基类指针，其余为自身数据（不包括静态成员和成员函数）。
- Sheep的虚指针指向下面Sheep的虚基类表vbtale@Sheep(virtual base table)，虚基类表是一个整型数组，数组第二个元素值为20，即Sheep的虚指针地址偏移20指向Animal的m_Age地址。Camel父类同理，因此，类中只有一个m_Age元素。
- Son中包含了两个指针和四个int类型，所以大小为24。

```c++
class Animal{
public:
    int m_Age;
};
class Sheep:virtual public Animal{
    int m_sheep;
};
class Camel :virtual public Animal{
    int m_camel;
};

class Son :virtual public Sheep, virtual public Camel{
    int m_son;
};
void test01(){
    Son son;
    son.m_Age = 10;
    cout << sizeof(Animal) << endl; //m_Age
    cout << sizeof(Sheep) << endl;  //sheep-Vbptr,m_sheep,m_Age
    cout << sizeof(Camel) << endl;  //camel-Vbptr,m_camel,m_Age
    cout << sizeof(Son) << endl;    //son-vbptr,m_son,m_Age,sheep-Vbptr,m_sheep,camel-Vbptr,m_camel
}
```

- 注意跟上面的区别，一个是son类中的元素顺序，一个是son类有了自己的虚基类指针和虚基类表。

**虚继承**

- 一般通过虚基类指针和虚基类表实现，将共同基类设置为虚基类。
- **每个虚继承的子类（虚基类本身没有）**都有一个虚基类指针（占用一个指针的存储空间）和虚基类表（不占用类对象的存储空间），**虚基类指针属于对象，虚基类表属于类**。
- 当虚继承的子类被当做父类继承时，虚基类指针也会被继承。
- 虚表中只记录了虚基类数据在派生类对象中与派生类对象首地址（虚基类指针）之间的偏移量，以此来访问虚基类数据。
- 虚继承不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。
- 虚基类表本质是一个**整型数组**。

### 静态函数可以是虚函数吗

不可以，因为虚函数属于对象，不属于类，静态函数属于类。

### 类型兼容性原则，为什么会有多态

类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代，如使用子类对象可以直接赋值给父类对象或子类对象可以直接初始化父类对象时，**对于同样的一条语句，不管传入子类还是父类对象，都是调用的父类函数，但我们想实现的是同样的一条语句，传入不同的对象，调用不同的函数**，我们想**传入子类对象调用子类函数，传入父类对象调用父类函数**，即同样的调用语句有多种不同的表现形态，这样就出现了**多态**。