###  MySQL 的查询流程具体是，一条SQL语句在MySQL中如何执行（1）

客户端请求 ---> 连接器（验证用户身份，给予权限）  ---> 查询缓存（存在缓存则直接返回，不存在则执行后续操作） ---> 分析器（对SQL进行词法分析和语法分析操作）  ---> 优化器（主要对执行的sql优化选择最优的执行方案方法）  ---> 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口） ---> 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）

<img src="/Users/wushengna/manual/img/img-post/MySQL查询.png" alt="MySQL查询" style="zoom:67%;" />

### 说说MySQL有哪些存储引擎，都有哪些区别

1. InnoDB **支持事务**，MyISAM **不支持事务**。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；
2. InnoDB **支持外键**，而 MyISAM **不支持外键**。对一个包含外键的 InnoDB 表转为 MyISAM 会失败；
3. InnoDB 是**聚簇索引**，MyISAM 是**非聚簇索引**。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是非聚簇索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和非聚簇索引是独立的。
4. InnoDB **不保存表的具体行数**，执行`select count(*) from table` 时需要全表扫描。而 MyISAM **用一个变量保存了整个表的行数**，执行上述语句时只需要读出该变量即可，速度很快；
5. InnoDB **最小的锁粒度是行锁**，MyISAM **最小的锁粒度是表锁**。行锁可以提高多用户并发操作，但InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。MyISAM一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

| 对比项   | MyISAM                                                   | InnoDB                                                       |
| -------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| 主外键   | 不支持                                                   | 支持                                                         |
| 事务     | 不支持                                                   | 支持                                                         |
| 行表锁   | 表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作 | 行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作   |
| 缓存     | 只缓存索引，不缓存真实数据                               | 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响 |
| 表空间   | 小                                                       | 大                                                           |
| 关注点   | 性能                                                     | 事务                                                         |
| 默认安装 | 是                                                       | 是                                                           |

### 索引（1）

#### 概念

索引是**对数据进行排序并快速查找的数据结构**，主要功能是排序和查找。

#### 数据结构

B/B+树，hash索引，存储引擎MyISAM和InnoDB使用的B/B+树，MEMORY/Heap有hash和B/B+，默认是hash。

- B/B+树，hash索引的区别
  - hash适用于等值查找的情况，不能进行范围查找；hash索引在任何时候都不能避免表扫描。
  - hash不支持多列联合索引的最左匹配规则，当有大量重复键值的情况，由于hash冲突，性能并不一定就会比B-Tree索引高。
- 为什么B+树比红黑树和B树更适合文件系统索引
  - B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低，通常B+树用于数据库索引，而B树则常用于文件索引，与B+树相比好处是有时不需要访问到叶节点就可以获取数据。
  - B+树的非叶子结点中只存放关键字的信息，没有存放关键字具体信息，因此结点更小，如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了。
  - B+树由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路，所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
  - B+树是一种特殊的平衡多路树，而红黑树是二叉的，它的深度相对B+树来说更大，更大的深度意味着查找次数更多，更频繁的磁盘IO，所以红黑树更适合在内存中进行查找。

#### 索引分类

- 单值索引
  - 索引包含单个列。
- 联合索引
  - 索引包含多个列，专门用于联合搜索，其效率大于索引合并。
- 唯一索引
  - 每张表可以有多个唯一索引，但是每个唯一索引只能有一列，索引列必须唯一 ，可以有NULL。
  - 主键索引是唯一索引的特殊类型，主键自动建立索引，每张表中的主键索引只能有一个，主键索引可以既防止重复，又提高访问速度，不可以有NULL。
- 非唯一索引
  - 普通索引，为了提高访问速度，每张表可以有多个普通索引，索引中的值可以有NULL，可重复。
- 全文索引
  - 可以加快模糊查询。

索引合并，使用多个单列索引组合搜索。

覆盖索引，select的数据列只用从索引中就能够取得，不必读取数据行，即查询列要被所建的索引覆盖。

#### 什么样的字段适合创建索引

- 主键自动建立唯一索引。
- 经常作查询选择的字段。
- 经常作表连接的字段，比如外键。
- 经常出现在order by，group by，distinct 后面排序或分组的字段。
- 单键/联合索引的选择问题，高并发下倾向创建联合索引。

#### 哪些不适合建立索引

- 数据记录太少的表<300w。
- 经常增删改的表。
- 数据重复且分布平均的表字段，如性别和国籍。
- where条件里用不到的字段不创建索引。

#### 索引的缺点

- 时间方面：创建索引和维护索引要耗费时间，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；
- 空间方面：索引需要占物理空间。

#### 最左前缀原则

- 在创建联合索引的时候，联合索引多个字段之间顺序需要如何选择
  - 把最频繁，识别度最高的放在最前面，因为最左前缀原则。
- 最左前缀原则：最左优先，即创建了lname_fname_age多列索引，相当于创建了(lname)单列索引，(lname,fname)联合索引以及(lname,fname,age)联合索引。

### 聚集索引和非聚集索引

聚集索引和非聚集索引的根本区别是**表记录的排列顺序和与索引的排列顺序是否一致**。聚集索引的逻辑顺序和物理顺序相同，非聚集索引则不同。

#### B+树叶子结点可以存哪些数据

- 聚集索引的叶节点就是数据节点，而非聚集索引的叶节点仍然是索引节点，只不过其包含一个指向对应数据块的指针。
- 叶子结点存储的是主键整行数据的是聚簇索引，叶子结点存储的仅仅是主键，然后通过指针指向具体信息的是非聚簇索引。

### MySQL怎么建立索引，怎么建立主键索引，怎么删除索引

MySQL建立索引有两种方式：用alter table或者create index。

```mysql
alter table table_name add primary key(column_list) #添加一个主键索引
alter table table_name add index (column_list)      #添加一个普通索引
alter table table_name add unique (column_list)     #添加一个唯一索引
```

```mysql
create index index_name on table_name (column_list)   #创建一个普通索引
create unique index_name on table_name (column_list)  #创建一个唯一索引
```

Mysql删除索引同样也有两种方式：alter table 和 drop index。

```mysql
alter table table_name drop index index_name    #删除一个普通索引
alter table table_name drop primary key         #删除一个主键索引
```

```mysql
drop index index_name on table table_name
```

### 优化

#### 索引优化

- 全值匹配我最爱
  - 创建索引后，尽量在where筛选条件中使用索引列。
- 最左前缀要遵守
  - 建立索引，将最常用的放在最左侧。
- 带头大哥不能死
  - 查询从索引最左列开始 ，否则全部**失效**。
- 中间兄弟不能断
  - 不能跳过索引中的列，否则部分**失效**。
- 索引列上少计算
  - 不在索引列上做任何操作，比如计算或类型转换，有些VARCHAR不写引号，sql会默认转换，但索引**失效**。
- 范围之后全失效
  - 用<或>时，当前索引不失效，范围条件右边的列**失效**。
- LIKE百分写最右
  - LIKE百分号不要写在最左侧，否则索引**失效**。
- 覆盖索引不写*
  - 当查询索引列时，select后面不写*，而是写索引列。
- 不等空值还有or
  - 尽量不使用！=或<>符号，不使用is NULL或is not NULL，少用or，否则索引**失效**。
- VARCHAR引号不能丢
  - 字符串不用单引号会**失效**，相当于索引列做自动类型转换。

#### 查询优化

- 慢查询步骤和过程。
  - 开启慢查询。
    - set slow_query_log = 1慢查询开启状态。
    - slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）。
  - 设置超时阈值，比如5s或10s，超时的sql语句会放在慢日志中。
    - long_query_time 查询超过多少秒才记录。
  - cat查看慢日志。
  - 用explain分析慢sql语句。
- explain优化，实际上模拟优化器执行sql语句，查看mysql如何执行你的sql语句。
  - table：显示这一行的数据是关于哪张表的。
  - type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const，eq_ref，ref，range，index和ALL，一般来说到range不错，最好到ref。
    - all:full table scan ;MySQL将遍历全表以找到匹配的行；
    - index: index scan; index 和 all的区别在于index类型只遍历索引；
    - range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，等查询；
    - ref：非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找；
    - eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描；
    - const，system：当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量。
  - possible_keys：显示可能应用在这张表中的索引，如果为空，没有可能的索引，可以为相关的域从WHERE语句中选择一个合适的语句。
  - key： 实际使用的索引，如果为NULL，则没有使用索引，很少的情况下，MySQL会选择优化不足的索引，这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引。
  - key_len：使用的索引的长度，在不损失精确性的情况下，长度越短越好。
  - rows：MySQL认为必须检查的用来返回请求数据的行数。
  - Extra：关于MySQL如何解析查询的额外信息。
    - Using temporary和Using filesort，意思MySQL根本不能使用索引，结果是检索会很慢。
    - Using index表示不错的信息，使用了覆盖索引。
- 根据explain的结果，进行索引优化。

### 事务的四大特性ACID

#### 事务

事务是**用户自定义的一个数据库操作序列**，这些操作要么全做，要么全不做，是一个不可分割的工作单位。在关系数据库中，事务可以是一条SQL语句，也可以是一组SQL语句。

#### 四大特性ACID

事务具有4个基本特征，分别是：原子性（Atomicity），一致性（Consistency），隔离性（Isolation），持久性（Duration），简称ACID。

- **原子性**
  - 事务所包含的一系列数据库操作要么全部成功执行，要么全部回滚。
  - 事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。
- **一致性**
  - 事务必须使数据库从一个一致性状态变换到另一个一致性状态。
  - 一致性是指数据处于一种语义上的有意义且正确的状态，一个事务执行之前和执行之后都必须处于一致性状态。
- **隔离性**
  - 并发执行的事务之间不能相互影响。
  - 当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰。
- **持久性**
  - 指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的。
  - 即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

### 事务的并发

从理论上来说，事务应该彼此完全隔离，以避免并发事务所导致的问题，然而，那样会对性能产生极大的影响，因为事务必须按顺序运行， 在实际开发中，为了提升性能，事务会以较低的隔离级别运行，这样会带来一些问题。

- **脏读**

  - 一个事务读取了另一个事务修改但未提交的数据；

  - 事务A读取事务B更新的数据，然后事务B回滚，此时事务A读到的是脏数据。

    ![脏读](/Users/wushengna/manual/img/img-post/脏读.jpg)

- **不可重复读**

  - 不可重复读的**重点是修改**，同样条件下两次读取结果不同，即被读取的数据可以被其它事务修改；

  - 事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。

    ![不可重复读](/Users/wushengna/manual/img/img-post/不可重复读.jpeg)

- **幻读**

  - 幻读的**重点在于新增或者删除**，同样条件下两次读出来的记录数不一样。

  - 事务A统计表中的数据，此时事务B想表中添加或删除了数据，当事务A再次统计表中的数据时，发现两次的记录不一样。

    ![幻读](/Users/wushengna/manual/img/img-post/幻读.jpeg)

- **不可重复读和幻读的区别**

  - 不可重复读侧重于修改，幻读侧重于新增或删除。
  - 解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。

### 事务的隔离级别

- **读未提交**，最低的隔离级别，会产生脏读，不可重复读，幻读问题。

- **读提交**，会产生不可重复读，幻读问题，在每一次进行普通的`select`时，都会重新生成一个视图。

- **可重复读**，会产生幻读问题，通过锁行来实现，只在第一次进行普通的`select`时，生成一个视图，之后的查询操作都重复使用这一个视图。

- **串行化**，最高的隔离级别，在这个隔离级别下，不会产生任何异常，通过锁表来实现。并发的事务，就像事务是在一个个按照顺序执行一样。

  ![事务隔离级别](/Users/wushengna/manual/img/img-post/事务隔离级别.jpeg)

#### Mysql中默认的事务隔离级别

可重复读的事务本身是会发生幻读，但MySQL中默认事务隔离级别是**“可重复读”**，不会发生脏读，可重复读和幻读的情况，因为可以通过Next-Key进行控制，Next-Key锁是行锁和GAP（间隙锁）的合并。

- 事务隔离级别：读未提交时，写数据只会锁住相应的行。
- 事务隔离级别为：可重复读时，写数据会锁住整张表。
- 事务隔离级别为：串行化时，读写数据都会锁住整张表。

### MVCC（多版本并发控制）

每次对记录进行改动，都会生成一条undo日志记录，把旧值相关信息放入日志，就相当于该记录的旧版本，每条undo日志都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），**那么所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值，另外每个版本中还包含生成该版本时对应的事务ID**。

**MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用读提交，可重复读这两种隔离级别的事务，在执行普通的select操作时访问记录的版本链的过程**。查询语句只能读到在生成ReadView之前已提交事务所做的更改，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的，而写操作肯定针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本并不冲突，也就是采用 MVCC 时，读-写操作并不冲突。

![MVCC版本链示意图](/Users/wushengna/manual/img/img-post/MVCC版本链示意图.png)

对于不同的隔离级别，需要判断版本链中的版本，哪个是当前事务可见的，所以在事务进行快照读操作时会生产数据库系统当前的一个快照：读视图Read View。读提交，可重复读这两个隔离级别的一个很大不同就是生成ReadView的时机不同，**读提交在每一次进行普通select操作前都会生成一个ReadView，而可重复读只在第一次进行普通select操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView**。ReadView里维护了生成该ReadView的事务ID，当前系统中活跃的读写事务的事务ID列表，最小事务ID，系统应该分配给下一个事务ID值。遍历版本链，根据版本ID与ReadView维护的四个变量比较，可知select返回的结果集。

使不同事务的读-写，写-读操作并发执行，从而提升系统性能，**执行delete语句或者更新主键的updata语句并不会立即把对应的记录完全从页面中删除，而是执行delete mark操作，相当于只是对记录打上了一个删除标志位，当该删除语句所在的事务提交之后，会有专门的线程后来真正地把记录删除掉**，这主要就是为MVCC服务的，MVCC只是在进行普通的SELECT查询时才生效。insert undo在事务提交之后就可以被释放掉了，而update undo由于还需要支持MVCC，不能立即删除掉。

事务利用MVCC进行的读取操作称之为一致性读，或者一致性无锁读，也称为快照读，一致性读并不会对表中的任何记录做加锁操作，其他事务可以自由的对表中的记录做改动。

### 一张表里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是多少

- 如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID记录到**数据文件**中，重启MySQL自增主键的最大ID也不会丢失；

- 如果表的类型是InnoDB，那么是15。因为InnoDB表只是把自增主键的最大ID记录到**内存**中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。

### 哪个存储引擎执行 select count(*) 更快

MyISAM更快，因为MyISAM内部维护了一个计数器，可以直接调取。

- 在 MyISAM 存储引擎中，把表的总行数存储在磁盘上，当执行`select count(*) from t`时，直接返回总数据。
- 在 InnoDB 存储引擎中，跟 MyISAM 不一样，没有将总行数存储在磁盘上，当执行`select count(*) from t`时，会先把数据读出来，一行一行的累加，最后返回总数量。

InnoDB 中 count(*) 语句是在执行的时候，全表扫描统计总数量，所以当数据越来越大时，语句就越来越耗时了，为什么 InnoDB 引擎不像 MyISAM 引擎一样，将总行数存储到磁盘上？这跟 InnoDB 的事务特性有关，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。

### CHAR 和 VARCHAR 的区别

char是**固定长度**，varchar**长度可变**：

char(n) 和 varchar(n) 中括号中 n 代表**字符的个数**，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。存储时，前者不管实际存储数据的长度，直接按 char 规定的长度分配存储空间；而后者会根据实际存储的数据分配最终的存储空间。

**相同点：**

1. char(n)，varchar(n)中的n都代表字符的个数。
2. 超过char，varchar最大长度n的限制后，字符串会被截断。

**不同点：**

1. char不论实际存储的字符数都会占用n个字符的空间，而varchar只会占用实际字符应该占用的字节空间加1（实际长度length，0<=length<255）或加2（length>255）。因为varchar保存数据时除了要保存字符串之外还会加一个字节来记录长度（如果列声明长度大于255则使用两个字节来保存长度）。
2. 能存储的最大空间限制不一样，char的存储上限为255字节。
3. char在存储时会截断尾部的空格，而varchar不会。

char是适合存储很短的、一般固定长度的字符串。例如，char非常适合存储密码的MD5值，因为这是一个定长的值。对于非常短的列，char比varchar在存储空间上也更有效率。

### 列的字符串类型可以是什么

字符串类型是：SET、BLOB、ENUM、CHAR、TEXT、VARCHAR。

### BLOB和TEXT有什么区别

- BLOB是一个二进制对象，可以容纳可变数量的数据。有四种BLOB类型：TINYBLOB、BLOB、MEDIUMBLO和LONGBLOB。

- TEXT是一个不区分大小写的BLOB。四种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT。

- BLOB 保存二进制数据，TEXT 保存字符数据。

### 为什么推荐使用整型自增主键而不是选择UUID

- UUID（通用唯一识别码）是字符串，比整型消耗更多的存储空间；
- 在B+树中进行查找时需要跟经过的节点值比较大小，整型数据的比较运算比字符串更快速；
- 自增的整型索引在磁盘中会连续存储，在读取一页数据时也是连续；UUID是随机产生的，读取的上下两行数据存储是分散的，不适合执行where id > 5 && id < 20的条件查询语句。
- 在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，不会破坏左侧子树的结构；UUID主键很容易出现这样的情况，B+树为了维持自身的特性，有可能会进行结构的重构，消耗更多的时间。

### 为什么非主键索引结构叶子节点存储的是主键值

保证数据一致性和节省存储空间，可以这么理解：商城系统订单表会存储一个用户ID作为关联外键，而不推荐存储完整的用户信息，因为当我们用户表中的信息（真实名称、手机号、收货地址···）修改后，不需要再次维护订单表的用户数据，同时也节省了存储空间。

### drop，truncate和delete的区别

- drop
  - 直接删除表。
- truncate
  - 清空整个表数据，并不删除表。
  - 若删除自增列，再次插入从1开始。
- delete
  - 可以通过where删除某一行的数据。
  - 删除自增列，再次插入从断点开始。

### like %和-的区别

%不限制通配的个数，-仅仅是一个字符。

### count(*)，count(1)和count(列名)的区别

- count(*)对行的数目进行计算，包含NULL。
- count(1)这个用法和count(*)的结果是一样的，如果表没有主键，那么count(1)比count( * )快。
- count(column)对特定的列的值具有的行数进行计算，不包含NULL值。
- 任何时候count(*)都是最优选择。

### MySQL中in和exists的区别

- exists：exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当exists里的条件语句能够返回记录行时（无论记录行是的多少，只要能返回），条件就为真，返回当前loop到的这条记录；反之，如果exists里的条件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为false。
- in：in查询相当于多个or条件的叠加。

```sql
SELECT * FROM A WHERE A.id IN (SELECT id FROM B);
SELECT * FROM A WHERE EXISTS (SELECT * from B WHERE B.id = A.id);
```

**如果查询的两个表大小相当，那么用in和exists差别不大**。

如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。

### UNION和UNION ALL的区别

UNION和UNION ALL都是将两个结果集合并为一个，**两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；**

- UNION在进行表连接后会筛选掉重复的数据记录（效率较低），而UNION ALL则不会去掉重复的数据记录；
- UNION会按照字段的顺序进行排序，而UNION ALL只是简单的将两个结果合并就返回；

### SQL执行顺序

- 手写

```sql
SELECT DISTINCT <select_list>
FROM <left_table> <join_type>
JOIN <right_table>
ON <join_condition>
WHERE <where_condition>
GROUP BY <group_by_list>
HAVING <having_condition>
ORDER BY <order_by_condition>
LIMIT <limit_number>
```

- 机读

```sql
FROM <left_table> <join_type>
ON <join_condition>
JOIN <right_table> 
WHERE  <where_condition>
GROUP BY  <group_by_list>
HAVING <having_condition>
SELECT DISTINCT <select_list>
ORDER BY <order_by_condition>
LIMIT <limit_number>
```

### 内连接、左右外连接（1）

- 内连接（inner join）: 只连接匹配的行。
- 左外连接（left join）: 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行。
- 右外连接（right join）: 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行。

**Join图**

<img src="/Users/wushengna/manual/img/img-post/join连接.png" alt="join连接" style="zoom:67%;" />

### 事务是怎么实现的

* 日志恢复：数据库里有两个日志，一个是redo log，一个是undo log。redo log记录的是已经成功提交的事务操作信息，用来恢复数据，保证事务的**持久性**，undo log记录的是事务修改之前的数据信息，用来回滚数据，保证事务的**原子性**和**一致性**。
* 并发控制：并发控制主要靠读写锁和MVCC（多版本并发控制）来实现。读写锁包括共享锁和排他锁，保证事务的**隔离性**和**一致性**，MVCC通过为数据添加时间戳来实现。按照其对可能冲突的操作采取的不同策略可以分为乐观并发控制和悲观并发控制两大类，乐观并发控制，对于并发执行可能冲突的操作，假定其不会真的冲突，允许并发执行，直到真正发生冲突时才去解决冲突，比如让事务回滚，悲观并发控制，对于并发执行可能冲突的操作，假定其必定发生冲突，通过让事务等待(锁)或者中止(时间戳排序)的方式使并行的操作串行执行。

### 事务是如何通过日志来实现的

事务日志包括：**重做日志redo**和**回滚日志undo**

- **redo log（重做日志**） 实现持久化和原子性

  在innoDB的存储引擎中，事务日志通过重做(redo)日志和innoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。

  在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录Redo Log，通过顺序IO来改善性能。所有的事务共享redo log的存储空间，它们的Redo Log按语句的执行顺序，依次交替的记录在一起。

- **undo log（回滚日志）**  实现一致性

  undo log 主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。

  Undo记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下回滚日志是记录下表空间中的（共享表空间或者独享表空间）。

二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同，redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。

### 二进制文件binlog

用来记录对mysql数据更新或潜在发生更新的SQL语句，并以"事务"的形式保存在磁盘中。

#### 作用

- 复制
  - 用于主从复制，读写分离，Master把它的二进制日志传递给slaves并回放（在slave上执行一遍）来达到master-slave数据一致的目的。
- 恢复
  - 让mysql将保存在binlog日志中指定段落区间的sql语句逐个重新执行一次。

### redo log（重做日志）和binlog（归档日志）的区别

- redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
- redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
- redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的，“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

### 还不能去掉binlog的原因

- redo log只有InnoDB有，别的引擎没有。
- redo log是循环写的，不持久保存，binlog的“归档”这个功能，redo log是不具备的。

### MySQL有多少种日志

- **错误日志**：记录出错信息，也记录一些警告信息或者正确的信息。
- **查询日志**：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。
- **慢查询日志**：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。
- **二进制日志**：记录对数据库执行更改的所有操作。
- **中继日志**：中继日志也是二进制日志，用来给slave库恢复。
- **事务日志**：重做日志redo和回滚日志undo。

### select for update有什么含义，会锁表还是锁行还是其他

**for update 仅适用于InnoDB，且必须在事务块（BEGIN/COMMIT）中才能生效。**在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。

InnoDB这种行锁实现特点意味着：**只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！** 假设有个表单 products ，里面有id跟name二个栏位，id是主键。

- 明确指定主键，并且有此笔资料，row lock。

```sql
SELECT * FROM products WHERE id='3' FOR UPDATE;
SELECT * FROM products WHERE id='3' and type=1 FOR UPDATE;
```

- 明确指定主键，若查无此笔资料，无lock。

```sql
SELECT * FROM products WHERE id='-1' FOR UPDATE;
```

- 无主键，table lock。

```sql
SELECT * FROM products WHERE name='Mouse' FOR UPDATE;
```

- 主键不明确，table lock。

```sql
SELECT * FROM products WHERE id<>'3' FOR UPDATE;
```

- 主键不明确，table lock。

```sql
SELECT * FROM products WHERE id LIKE '3' FOR UPDATE;
```

### MySQL高并发的解决方案和优化

高频访问：

* 分表分库：将数据库表进行水平拆分，减少表的长度。
* 增加缓存： 在web和DB之间加上一层缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。
* 增加数据库的索引：在合适的字段加上索引，解决高频访问的问题，提高查询速度（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）。

并发优化：

* 主从读写分离：只在主服务器上写，从服务器上读。
* 负载均衡集群：通过集群或者分布式的方式分散计算压力。

### MySQL主从复制

#### 原理

- 主从复制需要三个线程来完成。
  - 主库中有一个**binary-log dump线程**，当从库连接主库时，主库会创建该线程，用于给从库发送二进制文件信息，其中读取二进制文件信息的时候会加锁。
  - 从库中有两个线程，一个是**从节点I/O线程**，一个是**SQL线程**。其中从节点I/O线程接收主节点线程发来的二进制文件信息，存入到中继日志文件（relay-log），SQL线程负责执行中继日志文件中的SQL操作。
- Master将数据改变记录到二进制日志(binary log)中。
- Slave上面的IO进程连接上Master，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容。
- Master接收到来自Slave的IO进程的请求。
  - 负责复制的IO进程会根据请求信息读取日志指定位置之后的日志信息，返回给Slave的IO进程。
  - 返回信息中除了日志所包含的信息之外，还包括本次返回的信息已经到Master端的bin-log文件的名称以及bin-log的位置。
- Slave的IO进程接收到信息后，将接收到的日志内容依次添加到Slave端的relay-log文件的最末端，并将读取到的Master端的bin-log的文件名和位置记录到master-info文件中，以便在下一次读取的时候能够清楚的告诉Master从某个bin-log的哪个位置开始往后的日志内容。
- Slave的Sql进程检测到relay-log中新增加了内容后，会马上解析relay-log的内容成为在Master端真实执行时候的那些可执行的内容，并在自身执行，从而实现主从数据的一致。

#### 读写分离

基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。

#### 三种复制方式

- 同步
  - master的变化，必须等待slave-1,slave-2,...,slave-n完成后才能返回。这样显然不可取，也不是MySQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。
- 异步
  - master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心，MySQL的默认设置，**这样可能会丢失数据**。
- 半同步
  - master一般至少有两个slave，主库写入 bin-log 日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的 relay-log 之后，接着会返回一个 ack 给主库，主库接收到至少一个从库的 ack 之后才会认为写操作完成了。
- 注意
  - 从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。
    - 由于从库从主库拷贝日志以及串行执行SQL的特点，在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。
    - 经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。
  - 解决思路
    - 从库中开启多线程并行操作。

### 随着业务的发展，业务越来越复杂，应用的模块越来越多，总的数据量很大，高并发读写操作均超过单个数据库服务器的处理能力怎么办

这个时候就出现了**数据分片**，数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中。数据分片的有效手段就是对关系型数据库进行分库和分表。

区别于分区的是，分区一般都是放在单机里的，用的比较多的是时间范围分区，方便归档。只不过分库分表需要代码实现，分区则是mysql内部实现。分库分表和分区并不冲突，可以结合使用。

### 为什么要分库

数据库集群环境后都是多台 slave，基本满足了读取操作; 但是写入或者说大数据、频繁的写入操作对master性能影响就比较大，这个时候，单库并不能解决大规模并发写入的问题，所以就会考虑分库。

### 分库是什么

一个库里表太多了，导致了海量数据，系统性能下降，把原本存储于一个库的表拆分存储到多个库上， 通常是将表按照功能模块、关系密切程度划分出来，部署到不同库上。

优点：

- 减少增量数据写入时的锁对查询的影响。
- 由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘IO，时延变短。

但是它无法解决单表数据量太大的问题。

### 数据库范式

范式之间的关系，第一范式包含第二范式，第二范式包含第三范式。这里只举反例，因为实际的数据在设计数据库表的时候，范式都是相对的。

- **第一范式 1NF**
  - **列不可再分，确保每列保持原子性，所有字段值都是不可分解的原子值。**
  - 比如，学生包括学号、姓名；地址包括省份，城市。若在使用中经常访问学号，城市等字段，则建表时，不能把学生、地址作为字段，若将其作为字段，则不满足第一范式。
  - 将学号、城市等作为字段，符合第一范式（相对来讲，因为城市还是可以分的，只是平时访问的多，也不会访问城市以下的字段）。
- **第二范式 2NF**
  - **非主属性完全依赖于主键，需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。**
  - 比如，学号，课程号，学院，成绩建一个数据库表。此时（学号，课程号）为主键，也称联合主键，此时只能当学号，课程号两者都确定的情况下，才能确定成绩，但学院只与学号有关，因此部分依赖于联合主键，这种情况不符合第二范式。
- **第三范式 3NF**
  - **数据表中的每一列数据都和主键直接相关，而不能间接相关，每一个非主属性既不传递依赖主键，也不部分依赖主键。**
  - 订单表【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity）主键是（OrderID），CustomerName，CustomerAddr，CustomerCity 直接依赖的是 CustomerID（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合3NF。

### 主键，外键，唯一键，自增主键

- **主键 PRIMARY KEY**
  - 数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（NULL）。
- **外键 FOREIGN KEY**
  - 在一个表中存在的另一个表的KEY（可以是另外一个表的主键或唯一键）称此表的外键。
- **唯一键 UNIQE**
  - 保证字段的唯一性，可以为空。
- **自增主键 AUTO_INCREMENT**
  - 自增列每增加一行自动增量，每个表只能有一个自增列。
  - 一般将主键设置为自增列，又叫自增主键。
  - 只能是数值型，delete删除自增列后，若再次插入，从断开处插入。
  - truncate删除后，再次插入从1开始。

### MySQL中的锁

#### 读写锁

- 读锁会阻塞写，但不会阻塞读。
- 写锁会阻塞读和写。

#### 行页表锁

- 对表中的记录加锁，叫做记录锁，又称行锁，行锁只锁定一行，偏写。
- 表锁会锁定整个表，偏读。
- 页锁在行锁和表锁之间。

#### InnoDB加锁

- 对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁。

- 对于普通SELECT语句，InnoDB不会加任何锁。

- 事务可以通过以下语句显示给记录集加共享锁或排他锁。

  ```mysql
  //共享锁（Ｓ）
  SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
  //排他锁（X）
  SELECT * FROM table_name WHERE ... FOR UPDATE
  ```

### 乐观锁和悲观锁

#### 悲观锁

先获取锁，再进行业务操作，悲观的认为所有的操作均会导致并发安全问题，因此要先确保获取锁成功再进行业务操作。`select ... for update` 实现悲观锁。

#### 乐观锁

先进行业务操作，再获取锁，一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，提交更新时，时间戳或版本号必须大于当前版本才提交更新。

```mysql
SELECT data AS old_data, version AS old_version FROM …;
//根据获取的数据进行业务操作，得到new_data和new_version
UPDATE SET data = new_data, version = new_version WHERE version = old_version
if (updated row > 0) {
    // 乐观锁获取成功，操作完成
} else {
    // 乐观锁获取失败，回滚并重试
}
```

#### 使用场景

一般情况下，**读多写少更适合用乐观锁，读少写多更适合用悲观锁**。乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能。

### 乐观锁与悲观锁怎么实现

- 悲观锁有行级锁和页级锁两种形式。行级锁对正在使用的单条数据进行锁定，事务完成后释放该行数据，而页级锁则对整张表进行锁定，事务正在对该表进行访问的时候不允许其他事务并行访问。

  悲观锁要求在整个过程中一直与数据库有一条连接，因为上一个事务完成后才能让下一个事务执行，这个过程是串行的。

- 乐观锁有三种常用的实现形式：
  - 在执行事务时把整个数据都拷贝到应用中，在数据更新提交的时候比较数据库中的数据与新数据，如果两个数据一模一样则表示没有冲突可以直接提交，如果有冲突就要交给业务逻辑去解决。
  - 使用版本戳来对数据进行标记，数据每发生一次修改，版本号就增加1。某条数据在提交的时候，如果数据库中的版本号与自己的一致，就说明数据没有发生修改，否则就认为是过期数据需要处理。
  - 采用时间戳对数据最后修改的时间进行标记。

### 行锁怎么实现

- 显示系统上行锁的争夺情况`show status like 'innodb_row_lock%';`。

- 只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。

  ```mysql
  //显式锁定
  set auto_commit = 0;
  begin;
  //加索引
   ALTER TABLE account ADD INDEX index_user_id (user_id);
  //检索索引
  SELECT * FROM account WHERE user_id = 1 FOR UPDATE
  commit;
  ```

### 间隙锁

#### 概念

- 当我们使用范围条件而不是相等条件查询数据时，InnoDB会把符合条件的数据记录索引项都加锁，此时键值在条件范围内，但并不存在的数据记录称为间隙。
- 比如检索1-3之间的数据，但表中并没有数据2，此时InnoDB会对这个间隙也加锁。
- 若范围检索不提交，另一个对间隙进行操作（比如添加2）会被阻塞，无法插入数据，导致性能变差。
- 在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。

#### 作用

- 间隙锁的主要作用是为了防止出现幻读。

#### 解除间隙锁

- 修改系统参数innodb_locks_unsafe_for_binlog=on就可以关闭改间隙锁机制，该值默认为off。
- 修改事务隔离级别为read-committed也可以避免间隙锁。

### 存储过程

存储过程是事先经过编译，并存储在数据库中的一段SQL语句的集合。 通俗讲，存储过程是由一些SQL语句组成的代码块，这些SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查）。

#### 优点

- 存储过程只在创建时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL语句每执行一次就编译一次，所以使用存储过程可提高数据库执行效率；
- 当SQL语句有变动时，可以只修改数据库中的存储过程而不必修改代码；
- 通过存储过程能够使**没有权限的用户在控制之下**间接地存取数据库，从而确保数据的安全。

### 触发器

触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。如某表上的触发器上包含对另一个表的数据操作，售出一件商品，仓库库存-1。

### 视图和游标

- 视图
  - 一种虚拟的表，具有和物理表相同的功能，可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集，对视图的修改会影响基本表，相比多表查询，它使得我们获取数据更容易。
- 游标
  - 对查询出来的结果集作为一个单元来有效的处理，游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行，可以对结果集当前行做修改，一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。

### 关系型和非关系型数据库的区别

* 关系型数据库的优点
  * 容易理解，因为它采用了关系模型来组织数据。
  * 可以保持数据的一致性。
  * 数据更新的开销比较小。
  * 支持复杂查询（带where子句的查询）。
* 非关系型数据库的优点
  * 不需要经过sql层的解析，读写效率高。
  * 基于键值对，数据的扩展性很好。
  * 可以支持多种类型数据的存储，如图片，文档等。

### 什么是非关系型数据库

非关系型数据库也叫nosql，采用键值对的形式进行存储，它的读写性能很高，易于扩展，例如Redis，Mongodb，hbase等。

适合使用非关系型数据库的场景：

* 日志系统
* 地理位置存储
* 数据量巨大
* 高可用

### MySQL的表空间方式

* 共享表空间：指的是数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。 
* 独立表空间：每一个表都将会生成以独立的文件方式来进行存储。 优点：当表被删除时这部分空间可以被回收；可以更快的恢复和备份单个表；将单个表复制到另一个实例会很方便； 缺点：MySQL会维持很多文件句柄，表太多会影响性能，如果很多表都增长会导致碎片问题。