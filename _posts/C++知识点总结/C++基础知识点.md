### 1. strlen和sizeof的区别

**(1)** **strlen()**是**函数**，在**运行时**才能计算。参数必须是**字符型指针**(char*)，且必 须是**以’\0’结尾的**。当数组名作为参数传入时，实际上数组已经退化为指针了。 它的功能是**返回字符串的长度**。

**(2)** **sizeof()**是**运算符**，而不是一个函数，在**编译时**就计算好了，用于**计算数据空间的字节数**。因此，sizeof**不能用来返回动态分配的内存空间的大小**。sizeof常用于返回类型和静态分配的对象、结构或数组所占的空间（参数不退化），返回值跟对象、结构、数组所存储的内容没有关系。

```c++
1)数组一一编译时分配的数组空间大小:
char a[10] = ”hello”; //因为char占1Byte，所以sizeof(a) = 10Byte
2)指针一一存储该指针所用的空间大小: 
char *str = ”I am from China.” //因为由存储的是一个字符指针，在32位的机器上，sizeof(str) = 4Byte
3)类型一一该类型所占的空间大小:
int b = 10; //因为在32位的机器上，int类型占4Byte，sizeo(b) = 4Byte
4)对象一一对象的实际占用空间大小:
class Class Sample{
  int a,b;
  int func();
}Class_a; //两个int类型的值是8Byte，sizeof(Class_a) = 8Byte
5)函数一一函数的返回类型所占的空间大小，且函数的返回类型不能是void。
  
int main(int argc, char const *argv[]){
  const char* str = "name";
  
  sizeof(str); //取的是指针str的长度8Byte
  strlen(str); //取的是这个字符串的长度，不包含结尾的\0，大小是4Byte
}
```

### 2. 数组和指针的区别

- **概念不同：** 指针相当于一个变量，它存放的是**数据在内存中的地址**；数组是用于储存**多个相同类型数据的集合**

- **赋值不同：** 同类型指针变量**可以相互赋值**，数组不行，**只能一个一个元素的赋值或拷贝**

- **访问数据不同：** 指针是**间接访问数据**，获取指针，先解引用，再访问指针指向的地址中的内容；数组是**直接访问**

- **sizeof意义不同：** 数组**所占存储空间的内存**：sizeof（数组名），数组的大小：sizeof（数组名）/sizeof（数据类型）；在32位平台下，sizeof（指针名）是4，在64位平台下，sizeof（指针名）是8，得到的是**一个指针变量的字节数**，而不是指针所指的内存容量

- **指针和数组名异同：** 指针和数组名**都可以表示地址**，但指针是**变量**，可以修改；数组名是**常量**，不可修改赋值

- **传参：** 数组传参时会**退化成指针**
  - 退化的意义：C语言只会以值拷贝的方式传递参数，参数传递时，如果是拷贝整个数组，效率会大大降低，并且在参数位于栈上，太大的数组拷贝将会导致栈溢出。因此，C语言将数组的传参进行了退化。将整个数组拷贝一份传入函数时，将数组名看做常量指针，传数组首元素的地址。

### 3. 指针数组和数组指针

指针数组本质是数组，数组指针本质是指针，谁优先级高，本质是谁

- 指针数组：**它实际上是一个数组，数组的每个元素存放的是一个指针类型的元素**。 int* arr[8];
  - 优先级问题：[]的优先级比*高
  - 说明arr是一个数组，而int*是数组里面的内容
  - 这句话的意思就是：arr是一个含有8个int*的数组

- 数组指针：**它实际上是一个指针，该指针指向一个数组**。 int (*arr)[8];
  - 由于[]的优先级比* 高，因此在写数组指针的时候必须将*arr用括号括起来
  - arr先和*结合，说明p是一个指针变量
  - 这句话的意思就是：指针arr指向一个大小为8个整型的数组

### 4. 字符数组和字符串常量

```c++
char arr[] = "hello"; //字符数组
char *arr2 = "hello"; //字符串常量
```

- `char arr[] = "hello"`，此处的赋值是将常量区的字符串"hello"拷贝到了堆栈区的数组arr的空间了。数组arr是在堆栈区开辟了空间，此时是可以修改字符串的值，因为修改的是堆栈区的字符串的值。另外此时的数组名arr是堆栈区中的"hello"的首地址。

- `char *arr2 = "hello"`，指针arr2是存储在堆栈区，但字符串是常量，存储在常量区，只是指针arr2指向了存储在常量区的字符串首地址，此时不能改变常量区的字符串的值。

```c++
const char arr[]="hello"; //这里hello本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区
const char *arr2="hello"; //字符串hello保存在常量区，const本来是修饰arr2指向的值不能通过arr2去修改，但是字符串hello在常量区，本来就不能改变，所以加不加const效果都一样
```

### 5. 函数指针与指针函数

**含义：**

**函数指针**`int (*f)(int x)`是**指向函数入口地址的指针变量**。C++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。

**指针函数**`int* f(int x, int y)`是**返回值是指针的函数**

**声明方式：**

```c++
int func(int a); //声明一个函数
int (*f) (int a); //声明一个函数指针
int *f1(int a); //声明一个指针函数
```

上述的`f`就是一个函数指针，它指向所有返回类型为int，并带有一个int参数的函数

**函数指针的赋值方法：**

```c++
f = &func; //指针名 = &函数名
f = func; //指针名 = 函数名
```

将`func`函数的首地址赋值给函数指针，赋值时函数不带括号，也不带参数，**函数名就代表了函数的首地址**。

**函数指针的调用方法：**

```c++
#include <iostream>
using namespace std;
int Mmin(int x,int y){
  if(x < y)
    return x;
  return y;
}
int Mmax(int x,int y){
  if(x > y)
    return x;
  return y;
}
int main(){
  int (*f)(int x，int y);
  int a=l0 , b = 20;
  f = Mmin; //把Mmin函数的入口地址赋给f
  cout << (*f)(a,b) << endl; //10
  f = Mmax; //把Mmax函数的入口地址赋给f
  cout << (*f)(a,b) << endl; //20
  return 0;
}
```

有了指向函数的指针变量后，就可以实现用该指针变量使用相同参数调用不同函数了，用于调用函数和回调函数

### 6. 引用和指针的区别

- **指针有内存分配，而引用只是一个别名：** 指针是一个变量，**存储的是一个地址**，引用跟原来的变量是同一个东西，**是原变量的别名**，引用声明时必须初始化，从而指向一个已经存在的对象。
- **引用可以看做常量指针，指针是一个存储地址的变量：** 指针在运行时**可以改变其所指向的值**，而引用一旦**和某个对象绑定后就不再改变**。这句话可以理解为：指针可以被重新赋值以指向另一个不同的对象，但是引用则总是指向在初始化时被指定的对象，以后不能改变，但是**指定的对象其内容可以改变**。
- **引用创建时必须初始化，且不为空，指针创建时可以为空：** 不存在指向空值的引用这个事实，意味着**使用引用的代码效率比使用指针的要高**。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空。
- **指针和引用的自增运算符意义不同：** 指针是对**内存地址**的自增，引用是对**值**的自增。
- **sizeof的意义不同：** 使用sizeof看一个**指针的大小**是4，而引用则是**被引用对象的大小**。
- **没有引用常量，有指针常量：** 没有`int& const p`，有`int* const p`。**常量指针和常量引用是存在的**，`const int *p`和`cosnt int &p`，都表示指向的对象为常量，常量引用形参的好处：
  - 使用引用作为形参，不会产生新的变量，**减少形参和实参传递的开销**；
  - 使用引用可能会导致实参随着形参的改变而改变，**声明为const之后就会消除这种副作用**。
- **参数传递：** 作为参数传递时，指针是**间接传递**，指针需要被解引用才可以对对象进行操作，而引用是**直接传递**，直接对引用的修改都会改变引用所指向的对象。
- **多级指针，一级引用：** 指针可以有多级指针（**p），而引用只有一级

### 7. 如何判断大小端存储

**大端字节序**是指一个整数的高位字节存放在内存的低地址处，低位字节存放在内存的高地址处

**小端字节序**是指整数的高位字节存放在内存的内存的高地址处，低位字节存放在内存的低地址处

大端字节序也成为**网络字节序**，当两台采用不同字节序的主机通信时，在发送数据之前发送端都必须经过字节序的转换成为大端字节序后再发送

**判断方法：**

```c++
#include <iostream>

using namespace std;

union U{
    int a;
    char b;
}; //在一个联合体里可以定义多种不同的数据类型，这些数据共享一段内存，在不同的时间里保存不同的数据类型和长度的变量，以达到节省空间的目的，但同一时间只能存储其中一个成员变量的值

int main(){
    U u;
    u.a = 0x1234;
    if(u.b == 0x12){
        cout << "big endian" << endl;
    }
    else if(u.b == 0x34){
        cout << "little endian" << endl;
    }
    return 0;
}
```

### 8. 内存字节对齐的规则和原因

#### 规则

- 对于结构的各个成员，第一个成员位于偏移为0的位置，以后的每个数据成员的偏移量必须是`min(#pragma pack()指定的数,这个数据成员的自身长度)`的倍数
- 在所有的数据成员完成各自对齐之后，结构或联合体本身也要进行对齐，对齐将按照 #pragam pack指定的数值和结构或者联合体最大数据成员长度中比较小的那个，也就是`min(#pragram pack() , 长度最长的数据成员)`

#### 原因

- **平台原因（移植原因）：** **不是所有的硬件平台都能访问任意地址上的任意数据**，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常
- **硬件原因：** 经过内存对齐之后，**CPU的内存访问速度大大提升**。访问未对齐的内存，处理器要访问两次（数据先读高位，再读低位），访问对齐的内存，处理器只要访问一次，为了提高处理器读取数据的效率，我们使用内存对齐

#### struct和union占用字节数的计算

```c++
//struct
#include <cstdio>
#include <iostream>
using namespace std;

struct E1 {
	int a; char b; char c;
}e1; //4 + 1 + 1 + 2 = 8

struct E2 {
	char b; int a; char c;
}e2; //1 + 3 + 4 + 1 + 3 = 12

struct B{
    char a;
    double b;
    int c;
}test_struct_b; //1 + 7 + 8 + 4 + 4 = 24

struct E{

}test_struct_e; //空结构体占用字节数为1，编译器默认分配了一个字节，为了确保两个不同对象的地址不同，带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定

int main() {
	cout << sizeof(E1) << endl; //8
	
	cout << sizeof(E2) << endl; //12
  
  cout << sizeof(test_struct_b) << endl; //24
  
  cout << sizeof(test_struct_e) << endl; //1
  
	return 0;
}

//union
#include <cstdio>
#include <iostream>
using namespace std;

union A{
    int a[5];
    char b;
    double c;
}; //20 + 4 = 24

int main() {
  cout << sizeof(A) << endl; //24
	return 0;
}

//混合结构体占用字节数
#include <cstdio>
#include <iostream>
using namespace std;
#define LL long long 

struct E5 {
	char a1,a2,a3,a4,a5,a6;
}e5; //1 + 1 + 1 + 1 + 1 + 1 = 6
struct E6 {
	char a1,a2,a3;
}e6; //1 + 1 + 1 = 3
struct E7 {
	struct E5 elem5;
	struct E6 elem6;
	LL a;
}e7; //6 + 3 + 7 + 8 = 24

struct E8 {
	char a[9];
}e8; //9
struct E9 {
	struct E8 elem8;
	LL a;
}e9; //9 + 7 + 8 = 24

typedef union{
    long i;
    int k[5];
    char c;
}UDATA; //4 * 5 + 4 = 24

struct C{
    int cat;
    UDATA cow;
    double dog;
}test_struct_c; //4 + 24 + 4 + 8 = 40

UDATA temp;

int main() {
	cout << sizeof(E5) << endl; //6
  
	cout << sizeof(E6) << endl; //3
  
	cout << sizeof(E7) << endl; //24
	
	cout << sizeof(E8) << endl; //9
  
	cout << sizeof(E9) << endl; //24
  
  cout << sizeof(test_struct_c) + sizeof(temp) << endl; //40 + 24 = 64
	return 0;
}
```

