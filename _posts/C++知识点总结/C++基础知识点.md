### 1. strlen和sizeof的区别

**(1)** **strlen()**是**函数**，在**运行时**才能计算。参数必须是**字符型指针**(char*)，且必 须是**以’\0’结尾的**。当数组名作为参数传入时，实际上数组已经退化为指针了。 它的功能是**返回字符串的长度**。

**(2)** **sizeof()**是**运算符**，而不是一个函数，在**编译时**就计算好了，用于**计算数据空间的字节数**。因此，sizeof**不能用来返回动态分配的内存空间的大小**。sizeof常用于返回类型和静态分配的对象、结构或数组所占的空间（参数不退化），返回值跟对象、结构、数组所存储的内容没有关系。

```c++
1)数组一一编译时分配的数组空间大小:
char a[10] = ”hello”; //因为char占1Byte，所以sizeof(a) = 10Byte
2)指针一一存储该指针所用的空间大小: 
char *str = ”I am from China.” //因为由存储的是一个字符指针，在32位的机器上，sizeof(str) = 4Byte
3)类型一一该类型所占的空间大小:
int b = 10; //因为在32位的机器上，int类型占4Byte，sizeo(b) = 4Byte
4)对象一一对象的实际占用空间大小:
class Class Sample{
  int a,b;
  int func();
}Class_a; //两个int类型的值是8Byte，sizeof(Class_a) = 8Byte
5)函数一一函数的返回类型所占的空间大小，且函数的返回类型不能是void。
  
int main(int argc, char const *argv[]){
  const char* str = "name";
  
  sizeof(str); //取的是指针str的长度8Byte
  strlen(str); //取的是这个字符串的长度，不包含结尾的\0，大小是4Byte
}
```

### 2. 数组和指针的区别

- **概念不同：** 指针相当于一个变量，它存放的是**数据在内存中的地址**；数组是用于储存**多个相同类型数据的集合**

- **赋值不同：** 同类型指针变量**可以相互赋值**，数组不行，**只能一个一个元素的赋值或拷贝**

- **访问数据不同：** 指针是**间接访问数据**，获取指针，先解引用，再访问指针指向的地址中的内容；数组是**直接访问**

- **sizeof意义不同：** 数组**所占存储空间的内存**：sizeof（数组名），数组的大小：sizeof（数组名）/sizeof（数据类型）；在32位平台下，sizeof（指针名）是4，在64位平台下，sizeof（指针名）是8，得到的是**一个指针变量的字节数**，而不是指针所指的内存容量

- **指针和数组名异同：** 指针和数组名**都可以表示地址**，但指针是**变量**，可以修改；数组名是**常量**，不可修改赋值

- **传参：** 数组传参时会**退化成指针**
  - 退化的意义：C语言只会以值拷贝的方式传递参数，参数传递时，如果是拷贝整个数组，效率会大大降低，并且在参数位于栈上，太大的数组拷贝将会导致栈溢出。因此，C语言将数组的传参进行了退化。将整个数组拷贝一份传入函数时，将数组名看做常量指针，传数组首元素的地址。

### 3. 指针数组和数组指针

指针数组本质是数组，数组指针本质是指针，谁优先级高，本质是谁

- 指针数组：**它实际上是一个数组，数组的每个元素存放的是一个指针类型的元素**。 int* arr[8];
  - 优先级问题：[]的优先级比*高
  - 说明arr是一个数组，而int*是数组里面的内容
  - 这句话的意思就是：arr是一个含有8个int*的数组

- 数组指针：**它实际上是一个指针，该指针指向一个数组**。 int (*arr)[8];
  - 由于[]的优先级比* 高，因此在写数组指针的时候必须将*arr用括号括起来
  - arr先和*结合，说明p是一个指针变量
  - 这句话的意思就是：指针arr指向一个大小为8个整型的数组

### 4. 字符数组和字符串常量

```c++
char arr[] = "hello"; //字符数组
char *arr2 = "hello"; //字符串常量
```

- `char arr[] = "hello"`，此处的赋值是将常量区的字符串"hello"拷贝到了堆栈区的数组arr的空间了。数组arr是在堆栈区开辟了空间，此时是可以修改字符串的值，因为修改的是堆栈区的字符串的值。另外此时的数组名arr是堆栈区中的"hello"的首地址。

- `char *arr2 = "hello"`，指针arr2是存储在堆栈区，但字符串是常量，存储在常量区，只是指针arr2指向了存储在常量区的字符串首地址，此时不能改变常量区的字符串的值。

```c++
const char arr[]="hello"; //这里hello本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区
const char *arr2="hello"; //字符串hello保存在常量区，const本来是修饰arr2指向的值不能通过arr2去修改，但是字符串hello在常量区，本来就不能改变，所以加不加const效果都一样
```

### 5. 函数指针

**含义：**

函数指针是**指向函数的指针变量**。C++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。

**声明方式：**

```c++
int func(int a); //声明一个函数
int (*f) (int a); //声明一个函数指针
```

上述的`f`就是一个函数指针，它指向所有返回类型为int，并带有一个int参数的函数，注意括号是一定要有的，否则上述定义就变成了声明一个函数`f`，其返回类型是int *，带有一个int参数

**赋值方法：**

```c++
f = &func; //指针名 = &函数名
f = func; //指针名 = 函数名
```

将`func`函数的首地址赋值给函数指针，赋值时函数不带括号，也不带参数，**函数名就代表了函数的首地址**。

**调用方法：**

```c++
#include <iostream>
using namespace std;
int Mmin(int x,int y){
  if(x < y)
    return x;
  return y;
}
int Mmax(int x,int y){
  if(x > y)
    return x;
  return y;
}
int main(){
  int (*f)(int x，int y);
  int a=l0 , b = 20;
  f = Mmin; //把Mmin函数的入口地址赋给f
  cout << (*f)(a,b) << endl; //10
  f = Mmax; //把Mmax函数的入口地址赋给f
  cout << (*f)(a,b) << endl; //20
  return 0;
}
```

有了指向函数的指针变量后，就可以实现用该指针变量使用相同参数调用不同函数了。

### 6. 引用和指针的区别

- **指针有内存分配，而引用只是一个别名：** 指针是一个变量，**存储的是一个地址**，引用跟原来的变量是同一个东西，**是原变量的别名**，引用声明时必须初始化，从而指向一个已经存在的对象。
- **引用可以看做常量指针，指针是一个存储地址的变量：** 指针在运行时**可以改变其所指向的值**，而引用一旦**和某个对象绑定后就不再改变**。这句话可以理解为：指针可以被重新赋值以指向另一个不同的对象，但是引用则总是指向在初始化时被指定的对象，以后不能改变，但是**指定的对象其内容可以改变**。
- **引用创建时必须初始化，且不为空，指针创建时可以为空：** 不存在指向空值的引用这个事实，意味着**使用引用的代码效率比使用指针的要高**。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空。
- **指针和引用的自增运算符意义不同：** 指针是对**内存地址**的自增，引用是对**值**的自增。
- **sizeof的意义不同：** 使用sizeof看一个**指针的大小**是4，而引用则是**被引用对象的大小**。
- **没有引用常量，有指针常量：** 没有`int& const p`，有`int* const p`。**常量指针和常量引用是存在的**，`const int *p`和`cosnt int &p`，都表示指向的对象为常量，常量引用形参的好处：
  - 使用引用作为形参，不会产生新的变量，**减少形参和实参传递的开销**；
  - 使用引用可能会导致实参随着形参的改变而改变，**声明为const之后就会消除这种副作用**。
- **参数传递：** 作为参数传递时，指针是**间接传递**，指针需要被解引用才可以对对象进行操作，而引用是**直接传递**，直接对引用的修改都会改变引用所指向的对象。
- **多级指针，一级引用：** 指针可以有多级指针（**p），而引用只有一级