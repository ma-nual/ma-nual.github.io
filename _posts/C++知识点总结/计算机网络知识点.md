### 七层网络模型

计算机网络体系结构：

![计算机网络结构](/Users/wushengna/manual/img/img-post/计算机网络结构.png)

|    分层    |                             作用                             |                   协议                    |               对应典型设备                |       传输单位        |
| :--------: | :----------------------------------------------------------: | :---------------------------------------: | :---------------------------------------: | :-------------------: |
|   物理层   |                底层数据传输，通过媒介传输比特                |          RJ45、CLOCK、IEEE802.3           |         网线，中继器，集线器，HUB         |       比特 Bit        |
| 数据链路层 | 提供介质访问，链路管理，定义数据的基本格式，如何传输，如何标识 |         PPP、FR、HDLC、VLAN、MAC          |            网卡，网桥，交换机             |       帧 Frame        |
|   网络层   | 寻址和路由选择，定义IP编址，定义路由功能，如不同设备的数据转发 | IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP |                  路由器                   |       包 Packet       |
|   传输层   |    建立主机端到端连接，提供端到端的可靠报文传递和错误恢复    |               TCP、UDP、SPX               |                进程和端口                 |       段Segment       |
|   会话层   |        控制应用程序之间会话能力，建立、管理和终止会话        |          NFS、SQL、NETBIOS、RPC           |     建立会话，如session认证，断点续传     | 会话协议数据单元 SPDU |
|   表示层   |           数据格式表示，对数据进行翻译、加密和压缩           |             JPEG、MPEG、ASII              | 编码方式，如图像编解码，URL字段传输编码等 | 表示协议数据单元 PPDU |
|   应用层   |                   应用软件，提供程序间通信                   |  FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS   |       应用程序，如FTP，SMTP，HTTP等       | 应用协议数据单元 APDU |

七层网络模型是一个标准。

四层网络模型是一个实现的应用模型。

### TCP三次握手与四次挥手和原因

![TCP三次握手和四次挥手](/Users/wushengna/manual/img/img-post/TCP三次握手和四次挥手.png)

**三次握手**

- Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
- Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
- Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

**四次挥手**

由于TCP连接时全双工的，因此每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。

- 数据传输结束后，客户端的应用进程发出FIN报文，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。
- 服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。
- 当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认。
- 客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。

**三次握手原因**

- 解决超时重传导致的重复连接，防止客户端的请求报文在网络滞留，客户端超时重传了请求报文，服务端建立连接，传输数据，释放连接之后，服务器又收到了客户端滞留的请求报文，建立连接一直等待客户端发送数据。
- 两次握手意味着服务端收到SYN报文段后即认为连接已经建立，并为其维护相关系统资源。但客户端在发送SYN报文段后可能由于网络原因服务端的SYN，ACK报文段并没有送达客户端，此时客户端不认为连接已经建立也不会发送数据，服务端则将维护相关系统资源一段比较长的时间，造成浪费。
- TCP是全双工通信，原本的握手模型确实应该像挥手一样进行四次的，但是服务端回复ACK和发送SYN之间并没有联系，所以可以合并为一次发送，故TCP握手只需要三次。

**四次挥手的原因**

- 当客户端确认发送完数据且知道服务器已经接收完了，想要关闭发送数据口（当然确认信号还是可以发），就会发FIN给服务器。
- 服务器收到客户端发送的FIN，表示收到了，就会发送ACK回复。
- 但这时候服务器可能还在发送数据，没有想要关闭数据口的意思，所以服务器的FIN与ACK不是同时发送的，而是等到服务器数据发送完了，才会发送FIN给客户端。
- 客户端收到服务器发来的FIN，知道服务器的数据也发送完了，回复ACK， 客户端等待2MSL以后，没有收到服务器传来的任何消息，知道服务器已经收到自己的ACK了，客户端就关闭链接，服务器也关闭链接（服务器比客户端早关闭）。

**TCP三次握手初始序列号为什么不用固定值**

防止串话，防止上一个连接的分组在本次连接建立后才传来并且在同一个窗口中。

**TCP三次握手第三次发生丢包网络怎么处理**

服务器收到SYN包后发出SYN+ACK数据包，服务器进入SYN_RECV状态。而这个时候客户端发送ACK给服务器失败了，服务器没办法进入ESTABLISH状态，这个时候不论客户端主动发送数据与否，服务器都会有定时器发送第二步SYN+ACK数据包，如果客户端再次发送ACK成功，建立连接。

如果一直不成功，服务器达到重传次数，默认是5次，或者会有超时（大概64s）设置，超时之后会给客户端发RTS报文，进入CLOSED状态，防止SYN洪泛攻击，这个时候客户端应该也会关闭连接。

### 状态转移图

![TCP状态转移图](/Users/wushengna/manual/img/img-post/TCP状态转移图.png)

### TIME_WAIT状态和2MSL时间

- 四次挥手期间，客户端和服务器端都可主动释放连接，谁主动释放，谁将进入TIME_WAIT状态。MSL是报文段最大生存时间，一般为2分钟，2MSL即4分钟。
- 为什么TIME-WAIT状态必须等待2MSL时间
  - **保证最后一次挥手报文能到B，能进行超时重传。**若B收不到A的ACK报文，则B会超时重传FIN+ACK，A会在2MSL时间内收到重传报文段，然后发送ACK，重新启动2MSL计时器。如果立即关闭，那么客户端接收FIN会发送RST报文，服务器以为连接异常了。
  - 保证客户端的ACK报文段在1个MSL中消逝后，服务端超时重传的FIN报文段在1个MSL内发送过来能被客户端接收到。
  - **防止已失效的连接请求报文段出现在本连接中。**TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。

### TCP超时重传

TCP每发送一个报文段，就对这个报文段开启一次计时器设置RTO。只要计时器设置的重传时间到了，但还没有收到确认，就要重传这一报文段，这个就叫作“超时重传”。

不同的网络情况不一样，不可能设置一样的RTO（超时重传时间），实际中RTO是根据网络中的RTT（报文段往返时间）来自适应调整的。

### TCP滑动窗口实现流量控制

- 流量控制是让发送方的发送速率不要太快，要让接收方来得及接收，实现对发送方的流量控制。
- 滑动窗口出现的原因：在确认应答策略中，对每一个发送的数据段，都要给一个ACK确认应答，收到ACK后再发送下一个数据段，TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。发送窗口只有收到对端对于本段发送窗口内字节的ACK确认，才会移动发送窗口的左边界。接收窗口只有在前面所有的段都确认的情况下才会移动左边界;在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认。以此确保对端会对这些数据重传。还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端会向它提醒。这样做有一个比较大的缺点，就是性能比较差，尤其是数据往返的时间长的时候。
- 应用程序在需要（如内存不足）时通过API通知TCP协议械缩小TCP的接收窗口。 然后TCP协议栈在下个时间段发送时包含新的窗口大小通知给对端，对端按通知的窗口来改变发送窗口，以此达到减缓发送速率的目的。
- 滑动窗口以字节为单位，而不是报文。

### TCP拥塞控制

- 慢开始（slow-start），最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，避免cwnd增长过大。
- 拥塞避免（congestion avoidance），每经过一个往返时间RTT，cwnd就增长1。在慢开始和拥塞避免的过程中，一旦发现网络拥塞，就把慢开始门限设为当前值的一半，并且重新设置cwnd为1，重新慢启动（乘法减小，加法增大）。
- 快重传（fast retransmit），接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。
- 快恢复（fast recovery），当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），将当前的cwnd设置为慢开始门限，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。采用快恢复算法时，慢开始只在建立连接和网络超时才使用。

![TCP拥塞控制](/Users/wushengna/manual/img/img-post/TCP拥塞控制.png)

![快重传](/Users/wushengna/manual/img/img-post/快重传.png)

![TCP拥塞控制流程图](/Users/wushengna/manual/img/img-post/TCP拥塞控制流程图.png)

**达到什么情况的时候开始减慢增长的速度**

采用慢开始和拥塞避免算法的时候

- 一旦**cwnd>慢开始门限**，就采用拥塞避免算法，减慢增长速度。

- 一旦**出现丢包的情况**，就重新进行慢开始，减慢增长速度。

采用快恢复和快重传算法的时候

- 一旦**cwnd>慢开始门限**，就采用拥塞避免算法，减慢增长速度。

- 一旦**发送方连续收到了三个重复确认**，就采用拥塞避免算法，减慢增长速度。

### 流量控制和拥塞控制的区别

- 流量控制是**点对点通信量的控制**，是一个端到端的问题，主要就是**抑制发送端发送数据的速率，以便接收端来得及接收**。
- 拥塞控制是**防止过多的数据注入到网络中，可以使网络中的路由器或链路不致过载**，是一个全局性的过程。

### TCP网络编程步骤

![TCP网络编程步骤](/Users/wushengna/manual/img/img-post/TCP网络编程步骤.png)

- 服务端：socket -> bind -> listen -> accept -> recv/send -> close
  - 创建一个socket，用函数socket()，设置SOCK_STREAM
  - 设置服务器地址和侦听端口，初始化要绑定的网络地址结构
  - 绑定服务器端IP地址、端口等信息到socket上，用函数bind()
  - 设置允许的最大连接数，用函数listen()
  - 接收客户端上来的连接，用函数accept()
  - 收发数据，用函数send()和recv()，或者read()和write()
  - 关闭网络连接close()，需要关闭服务端sock和accept产生的客户端sock文件描述符
- 客户端：socket -> connect -> send/recv -> close
  - 创建一个socket，用函数socket()
  - 设置要连接的对方的IP地址和端口等属性
  - 连接服务器，用函数connect()
  - 收发数据，用函数send()和recv()，或read()和write()
  - 关闭网络连接close()
- 注意
  - INADDR_ANY表示本机任意地址，一般服务器端都可以这样写
  - accept中接收的是客户端的地址，返回对应当前客户端的一个clisock文件描述符，表示当前客户端的tcp连接
  - send和recv中接收的是新建立的客户端的sock地址

### TCP网络编程API

- `int socket(int domain, int type, int protocol);`
  - domain：协议族，如IPV4，IPV6等。
  - type：socket类型，如SOCK_STREAM（流式套接字TCP）、SOCK_DGRAM（数据报式套接字UDP）。
  - protocol：协议类型。

- `int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`
  - sockfd：需要绑定端口号和ip的套接字。
  - addr：指向要绑定给sockfd的协议地址。
- `int listen(int sockfd, int backlog);`
  - sockfd：用于监听的套接字；
  - backlog：新连接等待队列的长度。

- `int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);`
  - sockfd：用于监听的套接字。
  - addr：对端的协议地址。
- `ssize_t read(int fd, void *buf, size_t count);`
  - read 函数是负责从 fd 中读取内容。
  - 当读成功时，read 返回实际所读的字节数。
  - 如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。
  - 如果错误为 EINTR 说明读是由中断引起的；如果是 ECONNREST 表示网络连接出了问题。
- `ssize_t write(int fd, const void *buf, size_t count);`
  - write 函数将 buf 中的 nbytes 字节内容写入文件描述符 fd。
  - 成功时返回写的字节数。失败时返回 -1，并设置 errno 变量。
  - 在网络程序中，当我们向套接字文件描述符写时有俩种可能。
    - write 的返回值大于 0，表示写了部分或者是全部的数据。
    - 返回的值小于 0，此时出现了错误。
  - 如果错误为 EINTR 表示在写的时候出现了中断错误；如果为 EPIPE 表示网络连接出现了问题（对方已经关闭了连接）。