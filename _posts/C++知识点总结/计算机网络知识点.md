### 七层网络模型

计算机网络体系结构：

![计算机网络结构](/Users/wushengna/manual/img/img-post/计算机网络结构.png)

|    分层    |                             作用                             |                   协议                    |               对应典型设备                |       传输单位        |
| :--------: | :----------------------------------------------------------: | :---------------------------------------: | :---------------------------------------: | :-------------------: |
|   物理层   |                底层数据传输，通过媒介传输比特                |          RJ45、CLOCK、IEEE802.3           |         网线，中继器，集线器，HUB         |       比特 Bit        |
| 数据链路层 | 提供介质访问，链路管理，定义数据的基本格式，如何传输，如何标识 |         PPP、FR、HDLC、VLAN、MAC          |            网卡，网桥，交换机             |       帧 Frame        |
|   网络层   | 寻址和路由选择，定义IP编址，定义路由功能，如不同设备的数据转发 | IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP |                  路由器                   |       包 Packet       |
|   传输层   |    建立主机端到端连接，提供端到端的可靠报文传递和错误恢复    |               TCP、UDP、SPX               |                进程和端口                 |       段Segment       |
|   会话层   |        控制应用程序之间会话能力，建立、管理和终止会话        |          NFS、SQL、NETBIOS、RPC           |     建立会话，如session认证，断点续传     | 会话协议数据单元 SPDU |
|   表示层   |           数据格式表示，对数据进行翻译、加密和压缩           |             JPEG、MPEG、ASII              | 编码方式，如图像编解码，URL字段传输编码等 | 表示协议数据单元 PPDU |
|   应用层   |                   应用软件，提供程序间通信                   |  FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS   |       应用程序，如FTP，SMTP，HTTP等       | 应用协议数据单元 APDU |

七层网络模型是一个标准。

四层网络模型是一个实现的应用模型。

### TCP三次握手与四次挥手和原因

![TCP三次握手和四次挥手](/Users/wushengna/manual/img/img-post/TCP三次握手和四次挥手.png)

**三次握手**

- Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
- Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
- Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

**四次挥手**

由于TCP连接时全双工的，因此每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。

- 数据传输结束后，客户端的应用进程发出FIN报文，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。
- 服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。
- 当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认。
- 客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。

**三次握手原因**

- 解决超时重传导致的重复连接，防止客户端的请求报文在网络滞留，客户端超时重传了请求报文，服务端建立连接，传输数据，释放连接之后，服务器又收到了客户端滞留的请求报文，建立连接一直等待客户端发送数据。
- 两次握手意味着服务端收到SYN报文段后即认为连接已经建立，并为其维护相关系统资源。但客户端在发送SYN报文段后可能由于网络原因服务端的SYN，ACK报文段并没有送达客户端，此时客户端不认为连接已经建立也不会发送数据，服务端则将维护相关系统资源一段比较长的时间，造成浪费。
- TCP是全双工通信，原本的握手模型确实应该像挥手一样进行四次的，但是服务端回复ACK和发送SYN之间并没有联系，所以可以合并为一次发送，故TCP握手只需要三次。

**四次挥手的原因**

- 当客户端确认发送完数据且知道服务器已经接收完了，想要关闭发送数据口（当然确认信号还是可以发），就会发FIN给服务器。
- 服务器收到客户端发送的FIN，表示收到了，就会发送ACK回复。
- 但这时候服务器可能还在发送数据，没有想要关闭数据口的意思，所以服务器的FIN与ACK不是同时发送的，而是等到服务器数据发送完了，才会发送FIN给客户端。
- 客户端收到服务器发来的FIN，知道服务器的数据也发送完了，回复ACK， 客户端等待2MSL以后，没有收到服务器传来的任何消息，知道服务器已经收到自己的ACK了，客户端就关闭链接，服务器也关闭链接（服务器比客户端早关闭）。

**TCP三次握手初始序列号为什么不用固定值**

防止串话，防止上一个连接的分组在本次连接建立后才传来并且在同一个窗口中。

**TCP三次握手第三次发生丢包网络怎么处理**

服务器收到SYN包后发出SYN+ACK数据包，服务器进入SYN_RECV状态。而这个时候客户端发送ACK给服务器失败了，服务器没办法进入ESTABLISH状态，这个时候不论客户端主动发送数据与否，服务器都会有定时器发送第二步SYN+ACK数据包，如果客户端再次发送ACK成功，建立连接。

如果一直不成功，服务器达到重传次数，默认是5次，或者会有超时（大概64s）设置，超时之后会给客户端发RTS报文，进入CLOSED状态，防止SYN洪泛攻击，这个时候客户端应该也会关闭连接。

### 状态转移图

![TCP状态转移图](/Users/wushengna/manual/img/img-post/TCP状态转移图.png)

### TIME_WAIT状态和2MSL时间

- 四次挥手期间，客户端和服务器端都可主动释放连接，谁主动释放，谁将进入TIME_WAIT状态。MSL是报文段最大生存时间，一般为2分钟，2MSL即4分钟。
- 为什么TIME-WAIT状态必须等待2MSL时间
  - **保证最后一次挥手报文能到B，能进行超时重传。**若B收不到A的ACK报文，则B会超时重传FIN+ACK，A会在2MSL时间内收到重传报文段，然后发送ACK，重新启动2MSL计时器。如果立即关闭，那么客户端接收FIN会发送RST报文，服务器以为连接异常了。
  - 保证客户端的ACK报文段在1个MSL中消逝后，服务端超时重传的FIN报文段在1个MSL内发送过来能被客户端接收到。
  - **防止已失效的连接请求报文段出现在本连接中。**TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。

### TCP超时重传

TCP每发送一个报文段，就对这个报文段开启一次计时器设置RTO。只要计时器设置的重传时间到了，但还没有收到确认，就要重传这一报文段，这个就叫作“超时重传”。

不同的网络情况不一样，不可能设置一样的RTO（超时重传时间），实际中RTO是根据网络中的RTT（报文段往返时间）来自适应调整的。

### TCP滑动窗口实现流量控制

- 流量控制是让发送方的发送速率不要太快，要让接收方来得及接收，实现对发送方的流量控制。
- 滑动窗口出现的原因：在确认应答策略中，对每一个发送的数据段，都要给一个ACK确认应答，收到ACK后再发送下一个数据段，TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。发送窗口只有收到对端对于本段发送窗口内字节的ACK确认，才会移动发送窗口的左边界。接收窗口只有在前面所有的段都确认的情况下才会移动左边界;在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认。以此确保对端会对这些数据重传。还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端会向它提醒。这样做有一个比较大的缺点，就是性能比较差，尤其是数据往返的时间长的时候。
- 应用程序在需要（如内存不足）时通过API通知TCP协议械缩小TCP的接收窗口。 然后TCP协议栈在下个时间段发送时包含新的窗口大小通知给对端，对端按通知的窗口来改变发送窗口，以此达到减缓发送速率的目的。
- 滑动窗口以字节为单位，而不是报文。

### TCP拥塞控制

- 慢开始（slow-start），最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，避免cwnd增长过大。
- 拥塞避免（congestion avoidance），每经过一个往返时间RTT，cwnd就增长1。在慢开始和拥塞避免的过程中，一旦发现网络拥塞，就把慢开始门限设为当前值的一半，并且重新设置cwnd为1，重新慢启动（乘法减小，加法增大）。
- 快重传（fast retransmit），接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。
- 快恢复（fast recovery），当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），将当前的cwnd设置为慢开始门限，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。采用快恢复算法时，慢开始只在建立连接和网络超时才使用。

![TCP拥塞控制](/Users/wushengna/manual/img/img-post/TCP拥塞控制.png)

![快重传](/Users/wushengna/manual/img/img-post/快重传.png)

![TCP拥塞控制流程图](/Users/wushengna/manual/img/img-post/TCP拥塞控制流程图.png)

**达到什么情况的时候开始减慢增长的速度**

采用慢开始和拥塞避免算法的时候

- 一旦**cwnd>慢开始门限**，就采用拥塞避免算法，减慢增长速度。

- 一旦**出现丢包的情况**，就重新进行慢开始，减慢增长速度。

采用快恢复和快重传算法的时候

- 一旦**cwnd>慢开始门限**，就采用拥塞避免算法，减慢增长速度。

- 一旦**发送方连续收到了三个重复确认**，就采用拥塞避免算法，减慢增长速度。

### 流量控制和拥塞控制的区别

- 流量控制是**点对点通信量的控制**，是一个端到端的问题，主要就是**抑制发送端发送数据的速率，以便接收端来得及接收**。
- 拥塞控制是**防止过多的数据注入到网络中，可以使网络中的路由器或链路不致过载**，是一个全局性的过程。

### TCP网络编程步骤

![TCP网络编程步骤](/Users/wushengna/manual/img/img-post/TCP网络编程步骤.png)

- 服务端：socket -> bind -> listen -> accept -> recv/send -> close
  - 创建一个socket，用函数socket()，设置SOCK_STREAM
  - 设置服务器地址和侦听端口，初始化要绑定的网络地址结构
  - 绑定服务器端IP地址、端口等信息到socket上，用函数bind()
  - 设置允许的最大连接数，用函数listen()
  - 接收客户端上来的连接，用函数accept()
  - 收发数据，用函数send()和recv()，或者read()和write()
  - 关闭网络连接close()，需要关闭服务端sock和accept产生的客户端sock文件描述符
- 客户端：socket -> connect -> send/recv -> close
  - 创建一个socket，用函数socket()
  - 设置要连接的对方的IP地址和端口等属性
  - 连接服务器，用函数connect()
  - 收发数据，用函数send()和recv()，或read()和write()
  - 关闭网络连接close()
- 注意
  - INADDR_ANY表示本机任意地址，一般服务器端都可以这样写
  - accept中接收的是客户端的地址，返回对应当前客户端的一个clisock文件描述符，表示当前客户端的tcp连接
  - send和recv中接收的是新建立的客户端的sock地址

### TCP网络编程API

- `int socket(int domain, int type, int protocol);`
  - domain：协议族，如IPV4，IPV6等。
  - type：socket类型，如SOCK_STREAM（流式套接字TCP）、SOCK_DGRAM（数据报式套接字UDP）。
  - protocol：协议类型。

- `int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`
  - sockfd：需要绑定端口号和ip的套接字。
  - addr：指向要绑定给sockfd的协议地址。
- `int listen(int sockfd, int backlog);`
  - sockfd：用于监听的套接字；
  - backlog：新连接等待队列的长度。

- `int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);`
  - sockfd：用于监听的套接字。
  - addr：对端的协议地址。
- `ssize_t read(int fd, void *buf, size_t count);`
  - read 函数是负责从 fd 中读取内容。
  - 当读成功时，read 返回实际所读的字节数。
  - 如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。
  - 如果错误为 EINTR 说明读是由中断引起的；如果是 ECONNREST 表示网络连接出了问题。
- `ssize_t write(int fd, const void *buf, size_t count);`
  - write 函数将 buf 中的 nbytes 字节内容写入文件描述符 fd。
  - 成功时返回写的字节数。失败时返回 -1，并设置 errno 变量。
  - 在网络程序中，当我们向套接字文件描述符写时有俩种可能。
    - write 的返回值大于 0，表示写了部分或者是全部的数据。
    - 返回的值小于 0，此时出现了错误。
  - 如果错误为 EINTR 表示在写的时候出现了中断错误；如果为 EPIPE 表示网络连接出现了问题（对方已经关闭了连接）。

### TCP协议选项

- SO_REUSEADDR：一般来说一个端口释放后会等待两分钟左右后才能再被使用，而使用 SO_REUSEADDR 则可以让端口释放后立即就可以被再次使用。SO_REUSEADDR 用于对 TCP 套接字处于 TIME_WAIT 状态下的 socket，才可以 重复绑定使用 。

- TCP_NODELAY/TCP_CORK：TCP_NODELAY 不使用 Nagle算法，不会将小包进行拼接成大包再进行发送，而是直接将小包发送出去，这会使得用户体验要好。当在传送大量数据的时候，为了提高TCP发送效率，可以设置TCP_CORK，当设置了TCP_CORK后，会有 200ms 阻塞，当阻塞时间过后，数据就会自动传送。

  - Nagle算法：如果发送端欲多次发送包含少量字符的数据包（一般情况下，后面统一称长度小于 MSS 的数据包为小包;与此相对，称长度等于 MSS 的数据包为大包;为了某些对比说明，还有中包，即长度比小包长，但又不足一个 MSS 的包），则发送端会先将第一个小包发送出去，而将后面到达的少量字符数据都缓存起来而不立即发送，直到收到接收端对前一个数据包报文段的 ACK 确认为止，或当前字符属于紧急数据，或者积攒到了一定数量的数据（比如缓存的字符数据已经达到数据包报文段的最大长度）等多种情况才将其组成一个较大的数据包发送出去。

- SO_LINGER：SO_LINGER可以改变close的行为。

  ```c++
  struct linger{
    int l_onoff;
    int l_linger;
  };
  ```
  - l_onoff设置为0，选项被关闭。l_linger值被忽略，就是上面的默认情形，close立即返回。
  - l_onoff设置为非 0，l_linger被设置为 0，则 close()不被阻塞立即执行，丢弃socket发送缓冲区中的数据，并向对端发送一个RST报文。这种关闭方式称为“强制”或“失效”关闭。这种方式，是用非正常的4种握手方式结束 TCP 的连接，所以，TCP连接将不会进入 TIME_WAIT 状态，这样会导致新建立的可能和已经连接的数据造成泪乱。
  - l_onoff设置为非0，l_linger被设置为非0，则close()调用阻塞进程，直到所剩数据发送完毕或超时。这种关闭称为**“优雅地”关闭**，在这种情况下，close的返回得到延迟。调用close()去关闭socket的时候，内核将会延迟。即如果send buffer中还有数据尚未发送，该进程将会被休眠直到以下任何一种情况发生：
    - send buffer中的所有数据都被发送并且得到对方 TCP 的应答消息（这种应答并不是意味着对方应用程序已经接收到数据）;
    - 延迟时间消耗完，在延迟时间被消耗完之后，send buffer中的所有数据都将会被丢弃。
    - 上面两种情况中，如果socket被设置为O_NONBLOCK状态，程序将不会等待close返回，send buffer中的所有数据都将会被丢弃。所以需要判断close的返回值。在send buffer中的所有数据都被发送之前并且延迟时间没有消耗完，close返回的话，close将会返回一个EWOULDBLOCK的提示。

- TCP_DEFER_ACCEPT：当接收到第一个数据之后，才会创建连接，可以用来防御空连接攻击（只是建立连接，但是不发送任何数据）。注意如果打开这个功能，kernel在val时间之内还没有收到数据，不会继续唤醒进程，而是直接丢弃连接。如果服务器设置 TCP_DEFER_ACCEPT 选项后，服务器受到一个 CONNECT 请求并进行了 3 次握手之后，新的socket状态依然为SYN_RECV，而不是ESTABLISHED，操作系统不会接收数据。

- SO_KEEPALIVE：SO_KEEPALIVE用于保持连接检测对方主机是否崩溃，避免（服务器）永远阻塞于TCP连接的输入。

  - 设置该选项后，如果2h内在此套接口的任一方向都没有数据交换，TCP就自动给对方发一个保持存活探测分节。这是一个对方必须响应的TCP分节。
    - 对方接收一切正常：以期望的ACK响应，2h后，TCP将发出另一个探测分节。
    - 对方已崩溃且已重新启动：以RST响应。套接口的待处理错误被置为ECONNR­-ESET，套接口本身则被关闭。
    - 对方无任何响应：源自 berkeley 的 TCP 发送另外8个探测分节，相隔75s一个，试图得到一个响应。在发出第一个探测分节11min 15s后若仍无响应就放弃。套接口的待处理错误被置为ETIMEOUT，套接口本身则被关闭。

- SO_SNDTIMEO/SO_RCVTIMEO：SO_SNDTIMEO和SO_RCVTIMEO两项分别设置socket的发送和接收超时时间，它们都接收一个timeval结构作为参数，当timeval结构为0时，表示选项无效。

- SO_RCVBUF/SO_SNDBUF：每个TCP套接字都有一个发送缓冲区和一个接收缓冲区，每个UDP套接字都有一个接收缓冲区。使用SO_RCVBUF和SO_SNDBUF可以改变默认缓冲区大小。

### 粘包的原因和解决方法

**粘包**是如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送；

**拆包**是如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，也就是将一个大的包拆分为多个小包进行发送。

**封包**是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了，包头其实上是个大小固定的结构体。根据固定的包头长度以及包头中含有的包体长度的变量值就能正确的拆分出一个完整的数据包。

#### 粘包的原因

- 由Nagle算法造成的发送端的粘包。
- 接收端接收不及时造成的接收端粘包。

#### 粘包的解决方法

- 使用封包，在发送的内容前加上发送内容的长度，对方会先收4Byte，解析获得接下来需要接收的长度，再进行收包。

### HTTP协议

#### 概述

- HTTP协议是**超文本传输协议**的缩写，是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。
- HTTP属于应用层协议，基于TCP/IP通信协议来传递数据。

#### 特点

- 灵活
  - HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
- 无连接
  - 无连接的含义是通信双方在交换HTTP报文之前不需要建立HTTP连接。
- 无状态
  - 无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时应答较快。
- 支持B/S和C/S模式
- 默认端口80
- 基于TCP协议

#### HTTP工作原理

HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。

- 客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。
- 服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

**HTTP 请求/响应的步骤**

- **客户端连接到Web服务器** 一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，[http://www.oakcms.cn。](http://www.oakcms.cn./)

- **发送HTTP请求** 通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。

- **服务器接受请求并返回HTTP响应** Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。

- **释放连接TCP连接** 若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;

- **客户端浏览器解析HTML内容** 客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

### HTTP协议请求报文具体信息

HTTP请求报文由请求行（request line），请求头部（header），空行和请求数据四个部分组成。

- **GET**

  ```
  GET /562f25980001b1b106000338.jpg HTTP/1.1
  Host:img.mukewang.com
  User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64)
  AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36
  Accept:image/webp,image/*,*/*;q=0.8
  Referer:http://www.imooc.com/
  Accept-Encoding:gzip, deflate, sdch
  Accept-Language:zh-CN,zh;q=0.8
  空行
  请求数据为空
  ```

- **POST**

  ```
  POST / HTTP1.1
  Host:www.wrox.com
  User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
  Content-Type:application/x-www-form-urlencoded
  Content-Length:40
  Connection: Keep-Alive
  空行
  name=Professional%20Ajax&publisher=Wiley
  ```

- **请求行：**用来说明请求类型,要访问的资源以及所使用的HTTP版本。GET说明请求类型为GET，/562f25980001b1b106000338.jpg(URL)为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。

- **请求头部：**紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息HOST，给出请求资源所在服务器的域名。User-Agent，HTTP客户端程序的信息，该信息由你发出请求使用的浏览器来定义，并且在每个请求中自动发送等。Accept，说明用户代理可处理的媒体类型。Accept-Encoding，说明用户代理支持的内容编码。Accept-Language，说明用户代理能够处理的自然语言集。Content-Type，说明实现主体的媒体类型。Content-Length，说明实现主体的大小。Connection，连接管理，可以是Keep-Alive或close。

- **空行：**请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。

- **请求数据：**也叫主体，可以添加任意的其他数据。

### GET和POST区别

- **get参数通过url传递，post放在request body中**，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变。
- **POST的安全性要比GET的安全性高**，一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。
- **get请求在url中传递的参数是有长度限制的，而post没有**。
- **GET产生一个TCP数据包，POST产生两个TCP数据包**。
  - 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
  - 对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

### HTTP协议响应报文具体信息

HTTP响应也由四个部分组成，分别是：状态行，消息报头，空行和响应正文。

```
HTTP/1.1 200 OK
Date: Fri, 22 May 2009 06:07:21 GMT
Content-Type: text/html; charset=UTF-8
<html>
      <head></head>
      <body>
            <!--body goes here-->
      </body>
</html>
```

- **状态行：**由HTTP协议版本号，状态码，状态消息三部分组成。第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为OK。

- **消息报头：**用来说明客户端要使用的一些附加信息第二行和第三行为消息报头，Date：生成响应的日期和时间；Content-Type：指定了MIME类型的HTML(text/html)，编码类型是UTF-8。

- **空行：**消息报头后面的空行是必须的。

- **响应正文：**服务器返回给客户端的文本信息，空行后面的html部分为响应正文。

### HTTP状态码

- 1xx：指示信息--表示请求已接收，继续处理。
- 2xx：成功--表示请求正常处理完毕。
  - 200 OK：客户端请求被正常处理。
  - 206 Partial content：客户端进行了范围请求。
- 3xx：重定向--要完成请求必须进行更进一步的操作。
  - 301 Moved Permanently：永久重定向，该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。
  - 302 Found：临时重定向，请求的资源现在临时从不同的URI中获得。
- 4xx：客户端错误--请求有语法错误，服务器无法处理请求。
  - 400 Bad Request：请求报文存在语法错误。
  - 403 Forbidden：请求被服务器拒绝。
  - 404 Not Found：请求不存在，服务器上找不到请求的资源。
- 5xx：服务器端错误--服务器处理请求出错。
  - 500 Internal Server Error：服务器在执行请求时出现错误。
  - 503 Service Unavaliable：服务器正在停机维护。

### HTTP和HTTPS的区别

- HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性。
- HTTPS可以保证报文完整性，另外可以核实发送者身份。
- HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书。
- HTTPS在TCP三次握手阶段之后，还需要进行SSL的handshake，协商加密使用的对称加密密钥。
- HTTP协议端口是80，HTTPS协议端口是443。

### 中间人攻击

请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击(MITM)，即指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。

#### 分类

**HTTP协议**内容是明文传输的，没有经过任何加密，而这些明文数据会经过WiFi、路由器、运营商、机房等多个物理设备节点，如果在这中间任意一个节点被监听，传输的内容就会完全暴露，即被中间人攻击。

**ARP协议**的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的进行。ARP攻击也是一种中间人攻击，他通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断，但是ARP攻击仅能在以太网进行，无法对外网进行攻击。

**针对SSL的中间人攻击方式**主要有两类，分别是SSL劫持攻击和SSL剥离攻击。SSL劫持攻击即SSL证书欺骗攻击，攻击者为了获得HTTPS传输的明文数据，需要先将自己接入到客户端和目标网站之间，在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥，这样，中间人就可以得到明文传输带Key1、Key2和Pre-Master-Key，从而窃取客户端和服务端的通信数据。SSL剥离攻击也需要将攻击者设置为中间人，之后见HTTPS范文替换为HTTP返回给浏览器，而中间人和服务器之间仍然保持HTTPS服务器，由于HTTP是明文传输的，所以中间人可以获取客户端和服务器传输数据。

#### 攻击过程

HTTPS协议被中间人攻击的过程如图1所示，中间人截取客户端发送给服务器的请求，然后伪装成客户端与服务器进行通信，将服务器返回给客户端的内容发送给客户端，伪装成服务器与客户端进行通信，通过这样的手段，便可以获取客户端和服务器之间通信的所有内容。使用中间人攻击手段，必须要让客户端信任中间人的证书，如果客户端不信任，则这种攻击手段也无法发挥作用。

![中间人攻击](/Users/wushengna/manual/img/img-post/中间人攻击.png)

1. 客户端发送请求到服务端，请求被中间人截获。

2. 服务器向客户端发送公钥。

3. 中间人截获公钥，保留在自己手上，然后自己生成一个【伪造的】公钥，发给客户端。

4. 客户端收到伪造的公钥后，生成加密hash值发给服务器。

5. 中间人获得加密hash值，用自己的私钥解密获得真秘钥，同时生成假的加密hash值，发给服务器。

6. 服务器用私钥解密获得假密钥，然后加密数据传输给客户端。

#### 解决方法

使用HTTPS协议，SSL/TLS协议加密传输，数字签名和数字证书（CA）。

HTTPS协议其实就是将HTTP协议的数据包再通过SSL/TLS加密后传输，SSL协议位于TCP/IP协议与各种应用协议之间，是一种国际标准的加密及身份认证通信协议。HTTPS协议为了兼顾性能和安全性，使用了**非对称加密+对称加密**的方案，为了保证公钥传输中不被篡改，又使用了非对称加密的数字签名功能，借助CA机构和系统根证书的机制保证了HTTPS证书的公信力。

#### SSL协议特点

1. SSL协议可用于保护正常运行与TCP之上的任何应用协议，如HTTP、FTP、SMTP或Telent的通信，最常见的是用户SSL来保护HTTP通信。

2. SSL协议的优点在于它是应用层协议无关的，高层的应用协议能透明的建立于SSL协议之上。

3. SSL协议的应用层协议之前就完成加密算法、通信密钥的协商以及服务器的认证工作，在此之后应用层协议所传送的数据都会被加密，从而保证通信的安全性。

4. SSL协议使用通信双方的客户证书以及CA根证书，允许客户/服务器应用以一种不能被偷听的方式通信，在通信双方建立起了一条安全的、可信任的通信通道。

5. 该协议使用密钥对传送数据加密，许多网站都是通过这种协议从客户端接收信用卡编号等保密信息，常用于交易过程。

#### 对称加密与非对称加密

对称加密是指有一个密钥，用它可以对一段明文加密，加密之后也只能用这个密钥来解密得到明文，如AES对称加密算法。

非对称加密有两个密钥，一个是公钥，另一个是私钥。一般来说，公钥用来加密，这时密文只能用私钥才能解开，如RSA密钥协商算法。

非对称加解密耗时要远大于对称加解密，我们才最终选用了上文介绍到非对称加密+对称加密的方案。

#### CA颁发机构

为了解决**客户端无法确认收到的公钥是不是真的是服务端发来的**，服务端在使用HTTPS前，去经过认证的CA机构申请颁发一份**数字证书**，数字证书里包含有证书持有者、证书有效期、公钥等信息，服务端将证书发送给客户端，客户端校验证书身份和要访问的网站身份确实一致后再进行后续的加密操作。

私钥除了**解密**外的真正用途其实还有一个，就是**数字签名**，其实就是一种防伪技术，只要有人篡改了证书，那么数字签名必然校验失败。

1. CA机构拥有自己的一对公钥和私钥。
2. CA机构在颁发证书时对证书明文信息进行哈希。
3. 将哈希值用私钥进行**加签**，得到数字签名。

**签名过程**

1. 明文数据和数字签名组成证书，传递给客户端。
2. 客户端得到证书，分解成明文部分Text和数字签名Sig1。
3. 用CA机构的公钥进行**解签**，得到Sig2（由于CA机构是一种公信身份，因此在系统或浏览器中会内置CA机构的证书和公钥信息）。
4. 用证书里声明的哈希算法对明文Text部分进行哈希得到H。
5. 当自己计算得到的哈希值H与**解签**后的Sig2**相等**，表示证书可信，**没有被篡改**。

#### HTTPS实现原理

HTTPS的加解密流程(非对称加密+对称加密)。

1. 用户在浏览器发起HTTPS请求（如 https://www.mogu.com/），默认使用服务端的443端口进行连接；
2. HTTPS需要使用一套**CA数字证书**，证书内会附带一个**公钥Pub**，而与之对应的**私钥Private**保留在服务端不公开；
3. 服务端收到请求，返回配置好的包含**公钥Pub**的证书给客户端；
4. 客户端收到**证书**，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续；
5. 客户端生成一个用于对称加密的**随机Key**，并用证书内的**公钥Pub**进行加密，发送给服务端；
6. 服务端收到**随机Key**的密文，使用与**公钥Pub**配对的**私钥Private**进行解密，得到客户端真正想发送的**随机Key**；
7. 服务端使用客户端发送过来的**随机Key**对要传输的HTTP数据进行对称加密，将密文返回客户端；
8. 客户端使用**随机Key**对称解密密文，得到HTTP数据明文；
9. 后续HTTPS请求使用之前交换好的**随机Key**进行对称加解密。

![https](/Users/wushengna/manual/img/img-post/https.png)

### cookie和session的区别

HTTP协议作为无状态协议，每次request请求之前是相互独立的，当前请求并不会记录它的上一次请求信息，使用两种方式将上下文请求进行关联，**客户端（不同的浏览器）记录用户的状态通过cookie，服务器端（不同的网站）记录用户的状态通过session。**

#### cookie

##### 工作流程

- 客户端请求服务器端，服务器端产生cookie响应头，随响应报文发送给客户端，客户端将cookie文本保存起来。
- 下次客户端再次请求服务端时，会产生cookie请求头，将之前服务器发送的cookie信息，再发送给服务器，服务器就可以根据cookie信息跟踪客户端的状态。

##### 基础知识

Cookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie，它是服务器端存放在本地机器中的数据，随每一个请求发送给服务器，Cookie具有不可跨域名性，Cookie在客户端是由浏览器来管理的，浏览器判断一个网站是否能操作另一个网站Cookie的依据是域名，由于Cookie在客户端，所以可以编辑伪造，不是十分安全。

- 非持久cookie
  - 内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。
- 持久cookie
  - 硬盘Cookie保存在硬盘里，有一个过期时间（客户端cookie设置的时间），除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。

#### session

##### 工作流程

- 当用户第一次访问站点时，服务器端为用户创建一个sessionID，这就是针对这个用户的唯一标识，每一个访问的用户都会得到一个自己独有的session ID，这个session ID会存放在响应头里的cookie中，之后发送给客户端。这样客户端就会拥有一个该站点给他的session ID。
- 当用户第二次访问该站点时，浏览器会带着本地存放的cookie（里面存有上次得到的session ID）随着请求一起发送到服务器，服务端接到请求后会检测是否有session ID，如果有就会找到响应的session文件，把其中的信息读取出来；如果没有就跟第一次一样再创建个新的。

##### 基础知识

session是存放在服务器里的，所以session里的东西不断增加会增加服务器的负担，我们会把一些重要的东西放在session里，不太重要的放在客户端cookie里。

- session失效
  - 服务器（非正常）关闭时。
  - session过期/失效（默认30分钟）。
    - 问题：时间的起算点从何时开始计算30分钟：从不操作服务器端的资源开始计时（例如：当你访问淘宝页面时，点开页面不动，第29分钟再动一下页面，就得重新计时30分钟；当过了30分钟，就失效了。）
  - 手动销毁session。
- sessionID的传递方式
  - 通过cookie传递。
  - 当cookie禁用后，可以通过url传递。
- 不同场景下的session
  - 当在同一个浏览器中同时打开多个标签，发送同一个请求或不同的请求，仍是同一个session;
  - 当不在同一个窗口中打开相同的浏览器时（打开多个相同的浏览器），发送请求，仍是同一个session;
  - 当使用不同的浏览器时，发送请求，即使发送相同的请求，是不同的session;
  - 当把当前某个浏览器的窗口全关闭，再打开，发起相同的请求时，是不同的session。

### 区别

- cookie数据存放在客户的浏览器上，session数据放在服务器上。
- cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。
- session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。
- 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
- 可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。

### HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗

显然每次请求都经历一次密钥传输过程非常耗时，用session就能达到只传输一次。

- 服务器会为每个浏览器（或客户端软件）维护一个session ID，在TSL握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下。
- 之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！

### 浏览器关闭之后，session就销毁了吗

浏览器关闭和服务器session销毁没有任何关系，会话Cookie（非持久cookie）在关闭浏览器后就会消失，但是原来服务器的Session还在，只有等到了销毁的时间会自动销毁。