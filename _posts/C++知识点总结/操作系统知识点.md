### 程序局部性原理

- **时间局部性**
  - 如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问（因为程序中存在大量的循环）。
- **空间局部性**
  - 一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）。

#### 从硬件和操作系统层面看如何利用局部性

- **硬件层**
  - 局部性原理允许硬件引入**高速缓存存储器**这种小而快速的存储器来存储最近被引用的指令和数据，从而提高对主存的访问速度。
- **操作系统**
  - 允许系统使用主存作为虚拟地址空间作为最近被引用块的高速缓存，**快表**就是将近期常访问的页表项副本放到更高速的联想寄存器中。

#### 从存储结构看如何利用局部性

![存储器层次结构](/Users/wushengna/manual/img/img-post/存储器层次结构.png)

存储器层次结构的中心思想是，对于每个 k，位于 k 层的更快更小的存储设备作为位于 k + 1 层的更大更慢的存储设备的缓存。

- **时间局部性**
  - 同一数据对象可能被多次使用。一旦一个数据对象在第一次被命中时被复制到缓存中，我们就会期望后面对目标有一系列的访问命中，因为缓存比低一层的存储设备更快。
- **空间局部性**
  - 块通常包含多个数据对象。我们会期望后面对该块中其他对象的访问能补偿不命中后复制该块的花费。

### 库函数和系统调用的区别

- **库函数调用**是**语言或应用程序**的一部分，而**系统调用**是**操作系统**的一部分，跨平台技术的原理就是通过库函数实现的，**库函数可以理解为是对系统调用的一层封装，但库函数不是必须包含系统调用**。
- 库函数有可能包含有一个系统调用，有可能有好几个系统调用，当然也有可能没有系统调用，比如有些操作不需要涉及内核的功能。

#### 区别

- 所有 C 函数库是相同的，而各个操作系统的系统调用是不同的。

- 函数库调用是调用函数库中的一个程序，而系统调用是调用系统内核的服务。

- 函数库调用是与用户程序相联系，而系统调用是操作系统的一个进入点。

- 函数库调用是在用户地址空间执行，而系统调用是在内核地址空间执行。

- 函数库调用的运行时间属于**用户**时间，而系统调用的运行时间属于**系统**时间。

- 函数库调用属于过程调用，开销较小，而系统调用需要切换到内核上下文环境然后切换回来，开销较大。

- 在C函数库libc中大约 300 个程序，在 UNIX 中大约有 90 个系统调用。

- 函数库典型的 C 函数：system，fprintf，malloc，而典型的系统调用：chdir，fork，write，brk。

#### 为什么不直接用函数调用

- 因为读写文件通常是大量的数据（相对于底层驱动的系统调用所实现的数据操作单位），这时，**使用库函数可以大大减少系统调用的次数**。这是因为**缓冲区技术**，在用户空间和内核空间对文件操作都使用了缓冲区，当用户空间缓冲区满或者写操作结束时，才将用户缓冲区的内容写到内核缓存区，同理内核缓冲区满或写结束时，才将内核缓冲区内容写到文件对应的硬件媒介。
- 为了保证可移植性。

#### 库函数的缓冲区

- 对于库函数，如果标准输出连到终端设备（直接输出到屏幕），则它是行缓冲的（遇到回车换行符或者是缓冲区满了才输出）；否则（输出到文件）是全缓冲的（缓冲区填满或者是程序运行结束了才输出）。
- 程序运行结束时，会刷新所有的缓冲区。

由于缓冲机制，也带来了一些问题。解决办法有如下两种：

- 任何时候我们都可以使用fflush(stdout)来刷新标准输出缓冲区。
- 使用不带缓冲的系统调用write替代printf输出。

#### 系统调用底层原理

每个系统调用函数都有一个系统调用号，首先找到系统调用对应的中断号（Linux下是int 0x80），然后在中断向量表中找到对应的中断处理函数，再根据系统调用号，在中断处理函数找到对应系统调用函数进行执行。

### 进程

进程是**资源分配**的基本单位。

**进程组成：**堆栈段（栈用于函数调用，存放着函数的参数，函数内部定义的局部变量，PCB（进程描述信息、控制管理信息、资源分配信息等）），代码段（程序中代码），数据段 （程序的全局变量，常量和静态变量）。

进程控制块（Process Control Block, PCB，即task_struct）描述进程的基本信息和运行状态，所谓的创建进程，执行程序和撤销进程，都是指对 PCB 的操作，PCB 是进程存在的唯一标识，系统通过 PCB 的存在而感知进程的存在 。 系统通过 PCB 对进程进行管理和调度。

### 线程

线程是**独立调度**的基本单位。

一个进程中可以有多个线程，它们共享进程资源。

### 进程启动过程

- 内核将程序读入内存，为程序分配内存空间;
- 内核为该进程分配进程标识符（PID）和其他所需资源;
- 内核为进程保存 PID 及相应的状态信息，把进程放到运行队列中等待执行，程序转化为进程后就可以被操作系统的调度程序调度执行了。

### 程序和进程的区别

程序是编译好的二进制文件，进程通俗讲就是运行的程序，资源分配主要是对CPU和内存进行分配，主要区别是：

- 程序占用磁盘，不占用系统资源，内存占用系统资源，即进程占用系统资源。
- 一个程序对应多个进程，一个进程对应一个程序。
- 程序没有生命周期，进程有生命周期。

### 进程和线程的区别与联系

#### 区别

**I 拥有资源**

进程占有资源，但是线程不占有，线程可以访问隶属进程的资源。

进程所维护的是程序所包含的资源(**静态资源**)， 如：**地址空间，打开的文件句柄集，文件系统状态， 信号处理handler**等;

线程所维护的运行相关的资源(**动态资源**)，如：**运行栈，调度相关的控制信息，待处理的信号集等**; 

**II 调度**

线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。进程切换开销大，由切换页全局目录和切换内核态堆栈和硬件上下文（一组寄存器值）两步组成，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，线程切换只是把寄存器值保存到内核堆栈里，再加载被调度线程的寄存器值。

**III 系统开销**

线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁系统都要为之分配或回收资源，如内存空间、I/O 设备等，需要重新分配及销毁task_struct结构，所付出的开销远大于创建或撤销线程时的开销。

**IV 通信方面**

线程间可以通过直接读写同一进程中的数据段（如全局变量）进行通信，但是进程通信需要借助 IPC，如管道，信号，消息队列，共享内存，套接字等通信机制，需要进程同步和互斥手段的辅助，以保证数据的一致性。

**V 健壮性**

线程、进程之间都可以并发，多进程程序比多线程程序更健壮，进程之间不会相互影响，因为进程有自己独立的地址空间；而一个线程崩溃会导致进程崩溃，从而影响同一个进程里面的其他线程。

#### 联系

线程是存在进程的内部，一个进程中可以有多个线程，一个线程只能存在一个进程中。

### 进程状态切换

![进程状态切换](/Users/wushengna/manual/img/img-post/进程状态切换.png)

- 就绪状态（ready）：等待被调度。
- 运行状态（running）
- 阻塞状态（waiting）：等待资源。

应该注意以下内容：

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

进程控制会导致进程状态的转换，无论哪个进程控制原语， 要做的无非三类事情：

1. 更新PCB中的信息。
   a. 所有的进程控制原语一定都会修改进程状态标志。
   b. 剥夺当前运行进程的CPU使用权必然需要保存其运行环境。
   c. 某进程开始运行前必然要恢复其运行环境。
2. 将PCB插入合适的队列。
3. 分配/回收资源。

### 孤儿进程与僵尸进程

**孤儿进程**是指父进程退出后它的子进程还在执行，孤儿进程会被init进程收养并完成状态收集（危害不大）。

回收方法：`kill -9 pid`

**僵尸进程**是指子进程完成并退出后父进程没有使用`wait()`或者`waitpid()`对它们进行状态收集，这些子进程的进程描述符（PCB）仍然会留在系统中，占用进程号等资源（危害极大）。

回收方法：杀死父进程，init领养。

**相关接口**

- **回收子进程1：**`pid_t wait(int *status);`

  一旦调用`wait()`，就会立即阻塞自己，`wait()`自动分析某个子进程是否已经退出，如果找到僵尸进程就会负责收集和销毁，如果没有找到就一直阻塞在这里，status传出参数指向子进程结束状态值。

  返回值：成功返回终止子进程ID，失败返回-1。

  作用：

  - 阻塞等待。
  - 回收子进程资源。
  - 查看死亡原因。

  子进程死亡原因：

  - 正常死亡`WIFEXITED`
    - 如果`WIFEXITED`为真，使用`WEXITSTATUS`得到退出状态。
  - 非正常死亡`WIFSIGNALED`
    - 如果`WIFSIGNALED`为真，所用`WTERMSIG`得到信号。

- **回收子进程2：**`pid_t waitpid(pid_t pid, int *status, int options);`

  - `pid`
    - `pid < -1` 回收进程组识别码为`pid`绝对值的任何进程。
    - `pid = -1` 回收任意子进程。
    - `pid = 0` 回收和调用进程组id和当前进程相同组内的子进程。
    - `pid > 0`回收指定进程识别码为`pid`的子进程。
  - `options`
    - `0`与`wait()`相同，也会阻塞。
    - `WNOHANG`如果当前没有子进程退出会立刻返回。
    - `WUNYRACED`子进程进入暂停马上返回，但结束状态不予理会。

  返回值：如果设置了`WNOHANG`，那么如果没有子进程退出，返回`0`，如果有子进程退出，返回退出的`pid`，反之失败返回`-1`（没有子进程）。

### 守护进程

**会话**是进程组的更高一级，多个进程组对应一个会话。

**进程组**是多个进程在同一个组，第一个进程默认是进程组的组长，进程组由进程组ID来唯一标识，其组长进程的进程号等于进程组ID，且该进程组ID不会因组长进程的退出而受到影响。

**守护进程**是脱离终端并在后台运行的进程，执行过程中信息不会显示在终端上，并且也不会被终端发出的信号打断。

**创建会话**组长不可以创建，必须是组员创建。

- **创建会话的步骤：**
  - 创建子进程。
  - 父进程杀死。
  - 子进程当会长。
- **创建守护进程的步骤：**
  - 创建子进程，父进程退出：`fork() + if(pid > 0){exit(0);}`，使子进程成为孤儿进程被init进程收养。
  - 在子进程中创建新会话：`setsid()`
  - 改变当前目录结构为根：`chdir("/")`
  - 重设文件掩码（文件权限掩码是指屏蔽掉文件权限中的对应位。）：`umask(0)`
  - 关闭文件描述符：`for(int i = 0; i < 65535; ++i){close(i);}`