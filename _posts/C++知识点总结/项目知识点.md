### 项目描述

需要修改的数据库信息，登录名，密码，库名，`user`，`passwd`，`databasename`。

命令行解析，getopt()，设置模式`config`。

WebServer类`server`声明，初始化http_conn类对象`users`，大小为最大文件描述符65536，getcwd()获得当前路径，缓冲区大小为200，当前路径加上"/root"，设置root文件路径`m_root`，初始化client_data定时器类对象`user_timer`，大小为最大文件描述符65536。

server.init()初始化，使用`config`参数。

server.log_write()创建日志文件，选择是否写日志`m_close_log`，选择**同步写入日志**或者**异步写入日志**`m_log_write`，**同步和异步通过设置阻塞队列长度区分**，异步需要设置阻塞队列的长度，同步设置长度为0，局部变量懒汉单例模式初始化，设置文件名`file_name`为"./ServerLog"，日志缓冲区大小`m_log_buf_size`为2000，日志最大行数`m_split_lines`为800000，阻塞队列长度`max_queue_size`同步为0异步为800，**循环数组模拟生产者消费者模型实现阻塞队列**，为了线程安全需要加互斥锁，当是异步写入，创建线程使用回调函数异步写入日志，回调函数实现从阻塞队列中取出一个日志string，如果当前队列没有元素，将会等待条件变量，FILE*类型文件指针指向log文件，fputs()写入文件，得到当前时间，有路径文件路径为"路径，年月日，`file_name`后缀"，没有路径文件路径为"年月日，`file_name`"，fopen以附加的方式打开只写文件，若文件不存在，则会创建该文件；如果文件存在，则写入的数据会被加到文件尾后，文件原先的内容会被保留。

server.sql_pool()创建数据库连接池，**单例模式初始化数据库连接池**，用**双向链表list维护数据库连接**，创建对应数量数据库连接，出错要写日志，users初始化数据库读取表，从连接池中取一个连接使用RAII机制，在user表中检索用户名和密码，使用map<string,string>维护用户名和密码，**将对应的用户名和密码存入map**。

server.thread_pool()创建线程池，创建对应数量线程，并对线程分离，出错抛出异常，回调函数处理请求队列任务，**用双向链表list维护请求队列**，**并发模型可以选择proactor和reactor**，当选择reactor模式，使用m_state区分读和写，读任务可以在LT模式和ET模式，循环读取客户数据，直到读完或者对方关闭连接，在非阻塞ET模式下需要将数据一次读完，使用recv接收读缓冲区中的数据，取出数据库连接，读取读缓冲区中的数据并且处理，**使用主从状态机解析http请求，从状态机用于分析出一行内容，主状态机用于解析一行意义**，生成http响应，如果是注册，先检测数据库中是否有重名，没有重名增加数据，如果是登录，直接判断，以只读方式获取文件描述符，通过mmap将该文件映射到内存中，向写缓冲区写入对应http响应，使用writev将http响应发送出去，**需要设置EPOLLONESHOT事件**，如果是申请长连接，则重新初始化HTTP对象，当选择proactor模式，取出数据库连接，处理http请求和响应数据。

server.trig_mode()设置触发模式，**监听和连接socket都可以选择LT模式和ET模式**。

server.eventListen()监听，创建socket，选择是否优雅关闭，设置socket文件描述符，bind绑定端口，listen监听端口，初始化定时器，epoll创建内核事件表，添加监听事件，设置非阻塞，创建管道套接字，设置管道写端非阻塞，读端非阻塞，**统一事件源**，添加监听事件，忽略信号值SIGPIPE，监听信号值SIGALRM和SIGTERM，每隔TIMESLOT时间触发SIGALRM信号。

server.eventLoop()运行，epoll等待事件触发，出错要写日志，轮询有事件产生的文件描述符，如果是监听文件描述符，处理新到的客户连接，选择LT模式和ET模式accept接受连接，出错要写日志，使用send发送出错信息，设置定时器，**使用升序双向链表维护定时器**，时间到了删除事件，关闭文件描述符，减少连接数，超时时间设置为3 * TIMESLOT，如果是出错事件，关闭连接，移除定时器，如果管道读端发生读事件，因为统一事件源，信号处理当成读事件处理，使用recv接收信号值，并且处理信号值，出错要写日志，如果是读事件，调整定时器，将读事件放入请求队列，或者读入了再放入请求队列，需要移除定时器，如果是写事件，调整定时器，将写事件放入请求队列，或者写入了再放入请求队列，需要移除定时器，当时间到了处理事件，删除节点，超时写入日志。

### 介绍下你的项目

本项目实现了一个轻量级的Web服务端，提供用户注册，登录等功能，可以对浏览器的链接请求进行解析处理，处理完之后给浏览器客户端返回一个响应，如文字图片视频等。

在并发模型上，采用epoll边沿触发模式来实现IO复用，实现了Reactor模式和同步IO模拟Proactor模式，使用同步IO模拟Proactor事件处理模式，实现半同步/半反应堆线程池，主线程为异步线程，负责监听文件描述符，接收socket新连接，若当前监听的socket发生了读写事件，然后将任务插入到请求队列。工作线程从请求队列中取出任务，完成读写数据的处理，解除了主线程和工作线程的耦合关系。

但是这种半反应堆模式的一个问题就是，因为有了请求队列，每次工作线程处理队列请求都需要加锁，会消耗CPU；另一方面如果任务很多，工作线程很少，就会造成客户端响应速度变慢。高效的半同步/半异步模式，解决办法就是取消任务队列，直接由主线程将各个客户端请求派发给各个工作线程，后期每个工作线程都持续响应同一个请求带来的读写。

使用有限状态机的设计思想，封装了http连接处理类，以实现解析报文请求和发送。其中主状态机主要用于解析客户端请求，在内部调用从状态机，从状态机用于解析一行内容并把每一行加\0\0格式化，将处理状态和数据传给主状态机，主状态机调用解析请求行，请求头，请求内容三部分函数进行解析，解析结束后生成响应报文，支持http长连接，支持解析GET和POST请求。

由于非活跃连接占用了连接资源，严重影响服务器的性能，基于双向链表实现一个服务器定时器，处理这种非活跃连接，释放连接资源。

此外，使用单例模式创建日志系统，对服务器运行状态、错误信息和访问数据进行记录，支持按天分类，超行分类功能，可以根据实际情况分别使用同步和异步写入两种方式，其中异步写入方式，将生产者-消费者模型封装为阻塞队列，创建一个写线程，工作线程将要写的内容push进队列，写线程从队列中取出内容，写入日志文件。

用单例模式建立数据库连接池，提前创建一定量的数据链接，并把他们保存在双向链表中，通过重复使用这些已经建立的数据库连接，解决频繁建立连接的缺点，从而提高系统性能。

### 线程池中的工作线程是一直等待吗

**线程池中的工作线程是处于一直阻塞等待的模式**，因为在创建线程池之初，通过循环调用pthread_create往线程池中创建了8个工作线程，工作线程处理函数接口为pthread_create函数原型中第三个参数函数指针所指向的worker函数，然后调用线程池类成员函数run（因为传入函数参数类型需要void*，已经将worker设置为静态成员函数，而静态成员函数只能访问静态成员变量，所以为了能够访问到类内非静态成员变量，可以通过在worker中调用run这个非静态成员变量来达到这一要求），在run函数中，将线程池中的工作线程都设置为阻塞等待在请求队列是否不为空的条件上，因此项目中线程池中的工作线程是处于一直阻塞等待的模式下的。

### 线程池工作线程处理完一个任务后的状态是什么

- 当处理完任务后如果请求队列为空时，则这个线程重新回到阻塞等待的状态。
- 当处理完任务后如果请求队列不为空时，那么这个线程将处于与其他线程竞争资源的状态，谁获得锁谁就获得了处理事件的资格。

### 如果同时1000个客户端进行请求访问，线程数不多，怎么能及时响应处理每一个请求访问

- **通过对子线程循环调用来解决高并发的问题**，调用了pthread_detach的线程只有等到他结束时系统才会回收他的资源，可以通过子线程的run调用函数进行while循环，让每一个线程池中的线程永远都不会终止，就是让他处理完当前任务就去处理下一个，没有任务就一直阻塞在那里等待，这样就能达到服务器高并发的要求，同一时刻8个线程都在处理请求任务，处理完之后接着处理，直到请求队列为空表示任务全部处理完成。
- **使用一个缓冲队列保存客户端的请求**，然后工作线程慢慢读取请求任务进行处理，直到全部任务完成。

### 如果一个客户请求需要占用线程很长的时间，会不会影响接下来的客户请求，有什么好的策略

**会影响接下来的客户请求**，因为线程池内线程的数量是有限的，如果客户请求占用线程时间过久的话会影响到处理请求的效率，当请求处理过慢时会造成后续接受的请求只能在请求队列中等待被处理，从而影响接下来的客户请求。

- 如果没有线程数限制，目前项目是固定线程数，**可以改成动态线程池**，连接请求过多的时候增加线程，对线程池进行一个扩充。
- **可以为线程处理请求对象设置处理超时时间**，超过时间先发送信号告知线程处理超时，然后设定一个时间间隔再次检测，若此时这个请求还占用线程则直接将其断开连接。
- **使用一个缓冲队列保存客户端占用时间很长的请求**，然后使用工作线程先处理其他请求，有空闲时间再处理占用时间长的请求。

### Reactor，Proactor，主从Reactor模型的区别

- **Reactor模式**：要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生（可读、可写），若有则立即通知工作线程，将socket可读可写事件放入请求队列，**读写数据，接受新连接及处理客户请求均在工作线程中完成**。

- **Proactor模式**：主线程和内核负责处理读写数据，接受新连接等**I/O操作**，**工作线程仅负责业务逻辑（给予相应的返回url）**，如处理客户请求。

- **主从Reactor模式**：核心思想是主反应堆线程只负责分发Acceptor连接建立，已连接套接字上的I/O事件交给sub-reactor负责分发，其中sub-reactor的数量，可以根据CPU的核数来灵活设置。**主反应堆线程一直在感知连接建立的事件**，如果有连接成功建立，主反应堆线程通过accept方法获取已连接套接字，**接下来会按照一定的算法选取一个从反应堆线程**，并把已连接套接字**加入到选择好的从反应堆线程中**，主反应堆线程唯一的工作，就是调用accept获取已连接套接字，以及将已连接套接字加入到从反应堆线程中。

- **同步IO模拟Proactor模式**：主线程往epoll内核事件表中注册socket上的读就绪事件，主线程调用epoll_wait等待socket上有数据可读，当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。睡眠在请求队列上的工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。

- **读就绪事件**：当有事件到来，epoll_wait()单纯通知主线程有事件来了，主线程把事件放入请求队列。应用程序利用工作线程通过read()等函数把数据从内核缓冲区读到用户缓冲区。

  **读完成事件**：有事件来了，主线程往内核注册这个读事件（就是告诉内核注意了一会要读数据）。注册了之后，主线程就去干其他事情，内核就自动会负责将数据从内核缓冲区放到用户缓冲区，不用用户程序管。

  Reactor模式主线程向工作线程通知的是读就绪事件，工作线程负责读事件的处理，而Proactor模式主线程向工作线程通知的是读完成事件，工作线程只负责业务逻辑。

  对于用同步IO模拟的Proactor模式，之前Proactor是用主线程调用aio_read函数向内核注册读事件，这里它是主线程使用epoll向内核注册读事件，但是内核不会负责将数据从内核读到用户缓冲区，最后还是要靠主线程也就是用户程序read()函数等负责将内核数据循环读到用户缓冲区，对于工作线程来说，收到的都是已读完成的数据，模拟就体现在这里。

  两种Proactor模式都是通过主线程调用不同函数进行注册，然后一个注册之后可以直接内核负责数据从内核到用户，另一个为什么需要注册，直接主线程循环读取然后封装放请求队列不就行了？

  不对，如果数据一直没来，直接进行循环读取就会持续在这里发生阻塞，这就是同步IO的特点，所以一定要注册了然后等通知，这样就可以避免长期阻塞等候数据。

### HTTP报文解析状态机转移图

![HTTP报文解析状态机转移图](/Users/wushengna/manual/img/img-post/HTTP报文解析状态机转移图.png)

- 主状态机，三种状态，标识解析位置。
  - CHECK_STATE_REQUESTLINE，解析请求行。
  - CHECK_STATE_HEADER，解析请求头。
  - CHECK_STATE_CONTENT，解析消息体，仅用于解析POST请求。

- 从状态机，三种状态，标识解析一行的读取状态。
  - LINE_OK，完整读取一行。
  - LINE_BAD，报文语法有误。
  - LINE_OPEN，读取的行不完整。

在HTTP报文中，每一行的数据由\r\n作为结束字符，空行则是仅仅是字符\r\n，因此可以通过查找\r\n将报文拆解成单独的行进行解析，从状态机负责读取buffer中的数据，将每行数据末尾的\r\n置为\0\0，并更新从状态机在buffer中读取的位置m_checked_idx，以此来驱动主状态机解析，主状态机根据状态调用不同的函数对请求进行解析，并设置状态机的状态。

### 数据库登录注册

数据库登录分为：载入数据表，提取用户名和密码，注册和登录校验和页面跳转。

- 载入数据表就是把数据库的数据通过map容器传到服务器上，map中的key为用户名，value为密码。
- 当从浏览器上输入用户的用户名和密码后，浏览器会一个post请求报文，服务器通过解析请求报文的消息体，解析出账号密码。
- 根据解析出的账号密码，工作线程从数据库连接池取得一个连接，访问数据库中的数据，与map容器中保存账号密码进行对比校验，相符则成功登陆，访问完毕后将连接交还连接池，注册账号时，同样将输入的账号密码与数据库已经存储的账号名进行对比校验，防止出现相同的账号名，如果不相同就加入数据库。
- 当输入的账号密码与数据库的数据成功匹配，就将浏览器跳转到对应的界面。

### 登录中的用户名和密码是load到本地，然后使用map匹配，如果有10亿数据，即使load到本地后hash也是很耗时的，可以怎样优化

使用缓存和数据库，如果数据库复杂，可以在逻辑设计的时候设计过多的表间关联，尽可能的降低数据的冗余，建立高效的索引，把使用更频繁的索引放在选择的首列。

具体操作，利用hash建立多级索引的方式来加快用户验证，首先将10亿的用户信息，利用大致缩小1000倍的hash算法进行hash，这时就获得了100万的hash数据，每一个hash数据代表着一个**用户信息块（一级）**；然后再分别对这100万的hash数据再进行hash，例如最终剩下1000个**hash数据（二级）**，在这种方式下，服务器只需要保存1000个二级hash数据，当用户请求登录的时候，先对用户信息进行一次hash，找到对应信息块（二级），在读取其对应的一级信息块，最终找到对应的用户数据。

### MySQL和Redis的区别

- MySQL是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢。
- Redis是NoSQL，即非关系型数据库，也是缓存数据库，即将数据存储在缓存中，缓存的读取速度快，能够大大的提高运行效率，但是保存时间有限。

### 定时器的工作原理

服务器主循环为每一个连接创建一个定时器，并对每个连接进行定时，另外利用升序时间链表容器将所有定时器串联起来，若主循环接收到定时通知，则在链表中依次执行定时任务，具体来说利用alarm函数周期性地触发 SIGALRM 信号，信号处理函数利用管道通知主循环，主循环接收到该信号后对升序链表上所有定时器进行处理，遍历定时器升序链表容器，从头结点开始依次处理每个定时器，直到遇到尚未到期的定时器，对到期的定时器执行回调函数，关闭连接，释放资源。

### 定时器删除和添加的时间复杂度，可以怎样优化，最小堆优化方法和时间复杂度

添加定时器时时间复杂度是O(n)，删除是O(1)，从头开始遍历的直到遍历到未超时的定时器。

添加在尾节点的时间复杂度可以优化，在添加新的定时器的时候，除了检测新定时器是否在小于头节点定时器的时间外，先检测新定时器是否在大于尾节点定时器的时间，都不符合再使用常规插入。

另外可以使用时间堆优化，用最小堆来构建，堆顶的元素就是最小的，将所有定时器中超时时间最小的一个定时器的超时值作为alarm函数的定时值，这样一旦定时任务处理函数tick()被调用，超时时间最小的定时器必然到期，我们就可以在tick函数中处理该定时器，然后再次从剩余的定时器中找出超时时间最小的一个定时器，并将这段最小时间设置为下一次alarm函数的定时值。添加定时器时时间复杂度是O(lgn)，删除是O(1)。

### 日志系统的运行机制

使用单例模式创建日志系统，对服务器运行状态，错误信息和访问数据进行记录，该系统可以实现按天分类，超行分类功能，可以根据实际情况分别使用同步和异步写入两种方式。其中异步写入方式，将生产者-消费者模型封装为阻塞队列，使用循环数组实现（可以通过是否设置阻塞队列大小判断是否异步，0为同步），创建一个写线程，工作线程将要写的内容push进队列，写线程从队列中取出内容，写入日志文件。

- 日志文件
  - 局部变量的懒汉模式获取实例。
  - 生成日志文件，并判断同步和异步写入方式。
- 同步
  - 判断是否分文件。
  - 直接格式化输出内容，将信息写入日志文件。

- 异步
  - 判断是否分文件。
  - 格式化输出内容，将内容写入阻塞队列，创建一个写线程，从阻塞队列取出内容写入日志文件。

![日志系统状态图](/Users/wushengna/manual/img/img-post/日志系统状态图.png)

日志写入函数与工作线程串行执行，由于涉及到I/O操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程，服务器所能处理的并发能力将有所下降，尤其是在峰值的时候，写日志可能成为系统的瓶颈。而异步日志采用生产者-消费者模型，工作线程将所写的日志内容先存入缓冲区，写线程从缓冲区中取出内容，写入日志，并发能力比较高。

当监控一台服务器的状态，输出监控日志，需要将日志分发到不同的机器上，可以使用观察者模式，或者是多机器，借助redis数据库的消息队列的发布订阅模式，实现分布式日志系统。