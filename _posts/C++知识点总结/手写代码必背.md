### 如何判断大小端存储

```c++
#include <iostream>

using namespace std;

union U{
    int a;
    char b;
}; //在一个联合体里可以定义多种不同的数据类型，这些数据共享一段内存，在不同的时间里保存不同的数据类型和长度的变量，以达到节省空间的目的，但同一时间只能存储其中一个成员变量的值

int main(){
    U u;
    u.a = 0x1234;
    if(u.b == 0x12){
        cout << "big endian" << endl;
    }
    else if(u.b == 0x34){
        cout << "little endian" << endl;
    }
    return 0;
}
```

### 单例模式

```c++
#include <iostream>

using namespace std;

class CSingleton{
private:
  CSingleton(){ //构造函数是私有的
    
  }
  static CSingleton *m_pInstance;
public:
  static CSingleton *GetInstance(){
    if(m_pInstance == NULL){ //判断是否第一次调用
      m_pInstance = new CSingleton();
    }
    return m_pInstance;
  }
};
CSingleton *CSingleton::m_pInstance = NULL; //初始化静态数据成员
int main(){
  CSingleton *s1 = CSingleton::GetInstance();
  CSingleton *s2 = CSingleton::GetInstance();
  if(s1 == s2){
    cout << "s1 = s2" << endl; //程序的执行结果是输出了s1 = s2
  }
  return 0;
}
```

### LRU

LRU即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。

```c++
class LRUCache {
public:
    struct Node
    {
        int val, key;
        Node *left, *right;
        Node() : key(0), val(0), left(NULL), right(NULL) {}
    };
    Node *hu, *tu; // hu: head_used, tu: tail_used; head在左侧，tail在右侧
    Node *hr, *tr; // hr: head_remains, tr: tail_remains; head在左侧，tail在右侧
    int n;
    unordered_map<int, Node*> hash;

    void delete_node(Node *p)
    {
        p->left->right = p->right, p->right->left = p->left;
    }
    
    void insert_node(Node *h, Node *p)
    {
        p->right = h->right, h->right = p;
        p->left = h, p->right->left = p;
    }
    
    LRUCache(int capacity) {
        n = capacity;
        hu = new Node(), tu = new Node();
        hr = new Node(), tr = new Node();
        hu->right = tu, tu->left = hu;
        hr->right = tr, tr->left = hr;
    
        for (int i = 0; i < n; i ++ )
        {
            Node *p = new Node();
            insert_node(hr, p);
        }
    }
    
    int get(int key) {
        if (hash[key])
        {
            Node *p = hash[key];
            delete_node(p);
            insert_node(hu, p);
            return p->val;
        }
        return -1;
    }
    
    void put(int key, int value) {
        if (hash[key])
        {
            Node *p = hash[key];
            delete_node(p);
            insert_node(hu, p);
            p->val = value;
            return;
        }
    
        if (!n)
        {
            n ++ ;
            Node *p = tu->left;
            hash[p->key] = 0;
            delete_node(p);
            insert_node(hr, p);
        }
    
        n -- ;
        Node *p = hr->right;
        p->key = key, p->val = value, hash[key] = p;
        delete_node(p);
        insert_node(hu, p);
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

### LFU

LFU最不经常使用，要求在页置换时置换使用次数最少的页面。

```c++
class LFUCache {
public:

    struct Node{
        int key;
        int val;
        Node *left, *right;
        Node(int _key, int _val):key(_key),val(_val),left(NULL),right(NULL){}
    };

    struct Block{
        Block *left, *right;
        Node *hn, *tn;
        int cnt;
        Block(int _cnt){
            cnt = _cnt;
            left = right = NULL;
            hn = new Node(-1,-1), tn = new Node(-1,-1);
            hn->right = tn;
            tn->left = hn;
        }
        ~Block(){
            delete hn;
            delete tn;
        }
        void insert_node(Node *p){
            p->left = hn;
            p->right = hn->right;
            hn->right->left = p;
            hn->right = p;
        }
        void delete_node(Node *p){
            p->left->right = p->right;
            p->right->left = p->left;
        }
        bool empty(){
            return hn->right == tn;
        }
    }*hb,*tb;
    int n;
    unordered_map<int,Block*> hash_block;
    unordered_map<int,Node*> hash_node;

    void insert_block(Block *p){
        auto cur = new Block(p->cnt + 1);
        cur->left = p;
        cur->right = p->right;
        p->right->left = cur;
        p->right = cur;
    }

    void delete_block(Block *p){
        p->left->right = p->right;
        p->right->left = p->left;
        delete p;
    }

    LFUCache(int capacity) {
        n = capacity;
        hb = new Block(0);
        tb = new Block(INT_MAX);
        hb->right = tb;
        tb->left = hb;
    }
    
    int get(int key) {
        if(hash_block.count(key) == 0){
            return -1;
        }
        auto block = hash_block[key];
        auto node = hash_node[key];
        block->delete_node(node);
        if(block->right->cnt != block->cnt + 1){
            insert_block(block);
        }
        block->right->insert_node(node);
        hash_block[key] = block->right;
        if(block->empty()){
            delete_block(block);
        }
        return node->val;
    }
    
    void put(int key, int value) {
        if(!n){
            return;
        }
        if(hash_block.count(key)){
            hash_node[key]->val = value;
            get(key);
        }
        else{
            if(hash_block.size() == n){
                auto p = hb->right->tn->left;
                hb->right->delete_node(p);
                if(hb->right->empty()){
                    delete_block(hb->right);
                }
                hash_block.erase(p->key);
                hash_node.erase(p->key);
                delete p;
            }
            auto p = new Node(key,value);
            if(hb->right->cnt > 1){
                insert_block(hb);
            }
            hb->right->insert_node(p);
            hash_block[key] = hb->right;
            hash_node[key] = p;
        }
    }
};

/**
 * Your LFUCache object will be instantiated and called as such:
 * LFUCache* obj = new LFUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```

### string

```c++
#include <iostream>
#include <string>

using namespace std;

class String{
public:
    String(const char *str = NULL); //普通构造函数
    String(const String &other); //拷贝构造函数
    ~String(); //析构函数
    String &operator=(const String &other); //拷贝赋值函数
    String operator+(const String &other); //字符串连接
    bool operator==(const String &other); //判断相等
    char operator[](int idx); //返回访问字符
    friend ostream &operator<<(ostream& os, const String& str); //输出字符串
    int getLength(); //返回长度
private:
    char *m_data; //私有变量保存字符串
};

String::String(const char *str){
    if(str == NULL){
        m_data = new char[1];
        *m_data = '\0';
    }
    else{
        int length = strlen(str);
        m_data = new char[length + 1];
        strcpy(m_data,str);
    }
}

String::~String(){
    if(m_data){
        delete[] m_data;
        m_data = 0;
    }
}

String::String(const String &other){ //输入参数为const型
    if(!other.m_data){ //对m_data加NULL判断
        m_data = 0;
    }
    m_data = new char[strlen(other.m_data) + 1];
    strcpy(m_data,other.m_data);
}

String &String::operator=(const String &other){ //输入参数为const型
    if(this != &other){ //检查是否自赋值
        delete[] m_data; //释放原有的内存资源
        if(!other.m_data){ //对m_data做NULL判断
            m_data = 0;
        }
        else{
            m_data = new char[strlen(other.m_data) + 1];
            strcpy(m_data,other.m_data);
        }
    }
    return *this; //返回本对象的引用
}

String String::operator+(const String &other){
    String newString;
    if(!other.m_data){
        newString = *this;
    }
    else if(!m_data){
        newString = other;
    }
    else{
        newString.m_data = new char[strlen(m_data) + strlen(other.m_data) + 1];
        strcpy(newString.m_data,m_data);
        strcat(newString.m_data,other.m_data);
    }
    return newString;
}

bool String::operator==(const String &other){
    if(strlen(m_data) != strlen(other.m_data)){
        return false;
    }
    else{
        return strcmp(m_data,other.m_data) ? false:true;
    }
}

char String::operator[](int idx){
    if(idx > 0 && idx < strlen(m_data)){
        return m_data[idx];
    }
}

ostream &operator<<(ostream& os, const String& str){
    os << str.m_data;
    return os;
}

int String::getLength(){
    return strlen(m_data);
}

int main(){
    String str1 = "yes";
    String str2 = "buy";
    str2 = str1;
    cout << str1[2] << endl;
    return 0;
}
```

### 数组模拟栈

```c++
// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空
if (tt > 0)
{

}
```

### 数组模拟队列

```c++
//1.普通队列
// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh <= tt)
{

}

//2.循环队列
// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh != tt)
{

}
```

### 归并排序

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10;
int q[N], tmp[N];
int n;

void merge_sort(int q[], int l, int r){
    if(l >= r){
        return;
    }
    int mid = l + r >> 1;
    
    merge_sort(q,l,mid);
    merge_sort(q,mid + 1,r);
    
    int k = 0, i = l, j = mid + 1;
    while(i <= mid && j <= r){
        if(q[i] <= q[j]){
            tmp[k++] = q[i++];
        }
        else{
            tmp[k++] = q[j++];
        }
    }
    while(i <= mid){
        tmp[k++] = q[i++];
    }
    while(j <= r){
        tmp[k++] = q[j++];
    }
    for(int i = l, j = 0; i <= r; i++, j++){
        q[i] = tmp[j];
    }
    return;
}

int main(){
    scanf("%d",&n);
    for(int i = 0; i < n; i++){
        scanf("%d",&q[i]);
    }
    merge_sort(q,0,n - 1);
    for(int i = 0; i < n; i++){
        printf("%d ",q[i]);
    }
    return 0;
}
```

### 快速排序

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10;
int q[N];
int n;

void quick_sort(int q[], int l, int r){
    if(l >= r){
        return;
    }
    int x = q[l + r >> 1], i = l - 1, j = r + 1;
    while(i < j){
        do{
            i++;
        }while(q[i] < x);
        do{
            j--;
        }while(q[j] > x);
        if(i < j){
            swap(q[i],q[j]);
        }
    }
    quick_sort(q,l,j); //边界条件，选择q[l + r >> 1]，区间要用[l,j]和[j + 1,r]
    quick_sort(q,j + 1,r);
    return;
}

int main(){
    scanf("%d",&n);
    for(int i = 0; i < n; i++){
        scanf("%d",&q[i]);
    }
    quick_sort(q,0,n - 1);
    for(int i = 0; i < n; i++){
        printf("%d ",q[i]);
    }
    return 0;
}
```

