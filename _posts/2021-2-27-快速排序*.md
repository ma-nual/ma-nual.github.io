---
layout:     post
published:  true
title:      "快速排序"
subtitle:   "算法笔记"
date:       2021-2-27 10:00:00
author:     "Manual"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 算法
---

> 本文介绍了快速排序的相关知识

## 算法思想

分治思想，如果要排序数组中下标从p到r之间的一组数据，选择p到r之间的任意一个数据作为q（分区点），遍历p到r之间的数据，将小于等于q的放到左边，将大于q的放到右边，将q放到中间，根据分治、递归的处理思想，用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了

## 算法步骤

1. 确定分界点：q[l]，q[l + r >> 1]，q[r]，随机
2. 调整区间：使数组在x左边数值都小于等于x，在x右边数值都大于等于x
3. 递归处理左右两段

## 算法模板

**题目描述**

给定你一个长度为n的整数数列，请你使用快速排序对这个数列按照从小到大进行排序，并将排好序的数列按顺序输出

**输入格式**

输入共两行，第一行包含整数 n

第二行包含 n 个整数（所有整数均在1~10^9范围内），表示整个数列

**输出格式**

输出共一行，包含 n 个整数，表示排好序的数列

**数据范围**

1≤n≤100000

**输入样例：**

```c++
5
3 1 2 4 5
```

**输出样例：**

```c++
1 2 3 4 5
```

**C++代码：**

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10;
int q[N];
int n;

void quick_sort(int q[], int l, int r){
    if(l >= r){
        return;
    }
    int x = q[l + r >> 1], i = l - 1, j = r + 1;
    while(i < j){
        do{
            i++;
        }while(q[i] < x);
        do{
            j--;
        }while(q[j] > x);
        if(i < j){
            swap(q[i],q[j]);
        }
    }
    quick_sort(q,l,j); //边界条件，选择q[l + r >> 1]，区间要用[l,j]和[j + 1,r]
    quick_sort(q,j + 1,r);
    return;
}

int main(){
    scanf("%d",&n);
    for(int i = 0; i < n; i++){
        scanf("%d",&q[i]);
    }
    quick_sort(q,0,n - 1);
    for(int i = 0; i < n; i++){
        printf("%d ",q[i]);
    }
    return 0;
}
```

## 性能分析

**稳定性**

不稳定，快速排序在分区后，相同数值的先后顺序会改变，如果要修改为稳定的，可以将数组中存入相同的数a[i]改为存入pair<a[i],i>

**时间复杂度**

对于长度为n的数组，递归每层分区不是除2，但是期望是除2，直到区间为1，共有logn层（以2为底），对每层排序的时间复杂度为O(n)，总的时间复杂度是O(nlogn)，快速排序在极端情况下（有序数组，每次分区得到的两个区间是不均等的），时间复杂度会退化为O(n^2)，平均情况的时间复杂度都是O(nlogn)，可以通过随机取分节点或者取中点避免最差情况

**空间复杂度**

递归造成的栈空间的使用，递归logn次，空间复杂度为O(logn)

## 相关题目（补充）

