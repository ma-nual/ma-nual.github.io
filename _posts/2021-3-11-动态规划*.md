---
layout:     post
published:  true
title:      "动态规划"
subtitle:   "算法笔记"
date:       2021-3-10 8:00:00
author:     "Manual"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 算法
---

> 本文介绍了动态规划的相关知识

## 算法思想

**背包问题**

- 01背包：每件物品最多只用一次，在背包能装下的前提，求最大价值
- 完全背包：每件物品有无限个，在背包能装下的前提，求最大价值
- 多重背包：每个物品数量不一样，在背包能装下的前提，求最大价值
- 分组背包：每一组最多只能选一个，在背包能装下的前提，求最大价值

**线性DP**

**区间DP**

**计数DP**

## 相关题目（补充）

### 01背包问题

**题目描述**

有N件物品和一个容量是V的背包，每件物品只能使用一次。第i件物品的体积是vi，价值是wi。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。

接下来有N行，每行两个整数vi,wi，用空格隔开，分别表示第i件物品的体积和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

`0<N,V≤1000`
`0<vi,wi≤1000`

**输入样例**

```c++
4 5
1 2
2 4
3 4
4 5
```

**输出样例：**

```c++
8
```

**算法**

状态`f[i][j]`定义：前i个物品，背包容量j下的最优解（最大价值）

我们的决策是如何取到最大价值，`f[i][j] = max(f[i - 1][j],f[i - 1][j - v[i]] + w[i])`

**C++ 代码**

```c++
#include <iostream>

using namespace std;

const int N = 1010;
int n, m, res[N][N], v[N], w[N];

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        cin >> v[i] >> w[i];
    }
    for(int i = 1; i <= n; i++){
        for(int j = 0; j <= m; j++){
            res[i][j] = res[i - 1][j];
            if(j >= v[i]){
                res[i][j] = max(res[i][j],res[i - 1][j - v[i]] + w[i]);
            }
        }
    }
    cout << res[n][m] << endl;
    return 0;
}
```

### 完全背包问题

**题目描述**

有N种物品和一个容量是V的背包，每种物品都有无限件可用。第i种物品的体积是vi，价值是wi。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有N行，每行两个整数vi,wi，用空格隔开，分别表示第i种物品的体积和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

`0<N,V≤1000`
`0<vi,wi≤1000`

**输入样例**

```c++
4 5
1 2
2 4
3 4
4 5
```

**输出样例：**

```c++
10
```

**算法**

状态`f[i][j]`定义：前i个物品，背包容量j下的最优解（最大价值）

我们的决策是如何取到最大价值，`f[i][j] = max(f[i][j],f[i - 1][j - k * v[i]] + k * w[i])`，`f[i,j] = max(f[i - 1,j],f[i - 1,j - v[i]] + w[i],f[i - 1,j - 2 * v[i]] + 2 * w[i],f[i - 1,j - 3 * v[i]] + 3 * w[i],...)`，`f[i,j - v[i]] = max(f[i - 1,j - v[i]],f[i - 1,j - 2 * v[i]] + w[i],f[i - 1,j - 2 * v[i]] + 3 * w[i],...)`，由上两式，可得出如下递推关系：`f[i][j] = max(f[i,j - v[i]] + w[i],f[i - 1][j])`

**C++ 代码**

```c++
#include <iostream>

using namespace std;

const int N = 1010;
int n, m;
int v[N], w[N], res[N][N];

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        cin >> v[i] >> w[i];
    }
    for(int i = 1; i <= n; i++){
        for(int j = 0; j <= m; j++){
            res[i][j] = res[i - 1][j];
            if(j >= v[i]){
                res[i][j] = max(res[i][j], res[i][j - v[i]] + w[i]);
            }
        }
    }
    cout << res[n][m] << endl;
    return 0;
}
```

### 多重背包问题

**题目描述**

有N种物品和一个容量是V的背包。第i种物品最多有si件，每件体积是vi，价值是wi。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有N行，每行三个整数vi,wi,si，用空格隔开，分别表示第i种物品的体积、价值和数量。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

`0<N,V≤100`
`0<vi,wi,si≤100`

**输入样例**

```c++
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

**输出样例：**

```c++
10
```

**算法**

状态`f[i][j]`定义：前i个物品，背包容量j下的最优解（最大价值）

我们的决策是如何取到最大价值，`f[i][j] = max(f[i][j],f[i - 1][j - k * v[i]] + k * w[i])`，有条件限制`k <= s[i]`

**C++ 代码**

```c++
#include <iostream>

using namespace std;

const int N = 110;
int n, m;
int v[N], w[N], s[N], res[N][N];

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        cin >> v[i] >> w[i] >> s[i];
    }
    for(int i = 1; i <= n; i++){
        for(int j = 0; j <= m; j++){
            for(int k = 0; k <= s[i] && k * v[i] <= j; k++){
                res[i][j] = max(res[i][j],res[i - 1][j - k * v[i]] + k * w[i]);
            }
        }
    }
    cout << res[n][m] << endl;
    return 0;
}
```

### 分组背包问题

**题目描述**

有N组物品和一个容量是V的背包。每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是vij，价值是wij，其中i是组号，j是组内编号。求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值。

**输入格式**

第一行有两个整数N，V，用空格隔开，分别表示物品组数和背包容量。

接下来有N组数据：

- 每组数据第一行有一个整数Si，表示第i个物品组的物品数量；
- 每组数据接下来有Si行，每行有两个整数vij,wij，用空格隔开，分别表示第i个物品组的第j个物品的体积和价值；

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

`0<N,V≤100`

`0<si≤100`

`0<vij,wij≤100`

**输入样例**

```c++
3 5
2
1 2
2 4
1
3 4
1
4 5
```

**输出样例：**

```c++
8
```

**算法**

状态`f[i][j]`定义：只从前i组物品中选，当前体积小于等于j的最大值

我们的决策是如何取到最大价值，`f[i][j] = max(f[i - 1][j],f[i - 1][j - v[i][k]] + w[i][k])`，有条件限制`k <= s[i]`

**C++ 代码**

```c++
#include <iostream>

using namespace std;

const int N = 110;
int n, m;
int v[N][N], w[N][N], s[N], res[N][N];

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        cin >> s[i];
        for(int j = 0; j < s[i]; j++){
            cin >> v[i][j] >> w[i][j];
        }
    }
    for(int i = 1; i <= n; i++){
        for(int j = 0; j <= m; j++){
            res[i][j] = res[i - 1][j];
            for(int k = 0; k < s[i]; k++){
                if(j >= v[i][k]){
                    res[i][j] = max(res[i][j],res[i - 1][j - v[i][k]] + w[i][k]);
                }
            }
        }
    }
    cout << res[n][m] << endl;
    return 0;
}
```

