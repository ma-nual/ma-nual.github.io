---
layout:     post
published:  true
title:      "static"
subtitle:   "C++笔记"
date:       2021-2-25 11:00:00
author:     "Manual"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - C++
---

> 本文介绍了static的相关知识

## 用法

首先，无论是全局静态变量还是局部静态变量，只要是初始化了的就在.data区，未初始化的就在.bss区，注意和const的区别，const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用

使用static的场景可以分为以下5类：

1. **全局静态变量：**全局变量前面加一个static即全局静态变量，全局静态变量并未改变全局变量的存储位置及生命周期，而是改变了其作用域，全局静态变量的作用域为其所在的文件，当前文件外的源文件无法访问该变量，即它对其它文件是不可见的
2. **局部静态变量：**在函数体中声明的静态变量，改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），其虽然不会随函数的结束而销毁，但是其作用域和函数体中其它变量一样，在函数外是不可见的，当下一次调用同样的函数时，其值会保持和上次一样
3. **静态函数：**在函数名前面加一个static即为静态函数，作用域为其所在的文件，只能在本文件中使用，不能被其他文件调用，也不会和其他文件中的同名函数冲突
4. **类中的静态成员：**类中的静态成员需要在类外初始化，且拥有一块单独的存储区，而不管创建了多少个该类的对象，所有这些对象的静态数据成员都共享这一块静态存储空间，它不属于具体的一个该类对象，而是属于整个类，所有的对象只保存一个该变量，如果改变它的值，则在各个对象中这个数据成员的值同时都改变了，静态成员通过<类名>::<静态成员>来使用，不需要生成对象就可以访问该成员，所以使用它也不需要this指针
5. **类中的静态函数：**类中的静态函数也是属于整个类的，所有对象实例共享该函数，调用它也不需要传入this指针，所以函数体中也不能使用类的非静态成员，而且不需要创建任何对象实例就可以访问该函数，但是也允许通过对象名调用静态成员函数，如果一定要引用本类的非静态成员，应该加对象名和成员运算符“.”（最好不要），**不可以同时用const和static修饰成员函数**（C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的）

## 修饰普通变量

```C++
#include <iostream> 
#include <string> 
using namespace std; 

void demo() 
{ 
    // static variable 
    static int count = 0; 
    cout << count << " "; 
    count++; 
} 

int main() 
{ 
    for (int i=0; i<5; i++)  
        demo(); 
    return 0; 
}
//输出：0 1 2 3 4 每次调用函数时，都不会对变量计数进行初始化。
```

## 修饰普通函数

普通函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。因此定义静态函数有以下好处：
<1> 其他文件中可以定义相同名字的函数，不会发生冲突
<2> 静态函数不能被其他文件所用

## 修饰成员变量

由于声明为static的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量**由对象共享**，对于不同的对象，不能有相同静态变量的多个副本，也是因为这个原因，静态变量不能使用构造函数初始化

```C++
#include<iostream> 
using namespace std; 

class Apple 
{ 
public: 
    static int i; //类内声明

    Apple() 
    { 
        // Do nothing 
    }; 
}; 

int Apple::i = 1; //类外初始化

int main() 
{ 
    Apple obj; 
    // prints value of i 
    cout << obj.i; 
} 
```

## 修饰成员函数

就像类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象，我们被允许使用对象和'.'来调用静态成员函数，但建议使用类名和范围解析运算符调用静态成员

静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数

```C++
#include<iostream> 
using namespace std; 

class Apple 
{ 
    public: 
        // static member function 
        static void printMsg() 
        {
            cout<<"Welcome to Apple!"; 
        }
}; 

// main function 
int main() 
{ 
    // invoking a static member function 
    Apple::printMsg(); 
} 
```

### 生命周期问题

```C++
#include<iostream> 
using namespace std; 

class Apple 
{ 
    int i; 
    public: 
        Apple() 
        { 
            i = 0; 
            cout << "Inside Constructor\n"; 
        } 
        ~Apple() 
        { 
            cout << "Inside Destructor\n"; 
        } 
}; 

int main() 
{ 
    int x = 0; 
    if (x==0) 
    { 
        static Apple obj; 
    } 
    cout << "End of main\n"; 
} 

//Inside Constructor
//End of main
//Inside Destructor
如果为普通类
//Inside Constructor
//Inside Destructor
//End of main
```

在上面的程序中，对象在if块内声明为非静态，因此变量的范围仅在if块内，因此，当创建对象时，将调用构造函数，并且在if块的控制权越过析构函数的同时调用，因为对象的范围仅在声明它的if块内

现在，在main结束后调用析构函数，这是因为静态对象的范围是贯穿程序的生命周期

## 类成员注意事项

1. static类成员使用时必须初始化，且只能类外初始化，声明与实现分离时，只能初始化在实现部分（.cpp部分）
2. 可以通过类名访问（无对象生成时亦可），也可以通过对象访问，不同的类对象中共享static数据成员
3. static成员函数可以直接访问所属类的static成员，但不能直接使用非static成员（没有this指针）
4. 如果只声明了类而未定义对象，类的一般数据成员是不占内存空间的，只有在定义对象时才会为对象的数据成员分配空间，但是静态数据成员不属于某一个对象，所以在为对象所分配的空间中不包括静态数据成员所占的空间，静态数据成员是在所有对象之外单独开辟一段空间来存放，只要在类中定义了静态数据成员，即使不定义对象，也为静态数据成员分配了空间，它可以被引用，即不随对象的建立而分配空间，也不随对象的撤销而释放，静态数据成员是程序在编译时被分配空间，到程序结束时释放空间

