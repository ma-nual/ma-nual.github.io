---
layout:     post
published:  true
title:      "C++11/14新特性"
subtitle:   "C++笔记"
date:       2021-2-16 21:00:00
author:     "Manual"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - C++
---

> 本文介绍了C++11/14新特性相关内容，主要是候捷老师的视频笔记

## Variadic Templates（可变模板参数）

```c++
//递归终结条件函数
void print()
{

}

//使用递归实现打印
template <typename T, typename... Types>                //这里的...是关键字的一部分
void print(const T& firstArg, const Types&... args)     //这里的...要写在自定义类型Types后面
{
  cout << firstArg << endl;
  print(args...);                                     //这里的...要写在变量args后面，代表args的所有参数
}

//输入
//print(7.5,"hello",bitset<16>(377),42);

//输出
//7.5
//hello
//0000000101111001
//42
```

函数使用可变模板参数，接受任意个数的参数和任意的参数类型，可以实现递归，把不定个数的参数一一分解，在可变模板参数内部可以使用*sizeof...(args)*得到实参的个数

```c++
template <typename... Types>
void print(const Types&... args)
{/*......*/}
```

同时定义上述函数，是合法的，函数特化程度这个更泛化，所以会调用之前的更特化的函数

**应用场景**

1. 哈希函数计算
2. tuple的实现

## 模板表达式中的空格

```c++
vector<list<int> >; //所有C++中都可使用
vector<list<int>>;  //C++11起可使用
```

在C++11之前，模板后面的尖括号需要空格，C++11之后就不需要了

## nullptr和std::nullptr

```c++
void f(int);
void f(void*); //函数重载
f(0); //调用f(int)
f(NULL); //如果NULL是0，调用f(int)，有歧义
f(nullptr); //调用f(void*)
```

使用nullptr代替NULL和0来代表指针没有指向值，这可以避免把空指针当int而引发错误，如上函数调用的实例，使用nullptr不会出现歧义，因为nullptr是std::nullptr_t类型，c++11以后，std::nullptr_t也是基础类型了，可以自己定义变量

## auto

```c++
list<string> c;
...
list<string>::iterator ite;
ite = find(c.begin(),c.end(),target);
//使用auto可以转换为
list<string> c;
...
auto ite = find(c.begin(),c.end(),target);
```

C++11之后，可以使用auto自动推导变量和对象的类型，主要用于类型名称长和类型复杂的情况，另外auto还可以自动推导lambda表达式的类型，然后就可以把lambda函数当普通函数使用

## Uniform Initialization（一致性初始化）

```c++
int values[]{1,2,3}; //一致性初始化
vector<int> v{2,3,5,7,11,13,17};
vector<string> cities{"Berlin","New York","London","Braunschweig","Cairo","Cologne"}; //这就会形成一个initializer_list<string>，背后有个array<string, 6>，vector<string>构造函数有接受initializer_list<string>的版本
complex<double> c{4.0,3.0}; //这就会形成一个initializer_list<double>，背后有个array<double, 2>，complex<double>构造函数没有接受initializer_list<double>的版本

//C++11以前初始化的方式
Rect r1 = {3,7,20,25,&area,&print};
Rext r1(3,7,20,25);
int ia[6] = {27,210,12,47,109,83};
```

C++11引入了一个通用的初始化方式——一致性初始化，使用大括号括起来进行初始化，编译器看到{ t1, t2, t3, ..., tn }这种初始化会转换成一个initializer_list<T>，它关联至一个array<T, n>，然后要分两种情况：

- 如果对象带有接受initializer_list的构造函数版本，那使用该构造函数进行初始化。（如上vector初始化）
- 如果对象没有initializer_list的构造函数版本，那编译器会将initializer_list逐一分解，传给对应的构造函数。（如上complex初始化）

另外，如果函数的参数就是initializer_list，那么就必须传入initializer_list，而不能传入多个T参数

## Initializer Lists（初始化列表）

```c++
int i; //i没定义
int j{}; //j初始化为0
int* p; //p没定义
int* q{}; //q初始化为nullptr

int x1(5.3); //可以但x1是5
int x2 = 5.3; //可以但x1是5
int x3{5.0}; //窄化转换，警告
int x4 = {5.3}; //窄化转换，警告
```

大括号可以设定初值（默认值），另外大括号初始化不允许窄化转换（书籍上这样说的，实际gcc只会给出警告，但这不是好习惯）

**initializer_list<>**

```c++
void print(std::initializer_list<int> vals){
  for(auto p = vals.begin(); p != vals.end(); ++p){
    std::cout << *p << "/n";
  }
}
//调用print函数
print({12,3,5,7,11,13,17}); //必须传给initializer_list一个initializer_list或{...}形式
```

C++11提供了一个std::initializer_list<>, 可以接受任意个数的相同类型

initializer_list的内部有一个array（指针）和一个长度，另外initializer_list的构造函数是私有的，但编译器当看到大括号的时候，就会调用这个构造函数，编译器有无上权力。initializer_list构造函数会传入array（C++11新提出的，对数组进行封装，可以使用算法库）的头部迭代器，以及它的长度，如果拷贝initializer_list，只是浅拷贝，指向同一个array以及得到同一个长度，max，min等函数都接受initializer_list