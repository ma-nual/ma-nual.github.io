---
layout:     post
published:  true
title:      "C++11/14新特性"
subtitle:   "C++笔记"
date:       2021-2-16 21:00:00
author:     "Manual"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - C++
---

> 本文介绍了C++11/14新特性相关内容，主要是候捷老师的视频笔记

## Variadic Templates（可变模板参数）

```c++
//递归终结条件函数
void print()
{

}

//使用递归实现打印
template <typename T, typename... Types>                //这里的...是关键字的一部分
void print(const T& firstArg, const Types&... args)     //这里的...要写在自定义类型Types后面
{
  cout << firstArg << endl;
  print(args...);                                     //这里的...要写在变量args后面，代表args的所有参数
}

//输入
//print(7.5,"hello",bitset<16>(377),42);

//输出
//7.5
//hello
//0000000101111001
//42
```

函数使用可变模板参数，接受任意个数的参数和任意的参数类型，可以实现递归，把不定个数的参数一一分解，在可变模板参数内部可以使用`sizeof...(args)`得到实参的个数

```c++
template <typename... Types>
void print(const Types&... args)
{/*......*/}
```

同时定义上述函数，是合法的，函数特化程度这个更泛化，所以会调用之前的更特化的函数

**应用场景**

1. 哈希函数计算
2. tuple的实现

## 模板表达式中的空格

```c++
vector<list<int> >; //所有C++中都可使用
vector<list<int>>;  //C++11起可使用
```

在C++11之前，模板后面的尖括号需要空格，C++11之后就不需要了

## nullptr和std::nullptr

```c++
void f(int);
void f(void*); //函数重载
f(0); //调用f(int)
f(NULL); //如果NULL是0，调用f(int)，有歧义
f(nullptr); //调用f(void*)
```

使用`nullptr`代替`NULL`和0来代表指针没有指向值，这可以避免把空指针当int而引发错误，如上函数调用的实例，使用`nullptr`不会出现歧义，因为`nullptr`是`std::nullptr_t`类型，C++11以后，`std::nullptr_t`也是基础类型了，可以自己定义变量

## auto

```c++
list<string> c;
...
list<string>::iterator ite;
ite = find(c.begin(),c.end(),target);
//使用auto可以转换为
list<string> c;
...
auto ite = find(c.begin(),c.end(),target);
```

C++11之后，可以使用auto自动推导变量和对象的类型，主要用于类型名称长和类型复杂的情况，另外auto还可以自动推导lambda表达式的类型，然后就可以把lambda函数当普通函数使用

## Uniform Initialization（一致性初始化）

```c++
int values[]{1,2,3}; //一致性初始化
vector<int> v{2,3,5,7,11,13,17};
vector<string> cities{"Berlin","New York","London","Braunschweig","Cairo","Cologne"}; //这就会形成一个initializer_list<string>，背后有个array<string, 6>，vector<string>构造函数有接受initializer_list<string>的版本
complex<double> c{4.0,3.0}; //这就会形成一个initializer_list<double>，背后有个array<double, 2>，complex<double>构造函数没有接受initializer_list<double>的版本

//C++11以前初始化的方式
Rect r1 = {3,7,20,25,&area,&print};
Rext r1(3,7,20,25);
int ia[6] = {27,210,12,47,109,83};
```

C++11引入了一个通用的初始化方式——一致性初始化，使用大括号括起来进行初始化，编译器看到`{ t1, t2, t3, ..., tn }`这种初始化会转换成一个`initializer_list<T>`，它关联至一个`array<T, n>`，然后要分两种情况：

- 如果对象带有接受`initializer_list`的构造函数版本，那使用该构造函数进行初始化。（如上vector初始化）
- 如果对象没有initializer_list的构造函数版本，那编译器会将`initializer_list`逐一分解，传给对应的构造函数。（如上complex初始化）

另外，如果函数的参数就是`initializer_list`，那么就必须传入`initializer_list`，而不能传入多个T参数

## Initializer Lists（初始化列表）

```c++
int i; //i没定义
int j{}; //j初始化为0
int* p; //p没定义
int* q{}; //q初始化为nullptr

int x1(5.3); //可以但x1是5
int x2 = 5.3; //可以但x1是5
int x3{5.0}; //窄化转换，警告
int x4 = {5.3}; //窄化转换，警告
```

大括号可以设定初值（默认值），另外大括号初始化不允许窄化转换（书籍上这样说的，实际gcc只会给出警告，但这不是好习惯）

**initializer_list<>**

```c++
void print(std::initializer_list<int> vals){
  for(auto p = vals.begin(); p != vals.end(); ++p){
    std::cout << *p << "/n";
  }
}
//调用print函数
print({12,3,5,7,11,13,17}); //必须传给initializer_list一个initializer_list或{...}形式
```

C++11提供了一个`std::initializer_list<>`, 可以接受任意个数的相同类型

`initializer_lis`t的内部有一个array（指针）和一个长度，另外`initializer_list`的构造函数是私有的，但编译器当看到大括号的时候，就会调用这个构造函数，编译器有无上权力。`initializer_list`构造函数会传入array（C++11新提出的，对数组进行封装，可以使用算法库）的头部迭代器，以及它的长度，如果拷贝`initializer_list`，只是浅拷贝，指向同一个array以及得到同一个长度，max，min等函数都接受`initializer_list`

## explicit

```c++
class P
{
public:
	explicit P(int a, int b, int c)
	{
	    cout << "P(int a, int b, int c)" << endl;
	}
};
 
P p = {1, 2, 3};    //报错，不能将initializer_list隐式转换为P
```

在构造函数前面加上`explicit`，就是告诉编译器，不能进行函数参数类型的隐式转换，只能通过显式地进行构造，如上例，构造函数不能将`initializer_list`隐式转换为P，但是如果定义了接受`initializer_list<int>`为参数的构造函数，就将会调用这个版本，不会报错，C++11之前`explicit`只对指定一个实参的函数有效，而现在对指定多个实参的函数也有效

## Range-based for statement

```c++
//形式
for(decl:coll){ //decl是申明，coll是容器，意思是一个个拿出coll中的元素
  statement
}
//实例1
for(int i:{2,3,5,7,9,13,17,19}){
  cout << i << endl;
}
//实例2
vector<double> vec;
...
for(auto elem:vec){ //可以搭配auto使用
  cout << elem << endl;
}
for(auto& elem:vec){ //需要引用的话，加上&即可
  elem *= 3;
}
```

## =default,=delete

如果自行定义一个构造函数，那么编译器就不会再给一个默认构造函数，如果强制加上`=default`，就可以重新获得并使用默认构造函数

```c++
class Zoo{
public:
  Zoo(int i1, int i2):d1(i1),d2(i2){ }
  Zoo(const Zoo&)=delete;
  Zoo(Zoo&&)=default;
  Zoo& operator=(const Zoo&)=default;
  Zoo&operator(const Zoo&&)=delete;
  virtual ~Zoo(){ }
private:
  intd1,d2;
};
```

`=default`要的是编译器给的默认构造函数，`=delete`是不要对应的构造函数，例如，上述的`Zoo(const Zoo&)=delete`是说不要拷贝构造，`Zoo(const Zoo&&)=default`是说要编译器默认给我的那一个

```c++
class Foo{
public:
  Foo(int i):_i(i){ }
  Foo()=default;
  
  Foo(const Foo& x):_i(x._i){ }
  //!Foo(const Foo&)=default;
  //!Foo(const Foo&)=delete;
  
  Foo& operator=(const Foo& x){_i = x._i;	return *this;}
  //!Foo& operator=(const Foo& x)=default;
  //!Foo& operator=(const Foo& x)=delete;
  
  //!void func1()=default;
  void func2()=delete;
  
  //!~Foo()=delete;
  ~Foo()=default;
  
private:
  int _i;
};
```

**构造函数**可以有多个版本，上述定义了两个`Foo`的构造函数，一个是有实参的，另一个使用`=default`得到编译器给出的默认构造函数。对于**拷贝构造函数**而言，只能允许一个，所以当使用`=default`的时候，由于已经写出一个了，就无法进行重载了（默认拷贝构造函数就是一个位一个位的拷贝），而使用`=delete`的时候，由于写出来了，无法进行删除了。**拷贝赋值函数**情况类似。对于**一般函数**来说，没有`default`版本，所以对一般函数进行`=default`是不对的，`=delete`可以有，但没必要，写出来不要还不如不写。**析构函数**定义为`=default`，语法上是可以的，但是在使用对象时肯定会报错，因为一个对象的生命周期总会结束的

`=default`，`=delete`与`=0`的区别在于`=default`只能用于big-five(构造函数，拷贝构造函数，拷贝赋值函数，析构函数，移动构造函数，移动赋值函数)， `=delete`可以用于任何函数，但有时没有必要使用，而`=0`只能用于虚函数，代表纯虚函数

对于一个空的class，C++会在空的class内部插入一些代码（默认的构造函数，拷贝构造函数，拷贝赋值函数以及析构函数，都是public并且是inline的），这样才会使构造，拷贝构造，拷贝赋值，析构的代码运行正常，这些默认的函数还给编译器放置藏身幕后的一些代码，比如当涉及继承的时候，调用base classes的构造和析构就会对应放置在默认生成的构造和析构当中

如果一个类带有指针成员，则需要自己定义big-three，而没有指针成员的话，用编译器默认提供的就足够了。complex就是直接使用编译器默认提供的拷贝赋值和析构，string就需要自己定义big-five

```c++
struct NoCopy{
  NoCopy()=default;
  NoCopy(const NoCopy&)=delete;
  NoCopy &operator=(const NoCopy&)=delete;
  ~NoCopy()=default;
};

struct NoDtor{
  NoDtor()=default;
  ~NoDtor()=delete; //带来严重后果
};

class PrivateCopy{
private:
  PrivateCopy(const PrivateCopy&);
  PrivateCopy &operator=(const PrivateCopy&);
public:
  PrivateCopy()=default;
  ~PrivateCopy();
};
```

class NoCopy把拷贝构造函数和拷贝赋值函数都`=delete`，不允许外界去拷贝这个类的对象，这个在一些事例上是有用的。class NoDtor则不要析构函数了，对象创建无法删除，会报错（一般不会这么使用）。最后的PrivateCopy把拷贝构造函数和拷贝赋值函数放入了`private`里面，这限制了访问这两个函数的使用者，一般用户代码无法调用，但友元以及成员函数可以进行拷贝

## Alias Template(template typedef)

```c++
template <typename T>
using Vec = std::vector<T,MyAlloc<T>>;

Vec<int> coll; //使用方法
//相当于
std::vector<int,MyAlloc<int>> coll;

//使用#define和typedef达不到相同效果
typedef std::vector<int,MyAlloc<int>> Vec; //不能使用模板
```

C++11引入了Alias Template，用法如上所示，先写`template `, 然后使用`using`命令设定别名模板，这样些可以自己设定类型以及容器的分配器，而使用`#define`和`typedef`不能达到效果，但别名模板有一个限制，不能进行偏特化

**template template parameter**

```c++
template <typename T,
          template <class>
              class Container
         >
class XCls
{
private:
    Container<T> c;
public:
    XCLs()
    {
        for(long i=0; i<SIZE; ++i)
            c.insert(c.end(), T());
 
        output_static_data(T());
        Container<T> c1(c);
        Container<T> c2(std::move(c));
        c1.swap(c2);
    }
};

//不得在function body之内声明
template<typename T>
using Vec = vector<T, allocator<T>>;
 
XCls<MyString, Vec> c1; //使用方法
```

`vector`其实有两个模板参数，虽然第二个有默认值，我们平时也可以像`vector<int>`这样用，但是在模板中直接这样写是不匹配的，所以这里就用到了模板别名，只要传入的是`vector`的模板别名就可以了，使用Alias Template，就可以将`Vec`变为一个模板参数的模板，然后就可以初始化对象，其中模板别名的定义不能在function body之内，也就是需要写在任何函数的外面，包括主函数，可以看到Alias Template不仅是少打几个字，还有减少模板参数个数以适配模板模板参数的功能，非常有用处