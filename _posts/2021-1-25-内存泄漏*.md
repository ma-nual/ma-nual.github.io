---
layout:     post
published:  true
title:      "内存泄漏"
subtitle:   "C++笔记"
date:       2021-1-25 19:00:00
author:     "Manual"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - C++
---

> 本文介绍了内存泄漏的相关知识

## 含义

内存泄漏是指动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，因而造成了内存的浪费。

内存泄漏的几种情况：

1. 在类的构造函数和析构函数中没有匹配使用new和delete函数

   1）在堆里创建了对象占用了内存，但是没有显示地释放对象占用的内存；

   2）在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存

2. 在释放对象数组时没有使用delete\[\]，使用了delete

   方括号是告诉编译器这个指针指向的是一个对象数组，同时也告诉编译器正确的对象地址值并调用对象的析构函数，如果没有方括号，那么这个指针就被默认为只指向一个对象，对象数组中的其他对象的析构函数就不会被调用，结果造成了内存泄露。如果在方括号中间放了一个比对象数组大小还大的数字，那么编译器就会调用无效对象（内存溢出）的析构函数，会造成堆的奔溃。如果方括号中间的数字值比对象数组的大小小的话，编译器就不能调用足够多个析构函数，结果会造成内存泄露。

   释放单个对象，单个基本数据类型的变量或者是基本数据类型的数组不需要大小参数，释放定义了析构函数的对象数组才需要大小参数。

3. 没有将基类的析构函数定义为虚函数

   当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露

4. 没有正确的清除嵌套的对象指针

5. 指向对象的指针数组只释放了每个对象的空间，没有释放每个指针的空间

   **指向对象的指针数组**不等同于**对象数组**

   对象数组是指：数组中存放的是对象，只需要调用对象数组中的每个对象的析构函数释放空间。

   指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了。

6. 缺少拷贝构造函数

   按值传递会调用（拷贝）构造函数，引用传递不会调用。在C++中，如果没有定义拷贝构造函数，那么编译器就会调用默认的拷贝构造函数，会逐个成员拷贝的方式来复制数据成员，如果是以逐个成员拷贝的方式来复制指针被定义为将一个变量的地址赋给另一个变量。这种隐式的指针复制结果就是两个对象拥有指向同一个动态分配的内存空间的指针，当释放第一个对象的时候，它的析构函数就会释放与该对象有关的动态分配的内存空间，而释放第二个对象的时候，它的析构函数会释放相同的内存，两次释放相同的内存是一种错误的做法，同时可能会造成堆的奔溃。

   所以，如果一个类里面有指针成员变量，要么必须显示的写拷贝构造函数和拷贝赋值函数，要么禁用拷贝构造函数和拷贝赋值函数。

7. 缺少拷贝赋值函数

   拷贝赋值函数也是逐个成员拷贝的方式复制对象，如果这个类的大小是可变的，那么结果就是造成内存泄露，如图：

   ![因缺少赋值运算符造成的内存泄漏](/img/img-post/因缺少赋值运算符造成的内存泄漏.png)

## 如何检测内存泄漏，并定位内存泄漏的位置（补充）

Linux系统下内存泄漏的检测方法，**valgrind**，**mtrace**，或者对new/malloc进行**统计监测**，看和delete/free次数是否一致。

## 如何避免和解决内存泄漏

1. malloc/free要配套；
2. 使用智能指针；
3. 将基类的析构函数设为虚函数；

## 内存泄漏和内存溢出的区别

**内存泄漏 memory leak** ：是指程序向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果导致一直占据该内存。
**内存溢出 out of memory** ：指程序申请内存时，没有足够的内存供申请者使用，即给了一块存储int类型数据的存储空间，但是申请者却存储long类型的数据，申请者要的内存空间超过了系统实际分配的空间，结果内存不够用。

内存泄漏的堆积最终会导致内存溢出。
